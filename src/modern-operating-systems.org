#+title: 现代操作系统(Modern Operating Systems)

https://book.douban.com/subject/3852290/

Unix的最基本的方针：
1. 所有的东西都是文件
2. 每个程序都应该只做一件事情，并且要做好。
3. 程序员需要计算机是仆人而不是保姆。

Unix实用程序分为6大类
- 文件和目录管理命令
- 过滤器
- 程序开发工具如编辑器和编译器
- 文本处理
- 系统管理
- 杂项

POSIX标准为100多个实用程序制定了语法和语义，主要是针对前三类程序。标准化这些实用程序思想是使人核能都能够编写shell脚本，并且使用这些程序能在所有的Unix系统里面运行。

抽象很重要，同时需要兼顾效率.微软公司清醒地认识到这一点，并尝试做一个很小的底层，以隐藏不同机器之间的差异，这一层被称为硬件抽象层(Hardware Abstraction Layer,HAL).谣传这个名字是IBM每个字母减1的结果HAL的作用是将操作系统的其余部分表示为抽象的硬件设备，特别是去除了真正硬件所附函的瑕疵和特质。这些设备表现为操作系统的其他部分和设备可以使用的独立与机器的服务和形式(函数调用和宏)。通过使用HAL服务和间接硬件寻址，当移植到新的硬件上时，驱动程序和核心秩序作很少的改动。移植HAL本身是直接的，因为所有的机器相关的代码都集中到一个地方，并且移植的目标是充分定义的，即实现所有的HAL服务。尽管HAL已经相当高效，但是对于多媒体应用而言，它的速度可能还不够快。为此，微软公司另外直接提供了一个名为DirectX的软件包，它用附加的过程增强了HAL，并允许用户进程对硬件进行直接的访问。一个操作系统最重要但可能最困难的任务是定义正确的抽象概念。有一些抽象概念，例如进程和文件，已经存在多年似乎显而易见。其他一些抽象概念，例如线程还比较新鲜，就不是那么成熟了。

接口设计的原则：
1. 简单 不是有东西可以在添加，而是没有东西可以再裁减时，才能达到尽善尽美。
2. 完备 万事都应该尽可能的简单，但不能过于简单。首先，重要的是强调简单和精炼的价值，因为复杂容易导致增加困难并且产生错误，正如我们已经看到的那样。我对精炼的定义是以机制的最少化和清晰度的最大化实现指定的功能。
3. 效率

添加更多的代码就是添加更多的程序错误。

对于性能优化的一条相当适用的口号是：“足够好才是足够好。”通过这条口号我们表达的意思是：性能一旦达到一个合理的水平，榨取最后一点百分比的努力和复杂性或许并不值得。如果调度算法相当公平并且在90%时间内保持CPU忙碌，它就尽到了自己的职责。发明一个改进了5%但是要复杂得多的算法或许是一个坏主意。

程序员是天生的乐观主义者。他们中的大多数人为编写程序的方式就是急切地奔向键盘并且开始击键，不久以后完全调试好的程序就完成了。然而对于大型程序，事实并非如此。

对于人员与时间的权衡，Brooks在他的《人月神话》中将他的经验总结在Brooks定律中：“对于一个延期的软件项目，增加人力将使他更加延期。”用稍微有意思的方法阐述就是“无论分配多少妇女从事这一工作，生一个孩子都需要9个月”。

任何大型的设计项目中包括软件和其他工程，最重要的是需要体系结构的一致性。应该有一名才智超群的人对设计进行控制。Brooks引证了兰斯大教堂作为大型项目的例子。兰斯大教堂的建造花费了几十年的时间，在这一过程中，后来的建筑师完全服从于完成最初建筑师的规划，结果是其他欧洲大教堂无可比拟的建筑构造的一致性。值得注意的是，最为成功的开放源代码项目显然是用了首席程序员模式，有一名才智超群者控制着体系结构的设计，Linus Torvalds控制着Linux内核，Richard Stallman控制着GNU C编译器。

拥有丰富经验的设计人鱼对于一个操作系统来说至关重要。大多数程序错误不是在代码中，而是在设计中。程序员正确作了吩咐他们要所的事情，而吩咐他们要做的事情是错误的。再多的测试软件都无法弥补糟糕的设计说明书。
