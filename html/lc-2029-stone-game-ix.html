<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LC 2029. 石子游戏 IX</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">LC 2029. 石子游戏 IX</h1>
<p>
<a href="https://leetcode-cn.com/problems/stone-game-ix/">https://leetcode-cn.com/problems/stone-game-ix/</a>
</p>

<p>
这题我估计看题解肯定也是看不懂，所以这题还是自己想办法。这题最简单的办法还是模拟，但是状态肯定很大，理论上是N[0] * N[1] * N[2]这么多个状态。但是有几个特点，可以让我们对状态进行化简：
</p>

<ol class="org-ol">
<li>N[0] 也就是 x%3=0 这个状态，其实只需要保存0/1即可。因为如果Alice拿一个0, Bob也可以拿一个0, 这样状态其实就和原来完全一致而不会有任何变化。所以最终只有一个人会使用0进行一次翻转。</li>
<li>如果一开始Alice拿2，那么Bob肯定拿2，接着Alice拿1，然后Bob继续拿2，如此往复。可以写成2 - (2-1) - (2-1) 。。。 所以每个1-2对其实是可以消除的。</li>
<li>但是也不是完全消除，为了进入某个状态，可以至少保留一个1或者是2。</li>
</ol>

<p>
这样下来：
</p>
<ul class="org-ul">
<li>N[0] 只有2个状态</li>
<li>N[1] 也只有2个状态（假设1的状态比2少）</li>
<li>N[2] 可能有很多状态，但是搜索会很快结束，所以不会是瓶颈。</li>
</ul>

<p>
这种博弈搜索的算法很少写，总结一下就是几乎不需要考虑是alice还是bob拿。虽然我代码里面有 `ab` 这个参数，这个参数是为了知道最后一次清空的时候是谁，但是其他min/max部分是没有考虑ab参数的。
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-py-def-class">class</span> <span class="org-py-class-name">Solution</span>:
    <span class="org-py-def-class">def</span> <span class="org-function-name">stoneGameIX</span>(<span class="org-py-object-reference">self</span>, stones: List[<span class="org-py-builtins">int</span>]) -&gt; <span class="org-py-builtins">bool</span>:
        <span class="org-py-variable-name">cnt</span> = [<span class="org-py-number">0</span>] * <span class="org-py-number">3</span>
        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> stones:
            <span class="org-py-variable-name">cnt</span>[x % <span class="org-py-number">3</span>] += <span class="org-py-number">1</span>
        <span class="org-py-variable-name">cnt</span>[<span class="org-py-number">0</span>] %= <span class="org-py-number">2</span>

        <span class="org-py-variable-name">mx</span> = <span class="org-py-builtins">max</span>(<span class="org-py-number">0</span>, <span class="org-py-builtins">min</span>(cnt[<span class="org-py-number">1</span>], cnt[<span class="org-py-number">2</span>]) - <span class="org-py-number">1</span>)
        <span class="org-py-variable-name">cnt</span>[<span class="org-py-number">1</span>] -= mx
        <span class="org-py-variable-name">cnt</span>[<span class="org-py-number">2</span>] -= mx

        <span class="org-py-def-class">def</span> <span class="org-function-name">search</span>(t, cnt, ab):
            <span class="org-keyword">if</span> <span class="org-py-builtins">sum</span>(cnt) == <span class="org-py-number">0</span>:
                <span class="org-comment"># if this is alice, then lose</span>
                <span class="org-comment"># else win.</span>
                <span class="org-keyword">return</span> ab

            <span class="org-py-variable-name">values</span> = [<span class="org-py-number">1</span>]
            <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">3</span>):
                <span class="org-keyword">if</span> (i + t) % <span class="org-py-variable-name">3</span> == <span class="org-py-number">0</span>: <span class="org-keyword">continue</span>
                <span class="org-keyword">if</span> cnt[i] &gt; <span class="org-py-number">0</span>:
                    <span class="org-py-variable-name">cnt2</span> = cnt.copy()
                    <span class="org-py-variable-name">cnt2</span>[i] -= <span class="org-py-number">1</span>
                    <span class="org-py-variable-name">x</span> = search(t + i, cnt2, <span class="org-py-number">1</span> - ab)
                    values.append(x)

            <span class="org-py-variable-name">m</span> = <span class="org-py-builtins">min</span>(values)
            <span class="org-keyword">return</span> <span class="org-py-number">1</span> - m

        <span class="org-py-variable-name">ans</span> = search(<span class="org-py-number">0</span>, cnt, <span class="org-py-number">0</span>)
        <span class="org-keyword">return</span> <span class="org-py-variable-name">ans</span> == <span class="org-py-number">1</span>
</pre>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/lc-2029-stone-game-ix.html';this.page.identifier = 'lc-2029-stone-game-ix.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
