<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LC 2157. 字符串分组</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">LC 2157. 字符串分组</h1>
<p>
<a href="https://leetcode-cn.com/problems/groups-of-strings/">https://leetcode-cn.com/problems/groups-of-strings/</a>
</p>

<p>
如果按照修改状态去枚举的话，那么修改状态可能会多达 26*26 种，如果乘以N = 2*10^4的话，那么肯定会出现超时。我花了很多时间在优化这个操作上，但是方向却是错误的。
</p>

<p>
题解里面这个解法非常不错 <a href="https://leetcode-cn.com/problems/groups-of-strings/solution/jiang-ti-huan-cao-zuo-de-fu-za-du-you-o2-951t/">https://leetcode-cn.com/problems/groups-of-strings/solution/jiang-ti-huan-cao-zuo-de-fu-za-du-you-o2-951t/</a> 大致思想是：
</p>
<ul class="org-ul">
<li>对于增加和删除一个字符操作，可以使用 `st ^ (1&lt;&lt;i)` 来完成</li>
<li>对于更换一个字符操作，可以可以使用 `st ^ (1&lt;&lt;i) | (1 &lt;&lt; 26)`, 相当于做个标记</li>
<li>这个标记意味着可以替换任何字符串，类似 "*bc" 这样</li>
</ul>

<p>
然后就是使用并集查找的数据结构，不过这里稍微有点特殊的是，对于更换一个字符操作可能产生的状态是不确定的。
</p>

<p>
leetcode上面总是有这些好题，工程量不是那么大，对于基础知识要求也不是特别高，但实现的时候需要想想和稍微绕点弯子。
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-py-def-class">class</span> <span class="org-py-class-name">UnionFind</span>:
    <span class="org-py-def-class">def</span> <span class="org-function-name">__init__</span>(<span class="org-py-object-reference">self</span>, values):
        r, c, = {}, {}
        <span class="org-keyword">for</span> v <span class="org-keyword">in</span> values:
            r[v], <span class="org-py-variable-name">c</span>[v] = v, <span class="org-py-number">1</span>
        <span class="org-py-object-reference">self</span>.r, <span class="org-py-object-reference">self</span>.c = r, c

    <span class="org-py-def-class">def</span> <span class="org-function-name">size</span>(<span class="org-py-object-reference">self</span>, a):
        <span class="org-py-variable-name">ra</span> = <span class="org-py-object-reference">self</span>.find(a)
        <span class="org-keyword">return</span> <span class="org-py-object-reference">self</span>.c[ra]

    <span class="org-py-def-class">def</span> <span class="org-function-name">find</span>(<span class="org-py-object-reference">self</span>, a):
        <span class="org-keyword">if</span> a <span class="org-keyword">not</span> <span class="org-keyword">in</span> <span class="org-py-object-reference">self</span>.r:
            <span class="org-py-object-reference">self</span>.r[a] = a
            <span class="org-py-object-reference">self</span>.c[a] = <span class="org-py-number">1</span>
            <span class="org-keyword">return</span> a

        <span class="org-comment"># find root.</span>
        <span class="org-py-variable-name">x</span> = a
        <span class="org-keyword">while</span> <span class="org-py-pseudo-keyword">True</span>:
            <span class="org-py-variable-name">ra</span> = <span class="org-py-object-reference">self</span>.r[x]
            <span class="org-keyword">if</span> <span class="org-py-variable-name">ra</span> == x:
                <span class="org-keyword">break</span>
            <span class="org-py-variable-name">x</span> = ra

        <span class="org-comment"># compress path.</span>
        <span class="org-py-variable-name">x</span> = a
        <span class="org-keyword">while</span> x != ra:
            <span class="org-py-variable-name">rx</span> = <span class="org-py-object-reference">self</span>.r[x]
            <span class="org-py-object-reference">self</span>.r[x] = ra
            <span class="org-py-variable-name">x</span> = rx
        <span class="org-keyword">return</span> ra

    <span class="org-py-def-class">def</span> <span class="org-function-name">merge</span>(<span class="org-py-object-reference">self</span>, a, b):
        <span class="org-py-variable-name">ra</span>, <span class="org-py-variable-name">rb</span> = <span class="org-py-object-reference">self</span>.find(a), <span class="org-py-object-reference">self</span>.find(b)
        <span class="org-keyword">if</span> <span class="org-py-variable-name">ra</span> == rb:
            <span class="org-keyword">return</span>
        <span class="org-py-variable-name">ca</span>, <span class="org-py-variable-name">cb</span> = <span class="org-py-object-reference">self</span>.c[ra], <span class="org-py-object-reference">self</span>.c[rb]
        <span class="org-keyword">if</span> ca &gt; cb:
            <span class="org-py-variable-name">ca</span>, <span class="org-py-variable-name">cb</span>, <span class="org-py-variable-name">ra</span>, <span class="org-py-variable-name">rb</span> = cb, ca, rb, ra
        <span class="org-py-object-reference">self</span>.r[ra] = rb
        <span class="org-py-object-reference">self</span>.c[rb] += ca


<span class="org-py-def-class">class</span> <span class="org-py-class-name">Solution</span>:
    <span class="org-py-def-class">def</span> <span class="org-function-name">groupStrings</span>(<span class="org-py-object-reference">self</span>, words: List[<span class="org-py-builtins">str</span>]) -&gt; List[<span class="org-py-builtins">int</span>]:
        <span class="org-py-def-class">def</span> <span class="org-function-name">value</span>(w):
            <span class="org-py-variable-name">st</span> = <span class="org-py-number">0</span>
            <span class="org-keyword">for</span> c <span class="org-keyword">in</span> w:
                <span class="org-py-variable-name">c2</span> = <span class="org-py-builtins">ord</span>(c) - <span class="org-py-builtins">ord</span>(<span class="org-string">'a'</span>)
                <span class="org-py-variable-name">st</span> = st | (<span class="org-py-number">1</span> &lt;&lt; c2)
            <span class="org-keyword">return</span> st

        <span class="org-py-variable-name">values</span> = [value(w) <span class="org-keyword">for</span> w <span class="org-keyword">in</span> words]
        <span class="org-py-variable-name">un</span> = UnionFind(values)
        <span class="org-py-variable-name">tmp</span> = <span class="org-py-builtins">set</span>(values)

        <span class="org-keyword">for</span> st <span class="org-keyword">in</span> values:
            <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">26</span>):
                <span class="org-py-variable-name">st2</span> = st ^ (<span class="org-py-number">1</span> &lt;&lt; i)
                <span class="org-keyword">if</span> st2 <span class="org-keyword">in</span> tmp:
                    un.merge(st, st2)

            <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">26</span>):
                <span class="org-keyword">if</span> st &amp; (<span class="org-py-number">1</span> &lt;&lt; i):
                    <span class="org-py-variable-name">st2</span> = (<span class="org-py-number">1</span> &lt;&lt; <span class="org-py-number">26</span>) | (st ^ (<span class="org-py-number">1</span> &lt;&lt; i))
                    un.merge(st, st2)

        <span class="org-py-variable-name">d</span> = Counter(un.find(st) <span class="org-keyword">for</span> st <span class="org-keyword">in</span> values)
        <span class="org-keyword">return</span> [<span class="org-py-builtins">len</span>(d), <span class="org-py-builtins">max</span>(d.values())]
</pre>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/lc-2157-groups-of-strings.html';this.page.identifier = 'lc-2157-groups-of-strings.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
