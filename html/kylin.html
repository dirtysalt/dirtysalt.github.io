<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>kylin</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="dirtysalt" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content">
<h1 class="title">kylin</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. share</a>
<ul>
<li><a href="#sec-1-1">1.1. atomic</a></li>
<li><a href="#sec-1-2">1.2. spinlock</a></li>
<li><a href="#sec-1-3">1.3. cycle</a></li>
<li><a href="#sec-1-4">1.4. support</a></li>
<li><a href="#sec-1-5">1.5. futex</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. sema</a></li>
<li><a href="#sec-1-5-2">1.5.2. cond</a></li>
<li><a href="#sec-1-5-3">1.5.3. event</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. kylin</a>
<ul>
<li><a href="#sec-2-1">2.1. Async</a></li>
<li><a href="#sec-2-2">2.2. ThreadPool</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Overview</a></li>
<li><a href="#sec-2-2-2">2.2.2. How Thread Works</a></li>
<li><a href="#sec-2-2-3">2.2.3. AddWorker &amp; DelWorker</a></li>
<li><a href="#sec-2-2-4">2.2.4. QueueJob &amp; CancelJob</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. TranBuf</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. Overview</a></li>
<li><a href="#sec-2-3-2">2.3.2. Create</a></li>
<li><a href="#sec-2-3-3">2.3.3. AllocOnce</a></li>
<li><a href="#sec-2-3-4">2.3.4. GetHandle</a></li>
<li><a href="#sec-2-3-5">2.3.5. AddRef</a></li>
<li><a href="#sec-2-3-6">2.3.6. Destroy</a></li>
<li><a href="#sec-2-3-7">2.3.7. Allocate</a></li>
<li><a href="#sec-2-3-8">2.3.8. Free</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4. BufHandle</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. OverView</a></li>
<li><a href="#sec-2-4-2">2.4.2. SetTranBuf</a></li>
<li><a href="#sec-2-4-3">2.4.3. DoAllocate</a></li>
<li><a href="#sec-2-4-4">2.4.4. DoAllocateCanFail</a></li>
<li><a href="#sec-2-4-5">2.4.5. _DoAddRef</a></li>
<li><a href="#sec-2-4-6">2.4.6. _DoFree</a></li>
<li><a href="#sec-2-4-7">2.4.7. AllocateBig</a></li>
<li><a href="#sec-2-4-8">2.4.8. AllocateCanFail</a></li>
<li><a href="#sec-2-4-9">2.4.9. AllocForBuf</a></li>
<li><a href="#sec-2-4-10">2.4.10. Allocate</a></li>
<li><a href="#sec-2-4-11">2.4.11. ChainFree</a></li>
<li><a href="#sec-2-4-12">2.4.12. CloneAndTerminate</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5. Kylin</a></li>
<li><a href="#sec-2-6">2.6. ExecMan</a>
<ul>
<li><a href="#sec-2-6-1">2.6.1. Overview</a></li>
<li><a href="#sec-2-6-2">2.6.2. Start &amp; Stop</a></li>
<li><a href="#sec-2-6-3">2.6.3. QueueExec</a></li>
<li><a href="#sec-2-6-4">2.6.4. Timer</a></li>
<li><a href="#sec-2-6-5">2.6.5. Example</a></li>
</ul>
</li>
<li><a href="#sec-2-7">2.7. DiskMan</a>
<ul>
<li><a href="#sec-2-7-1">2.7.1. Overview</a></li>
<li><a href="#sec-2-7-2">2.7.2. Start &amp; Stop</a></li>
<li><a href="#sec-2-7-3">2.7.3. Associate &amp; Deassociate</a></li>
<li><a href="#sec-2-7-4">2.7.4. Read &amp; Write</a></li>
<li><a href="#sec-2-7-5">2.7.5. Example</a></li>
</ul>
</li>
<li><a href="#sec-2-8">2.8. NetworkMan</a>
<ul>
<li><a href="#sec-2-8-1">2.8.1. Overview</a></li>
<li><a href="#sec-2-8-2">2.8.2. Start &amp; Stop</a></li>
<li><a href="#sec-2-8-3">2.8.3. Associate &amp; Deassociate</a></li>
<li><a href="#sec-2-8-4">2.8.4. Listen</a></li>
<li><a href="#sec-2-8-5">2.8.5. Connect</a></li>
<li><a href="#sec-2-8-6">2.8.6. Monitor</a></li>
<li><a href="#sec-2-8-7">2.8.7. Delay</a></li>
<li><a href="#sec-2-8-8">2.8.8. Read &amp; Write</a></li>
<li><a href="#sec-2-8-9">2.8.9. SocketState</a></li>
</ul>
</li>
<li><a href="#sec-2-9">2.9. EPoller</a>
<ul>
<li><a href="#sec-2-9-1">2.9.1. Overview</a></li>
<li><a href="#sec-2-9-2">2.9.2. Create &amp; Close</a></li>
<li><a href="#sec-2-9-3">2.9.3. Associate &amp; Deassociate</a></li>
<li><a href="#sec-2-9-4">2.9.4. DoConnect</a></li>
<li><a href="#sec-2-9-5">2.9.5. Delay &amp; CancalDelay</a></li>
<li><a href="#sec-2-9-6">2.9.6. DoWithDelayed &amp; DoWithError</a></li>
<li><a href="#sec-2-9-7">2.9.7. Read &amp; Write</a></li>
<li><a href="#sec-2-9-8">2.9.8. NofityClient</a></li>
<li><a href="#sec-2-9-9">2.9.9. Run</a></li>
</ul>
</li>
<li><a href="#sec-2-10">2.10. Socket</a>
<ul>
<li><a href="#sec-2-10-1">2.10.1. Overview</a></li>
<li><a href="#sec-2-10-2">2.10.2. Create</a></li>
<li><a href="#sec-2-10-3">2.10.3. Close</a></li>
<li><a href="#sec-2-10-4">2.10.4. Shutdown</a></li>
<li><a href="#sec-2-10-5">2.10.5. Listen</a></li>
<li><a href="#sec-2-10-6">2.10.6. Connect</a></li>
<li><a href="#sec-2-10-7">2.10.7. Read &amp; Write</a></li>
<li><a href="#sec-2-10-8">2.10.8. OnCompletion</a></li>
<li><a href="#sec-2-10-9">2.10.9. Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. demo</a>
<ul>
<li><a href="#sec-3-1">3.1. echo</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. client.cc</a></li>
<li><a href="#sec-3-1-2">3.1.2. server.cc</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. file-request</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. client.cc</a></li>
<li><a href="#sec-3-2-2">3.2.2. server.cc</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
kylin是baidu in-house的异步编程框架，提供CPU，Network以及Disk异步操作接口，并且内置许多常用编程组件包括定时器和内存池等。
</p>

<ul class="org-ul">
<li>异步编程_百度文库 : <a href="http://wenku.baidu.com/view/6fa262f67c1cfad6195fa74e.html">http://wenku.baidu.com/view/6fa262f67c1cfad6195fa74e.html</a>
</li>
<li>三谈火车票系统_新浪轻博客 : <a href="http://qing.blog.sina.com.cn/tj/85c4105033000ab2.html">http://qing.blog.sina.com.cn/tj/85c4105033000ab2.html</a>
</li>
<li>SEDA: An Architecture for Well-Conditioned, Scalable Internet Services <a href="http://www.eecs.harvard.edu/~mdw/papers/seda-sosp01.pdf">http://www.eecs.harvard.edu/~mdw/papers/seda-sosp01.pdf</a>
</li>
<li>Why Threads Are a Bad Idea <a href="http://www.stanford.edu/class/cs240/readings/threads-bad-usenix96.pdf">http://www.stanford.edu/class/cs240/readings/threads-bad-usenix96.pdf</a>
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> share</h2>
<div class="outline-text-2" id="text-1">
<p>
公共组件代码
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> atomic</h3>
<div class="outline-text-3" id="text-1-1">
<p>
最主要实现了atomic add/swap/cas三个操作。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">return old value</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">atomic_add</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">count</span>, <span class="org-type">int</span> <span class="org-variable-name">add</span>) {
    <span class="org-keyword">__asm__</span> __volatile__(
        <span class="org-string">"lock xadd %0, (%1);"</span>
        : <span class="org-string">"=a"</span>(add)
        : <span class="org-string">"r"</span>(count), <span class="org-string">"a"</span>(add)
        : <span class="org-string">"memory"</span>);
    <span class="org-keyword">return</span> add;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">return old value</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">atomic_swap</span>(<span class="org-keyword">volatile</span> <span class="org-type">void</span> *<span class="org-variable-name">lockword</span>, <span class="org-type">int</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">__asm__</span> __volatile__(
        <span class="org-string">"lock xchg %0, (%1);"</span>
        : <span class="org-string">"=a"</span>(value)
        : <span class="org-string">"r"</span>(lockword), <span class="org-string">"a"</span>(value)
        : <span class="org-string">"memory"</span>);
    <span class="org-keyword">return</span> value;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">return old value</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#35821;&#20041;&#26159;&#36825;&#26679;&#30340;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;*lockword==comperand,&#37027;&#20040;*lockword=exchange</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#19981;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#21407;&#22987;&#30340;*lockword</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;cmpxchg x y&#30340;&#35821;&#20041;&#26159;&#36825;&#26679;&#30340;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;y==%%eax,&#37027;&#20040;x-&gt;y.&#21542;&#21017;&#19981;&#21464;&#12290;&#28982;&#21518;y(&#21407;&#22987;)-&gt;%%eax</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">atomic_comp_swap</span>(<span class="org-keyword">volatile</span> <span class="org-type">void</span> *<span class="org-variable-name">lockword</span>,
                                   <span class="org-type">int</span> <span class="org-variable-name">exchange</span>,
                                   <span class="org-type">int</span> <span class="org-variable-name">comperand</span>)
{
    <span class="org-keyword">__asm__</span> __volatile__(
        <span class="org-string">"lock cmpxchg %1, (%2)"</span>
        :<span class="org-string">"=a"</span>(comperand)
        :<span class="org-string">"d"</span>(exchange), <span class="org-string">"r"</span>(lockword), <span class="org-string">"a"</span>(comperand));
    <span class="org-keyword">return</span> comperand;
}
</pre>
</div>
<p>
然后再上面封装了一系列原子操作。封装的一系列原子操作还是比较好理解的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#define</span> <span class="org-function-name">AtomicGetValue</span>(<span class="org-variable-name">x</span>)    (atomic_comp_swap(&amp;(x), 0, 0))
<span class="org-preprocessor">#define</span> <span class="org-function-name">AtomicSetValue</span>(<span class="org-variable-name">x</span>, <span class="org-variable-name">v</span>)    (atomic_swap(&amp;(x), (v)))
<span class="org-preprocessor">#define</span> <span class="org-function-name">AtomicSetValueIf</span>(<span class="org-variable-name">x</span>, <span class="org-variable-name">v</span>, <span class="org-variable-name">ifn</span>)(atomic_comp_swap(&amp;(x), (v), ifn))
<span class="org-preprocessor">#define</span> <span class="org-function-name">AtomicDec</span>(<span class="org-variable-name">c</span>)    (atomic_add(&amp;(c), -1) - 1)
<span class="org-preprocessor">#define</span> <span class="org-function-name">AtomicInc</span>(<span class="org-variable-name">c</span>)    (atomic_add(&amp;(c), 1) + 1)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> spinlock</h3>
<div class="outline-text-3" id="text-1-2">
<p>
spinlock直接使用atomic提供的原子操作来实现，理解起来倒不是很麻烦
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">spin_lock</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">lock</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">l</span>;
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = 10;
    <span class="org-type">int</span> <span class="org-variable-name">id</span> = thread_getid();
    <span class="org-comment-delimiter">//</span><span class="org-comment">l==0&#30340;&#35805;&#35828;&#26126;&#21407;&#26469;lock==0&#28982;&#21518;&#34987;&#32622;&#20026;id</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">l==id&#30340;&#35805;&#35828;&#26126;&#21407;&#26469;lock==id&#37027;&#20040;&#23601;&#19981;&#24517;&#22312;&#36827;&#34892;&#21152;&#38145;&#25805;&#20316;</span>
    <span class="org-keyword">for</span> (l=atomic_comp_swap(lock, id, 0);
         l!=0 &amp;&amp; l!=id;
         l=atomic_comp_swap(lock, id, 0)
         ) {
        <span class="org-keyword">if</span> (i --) {
            nop();
        }
        <span class="org-keyword">else</span> {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#36827;&#34892;10&#27425;nop&#20043;&#21518;&#22914;&#26524;&#27809;&#26377;&#24471;&#21040;&#38145;&#30340;&#35805;</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#23601;&#30452;&#25509;relinquish CPU</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">#define thread_yield sched_yield</span>
            i = 10;
            thread_yield();
        }
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#20540;&#21487;&#20197;&#30693;&#36947;&#20043;&#21069;lock&#26159;&#21542;&#38145;&#22312;&#33258;&#24049;&#36825;&#37324;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20026;false&#30340;&#35805;&#34920;&#31034;&#33258;&#24049;&#24182;&#27809;&#26377;&#38145;</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">spin_unlock</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">lock</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">id</span> = thread_getid();
    <span class="org-keyword">return</span> id == atomic_comp_swap(lock, 0, id);
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">spin_trylock</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">lock</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">id</span> = thread_getid();
    <span class="org-type">int</span> <span class="org-variable-name">owner</span> = atomic_comp_swap(lock, id, 0);
    <span class="org-keyword">return</span> (owner==0 || owner==id);
}
</pre>
</div>

<p>
在spinlock.h下面有一个token实现。token语义非常简单，如果token==0的话那么这个令牌没有被任何人获得，
如果token!=0的话，那么令牌被token标记的对象获取了。token可以是pid,也可以是tid.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">token_acquire</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">token</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">return</span> atomic_comp_swap(token, id, 0);
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">token_release</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">token</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">return</span> atomic_comp_swap(token, 0, id);
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">token_transfer</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">token</span>, <span class="org-type">int</span> <span class="org-variable-name">oldid</span>, <span class="org-type">int</span> <span class="org-variable-name">newid</span>) {
    <span class="org-keyword">return</span> atomic_comp_swap(token, newid, oldid);
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">token_set</span>(<span class="org-keyword">volatile</span> <span class="org-type">int</span> *<span class="org-variable-name">token</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">return</span> atomic_comp_swap(token, id, *token);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> cycle</h3>
<div class="outline-text-3" id="text-1-3">
<p>
提供开销更小的计时器，使用读取CPU的time stamp counter.这个内容表示自计算机启动以来的CPU运行周期。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">uint64</span> <span class="org-function-name">rdtsc</span>() {
    <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">lo</span>, <span class="org-variable-name">hi</span>;
    <span class="org-comment-delimiter">/* </span><span class="org-comment">We cannot use "=A", since this would use %rax on x86_64 */</span>
    <span class="org-keyword">__asm__</span> __volatile__ (
        <span class="org-string">"rdtsc"</span>
        : <span class="org-string">"=a"</span> (lo), <span class="org-string">"=d"</span> (hi));
    <span class="org-keyword">return</span> (<span class="org-type">uint64</span>)hi &lt;&lt; 32 | lo;
}
</pre>
</div>
<p>
得到周期之后我们必须转换称为时间(s)。周期转换称为时间就是除CPU的主频。得到CPU主频的话没有什么特别好的办法，
一种简单的方法是通过等待1s然后得到tsc差。对于Linux操作系统的话可以通过读取proc文件系统获得
</p>
<pre class="example">
[zhangyan@tc-cm-et18.tc.baidu.com]$ cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 12
model name      : Intel(R) Xeon(R) CPU           E5620  @ 2.40GHz
stepping        : 2
cpu MHz         : 2400.186
cache size      : 256 KB
physical id     : 0
siblings        : 16
core id         : 0
cpu cores       : 16
fpu             : yes
fpu_exception   : yes
cpuid level     : 11
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx lm pni monitor ds_cpl est tm2 cx16 xtpr
bogomips        : 4803.76
clflush size    : 64
cache_alignment : 64
address sizes   : 40 bits physical, 48 bits virtual
power management:
</pre>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> support</h3>
<div class="outline-text-3" id="text-1-4">
<p>
从这里面我们可以学习到如何进行系统调用，阅读一下&lt;asm/unistd.h&gt;可以找到系统调用号，然后使用syscall来发起。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/syscall.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    printf(<span class="org-string">"%lu\n"</span>,syscall(__NR_gettid));
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> futex</h3>
<div class="outline-text-3" id="text-1-5">
<p>
关于futex的话可以看看下面这些链接
</p>
<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/Futex">http://en.wikipedia.org/wiki/Futex</a>
</li>
<li><a href="http://linux.die.net/man/2/futex">http://linux.die.net/man/2/futex</a>
</li>
<li><a href="http://blog.csdn.net/Javadino/article/details/2891385">http://blog.csdn.net/Javadino/article/details/2891385</a>
</li>
<li><a href="http://blog.csdn.net/Javadino/article/details/2891388">http://blog.csdn.net/Javadino/article/details/2891388</a>
</li>
<li><a href="http://blog.csdn.net/Javadino/article/details/2891399">http://blog.csdn.net/Javadino/article/details/2891399</a>
</li>
<li><a href="http://people.redhat.com/drepper/futex.pdf">http://people.redhat.com/drepper/futex.pdf</a>
</li>
</ul>
<p>
尤其是最后一篇文章可以好好看看，讲到了关于如何使用futex.futex使用需要用户态和内核态的配合，用户态处理一些uncontented case,
而对于contented case的话交给内核态处理。在实际应用上发现大部分情况都是uncontented case都可以在用户态解决而不用陷入内核态。
如果想要深入了解的话，看看pthread里面同步组件的实现。
</p>

<p>
这里我们简单地介绍一下kylin里面使用futex实现的功能，先看看futex结构
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">futex</span> {
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">lock</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">futex shared address</span>
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">count</span>;
};
</pre>
</div>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> sema</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
可以认为是操作系统里面的PV实现.count就是资源数目，lock始终==0.理解起来并不会很麻烦。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">futex_sema_down</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>, <span class="org-keyword">struct</span> <span class="org-type">timespec</span>* <span class="org-variable-name">timeout</span>, <span class="org-type">bool</span> <span class="org-variable-name">interruptable</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#22312;&#29992;&#25143;&#24577;&#23581;&#35797;&#21462;&#36164;&#28304;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;n&gt;0&#30340;&#35805;&#65292;&#35828;&#26126;&#36164;&#28304;OK,&#37027;&#20040;&#23601;&#19981;&#38656;&#35201;&#38519;&#20837;&#20869;&#26680;&#24577;&#36827;&#34892;wait.</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = atomic_add(&amp;pf-&gt;count, -1);
    <span class="org-keyword">if</span> (n &lt;= 0) {
  <span class="org-constant">retry</span>:
        <span class="org-keyword">if</span> (0 == sys_futex(&amp;pf-&gt;lock, FUTEX_WAIT, 0, timeout)) {
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-keyword">switch</span> (errno) {
            <span class="org-keyword">case</span> ETIMEDOUT:
                atomic_add(&amp;pf-&gt;count, 1);
                <span class="org-keyword">return</span> ETIMEDOUT;
            <span class="org-keyword">case</span> EINTR:
                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>interruptable)
                    <span class="org-keyword">goto</span> <span class="org-constant">retry</span>;
                atomic_add(&amp;pf-&gt;count, 1);
                <span class="org-keyword">return</span> EINTR;
            <span class="org-keyword">default</span>:
                RaiseError(IMPOSSIBLE__Can_not_lock_in_futex_sema_down);
        }
    }
    <span class="org-keyword">return</span> 0;
}
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">futex_sema_up</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">retry</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#22312;&#29992;&#25143;&#24577;&#37322;&#25918;&#36164;&#28304;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;n&lt;0&#30340;&#35805;&#65292;&#35828;&#26126;&#23384;&#22312;&#31561;&#24453;&#36164;&#28304;&#30340;waiters,&#25105;&#20204;&#24517;&#39035;&#38519;&#20837;&#20869;&#26680;&#24577;wakeup.</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = atomic_add(&amp;pf-&gt;count, 1);
    <span class="org-keyword">if</span> (n &lt; 0) {
        retry = 10;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#22320;&#26041;&#20889;&#24471;&#38750;&#24120;&#20180;&#32454;&#38656;&#35201;&#37325;&#35797;</span>
        <span class="org-keyword">while</span> (1 != (n=sys_futex(&amp;pf-&gt;lock, FUTEX_WAKE, 1, <span class="org-constant">NULL</span>))) {
            <span class="org-comment-delimiter">/* </span><span class="org-comment">it means the downer decreases the count but not yet start waiting</span>
<span class="org-comment">             *   --- may be interrupted near the retry label in the above function;</span>
<span class="org-comment">             * so we have to wait and retry.</span>
<span class="org-comment">             */</span>
            <span class="org-keyword">if</span> (retry --) {
                nop();
            }
            <span class="org-keyword">else</span> {
                retry = 10;
                thread_yield();
            }
        }
        <span class="org-keyword">return</span> n;
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> cond</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
这里cond和pthread_cond是有差别的，这里的cond没有和任何mutex相关。kylin这里认为count==0的时候，那么condition才被满足。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">futex_cond_wait</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>, <span class="org-keyword">struct</span> <span class="org-type">timespec</span>* <span class="org-variable-name">timeout</span>, <span class="org-type">bool</span> <span class="org-variable-name">interruptable</span>) {
    <span class="org-comment-delimiter">/* </span><span class="org-comment">I dont know whether it is a bug of linux kernel.</span>
<span class="org-comment">     * Sometimes, sys_futex(.., FUTEX_WAIT, ..) returns 0, but the condition is not satisfied.</span>
<span class="org-comment">     * So we have to check the condition again after return.</span>
<span class="org-comment">     */</span>
    <span class="org-keyword">while</span> (0 &lt; AtomicGetValue(pf-&gt;count)) {
        sys_futex(&amp;pf-&gt;lock, FUTEX_WAIT, 0, timeout);
        <span class="org-keyword">switch</span> (errno) {
            <span class="org-keyword">case</span> ETIMEDOUT:
                <span class="org-keyword">return</span> ETIMEDOUT;
            <span class="org-keyword">case</span> EINTR:
                <span class="org-keyword">if</span> (interruptable) {
                    <span class="org-keyword">return</span> EINTR;
                }
            <span class="org-keyword">default</span>:
                <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">futex_cond_signal</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = atomic_add(&amp;pf-&gt;count, -1);
    <span class="org-keyword">if</span> (1 == n) {
        pf-&gt;lock = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#26086;&#35302;&#21457;&#20043;&#21518;&#65292;&#37027;&#20040;&#23601;&#19981;&#33021;&#22815;&#20877;&#36827;&#34892;wait&#20102;&#12290;</span>
        mfence_c();
        <span class="org-keyword">return</span> sys_futex(&amp;pf-&gt;lock, FUTEX_WAKE, 65535, <span class="org-constant">NULL</span>);<span class="org-comment-delimiter">// </span><span class="org-comment">I hope 65535 is enough to wake up all</span>
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> event</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
这里的event名字取得也相当的奇怪。这里count实际上有两个状态，&gt;=0以及&lt;0(LARGE_ENOUGH_NEGATIVE).对于count&gt;=0的状态时候，
可以认为当前是没有signaled的需要wait，如果count为&lt;0(LARGE_ENOUGH_NEGATIVE)的时候是有signal的状态的不需要wait。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">futex_event_wait</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>, <span class="org-keyword">struct</span> <span class="org-type">timespec</span>* <span class="org-variable-name">timeout</span>, <span class="org-type">bool</span> <span class="org-variable-name">interruptable</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;signaled&#29366;&#24577;&#30340;&#35805;</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = atomic_add(&amp;pf-&gt;count, 1);
    <span class="org-keyword">if</span> (0 &lt;= n) {
  <span class="org-constant">retry</span>:
        <span class="org-keyword">if</span> (0 == sys_futex(&amp;pf-&gt;lock, FUTEX_WAIT, 0, timeout))
            <span class="org-keyword">return</span> 0;

        <span class="org-keyword">switch</span> (errno) {
            <span class="org-keyword">case</span> ETIMEDOUT:
                atomic_add(&amp;pf-&gt;count, -1);
                <span class="org-keyword">return</span> ETIMEDOUT;
            <span class="org-keyword">case</span> EINTR:
                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>interruptable)
                    <span class="org-keyword">goto</span> <span class="org-constant">retry</span>;
                atomic_add(&amp;pf-&gt;count, -1);
                <span class="org-keyword">return</span> EINTR;
            <span class="org-keyword">default</span>:
                RaiseError(IMPOSSIBLE__Can_not_lock_in_futex_sema_down);
        }
    }
    <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">// </span><span class="org-comment">else signaled</span>
        AtomicSetValue(pf-&gt;count, LARGE_ENOUGH_NEGATIVE);
    }
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">futex_event_signal</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>, <span class="org-type">bool</span> <span class="org-variable-name">reset</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">m</span>, <span class="org-variable-name">n</span>, <span class="org-variable-name">retry</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#30475;&#30475;&#24403;&#21069;&#26159;&#21542;signaled</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;signal&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;wakeup&#36825;&#20123;waiters.</span>
    n = AtomicSetValue(pf-&gt;count, reset ? 0 : LARGE_ENOUGH_NEGATIVE);
    <span class="org-keyword">if</span> (0 &lt; n) {
        retry = 10;
        m = n;
        <span class="org-keyword">do</span> {
            n -= sys_futex(&amp;pf-&gt;lock, FUTEX_WAKE, n, <span class="org-constant">NULL</span>);
            <span class="org-keyword">if</span> (0 == n)
                <span class="org-keyword">return</span> m;
            <span class="org-keyword">if</span> (retry --) {
                nop();
            }
            <span class="org-keyword">else</span> {
                retry = 10;
                thread_yield();
            }
        } <span class="org-keyword">while</span> (1);
    }
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">futex_event_reset</span>(<span class="org-keyword">struct</span> <span class="org-type">futex</span>* <span class="org-variable-name">pf</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-variable-name">retry</span> = 10;
    <span class="org-keyword">do</span> {
        n = AtomicSetValueIf(pf-&gt;count, 0, LARGE_ENOUGH_NEGATIVE);
        <span class="org-keyword">if</span> (0&lt;=n || LARGE_ENOUGH_NEGATIVE==n) {
            <span class="org-keyword">return</span>;
        }
        <span class="org-keyword">if</span> (retry --) {
            nop();
        }
        <span class="org-keyword">else</span> {
            retry = 10;
            thread_yield();
        }
    } <span class="org-keyword">while</span> (1);
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> kylin</h2>
<div class="outline-text-2" id="text-2">
<p>
异步框架代码
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Async</h3>
<div class="outline-text-3" id="text-2-1">
<p>
kylin对于用户来说首先需要了解的概念就在Async.h文件里面，主要是下面两个类
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-type">void</span> (*<span class="org-type">JOB_PROC</span>)(<span class="org-type">Job</span>*);

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;Job&#36825;&#20010;&#20869;&#23481;&#25105;&#20204;&#31245;&#21518;&#22312;ThreadPool&#37096;&#20998;&#20250;&#26377;&#35814;&#32454;&#20998;&#26512;</span>
<span class="org-keyword">struct</span> <span class="org-type">Job</span> {
    <span class="org-type">DLINK</span> <span class="org-variable-name">link</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;link&#30340;&#35805;&#21487;&#20197;&#23558;Job&#22312;JobQ&#20013;&#20018;&#32852;&#36215;&#26469;&#21487;&#20197;&#24456;&#26041;&#20415;&#22320;&#21462;&#28040;</span>
    <span class="org-type">JOB_PROC</span> <span class="org-variable-name">fProc</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">&#32447;&#31243;&#27744;&#37324;&#38754;&#21253;&#21547;JobQ,&#27599;&#21462;&#19968;&#20010;Job&#20986;&#26469;&#20043;&#21518;&#23601;&#25191;&#34892;fProc.</span>
};

<span class="org-keyword">class</span> <span class="org-type">CAsyncClient</span>;
<span class="org-keyword">struct</span> <span class="org-type">AsyncContext</span> : <span class="org-type">Job</span> {
    <span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;&#35843;&#29992;&#20043;&#21518;&#36820;&#22238;&#30340;error_code</span>
    <span class="org-type">int</span> <span class="org-variable-name">nAction</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;&#20160;&#20040;&#35843;&#29992;</span>
    <span class="org-type">CAsyncClient</span> *<span class="org-variable-name">pClient</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24212;&#35813;&#20351;&#29992;&#20160;&#20040;client&#26469;&#22788;&#29702;</span>
};

<span class="org-keyword">class</span> <span class="org-type">CAsyncClient</span>
{
<span class="org-keyword">protected</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">m_nId&#20165;&#20165;&#26159;&#19968;&#20010;&#32534;&#21495;&#65292;&#27599;&#27425;&#21019;&#24314;&#19968;&#20010;AsyncClient&#37117;&#20250;&#20840;&#23616;+1</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">m_nHostId&#38750;&#24120;&#37325;&#35201;&#65292;&#20351;&#29992;&#36825;&#20010;&#21487;&#20197;&#23558;Job&#25511;&#21046;&#20002;&#21040;&#21738;&#20010;&#32447;&#31243;&#25191;&#34892;</span>
    <span class="org-type">int</span> <span class="org-variable-name">m_nId</span>, <span class="org-variable-name">m_nHostId</span>;
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">m_nRef</span>;
    <span class="org-function-name">CAsyncClient</span>(<span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pHost</span>);
    <span class="org-function-name">CAsyncClient</span>();
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">CAsyncClient</span>();
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">GetId</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> m_nId; }
    <span class="org-type">int</span> <span class="org-function-name">GetAsyncId</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> m_nHostId; }
    <span class="org-type">int</span> <span class="org-function-name">GetHostThreadId</span>() <span class="org-keyword">const</span>;
    <span class="org-type">bool</span> <span class="org-function-name">IsInHostThread</span>() <span class="org-keyword">const</span>;
    <span class="org-type">void</span> <span class="org-function-name">SetHost</span>(<span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pHost</span>);
    <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">AddRef</span>() {
        <span class="org-keyword">return</span> AtomicInc(m_nRef);
    }
    <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">Release</span>() {
        <span class="org-keyword">return</span> AtomicDec(m_nRef);
    }
    <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">GetRef</span>() {
        <span class="org-keyword">return</span> AtomicGetValue(m_nRef);
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>) = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#25143;&#38656;&#35201;&#37325;&#20889;&#36825;&#20010;&#36807;&#31243;</span>
};
</pre>
</div>
<p>
对于用户来说使用过程大致是这样的：
</p>
<ul class="org-ul">
<li>创建一个CAsyncClient client实例.当然是我们自己需要继承CAsyncClient重写自己的类。
</li>
<li>创建一个AsyncContext ctx(或者是集成AsyncContext).然后将ctx和client绑定。
</li>
<li>发起调用op，传入这个ctx，为了方便理解包装成为Task(op,ctx)放入线程池。可能会设置nAction字段。
</li>
<li>线程池取出Task,结合ctx调用op.将op返回值放入APF_ERROR里面。
</li>
<li>然后根据ctx关联的client,调用client的OnCompletion方法。
</li>
<li>调用OnCompletion方法的话会根据ctx里面的标记，可以直接在工作线程调用，也可以丢入CPU线程调用。
</li>
</ul>
<p>
可以看到在实现时候，最好一个client就绑定几个相关的ctx最方便了。这里有一个地方需要特别关注就是引用计数。因为C++本身没有GC实现，所以我们必须自己来管理内存分配和释放。
因为client可以一次多个调用，而在OnCompletion里面根本不知道谁先完成谁后完成，也就不能够确定释放责任了。通过引用计数可以很好地解决这个问题。
如果我们直接继承CAsyncClient的话，内部是有引用计数实现的，非常方便我们只需要如何适当地使用就OK了。关于如何适当使用，谢谢sunxiao同学在这里的建议。
</p>
<ul class="org-ul">
<li>一旦发起一次异步调用，那么首先AddRef().当然需要确保这个调用内部没有帮助我们AddRef.
</li>
<li>我们不需要显示地DecRef(),因为这个事情在线程池fProc里面调用了Release.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> ThreadPool</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
线程池很简单，取出一个Job出来执行就多了。但是为了更好地理解kylin有必要看看线程池接口/实现。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-type">void</span> (*<span class="org-type">THREAD_INIT_PROC</span>)(<span class="org-type">int</span> <span class="org-variable-name">type</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">id&#34920;&#31034;&#36825;&#20010;&#32447;&#31243;&#30340;&#36923;&#36753;&#32534;&#21495;</span>

<span class="org-keyword">class</span> <span class="org-type">CThreadPool</span>
{
    <span class="org-type">bool</span> <span class="org-variable-name">m_bShareQ</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#25152;&#26377;&#32447;&#31243;&#20849;&#20139;&#19968;&#20010;Q</span>
    <span class="org-type">int</span> <span class="org-variable-name">m_nWorkers</span>, <span class="org-variable-name">m_nMaxWorkers</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#32447;&#31243;&#25968;&#21644;&#26368;&#22823;&#32447;&#31243;&#25968;</span>
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">m_nJobs</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#26377;&#22810;&#23569;&#20010;Jobs</span>
    <span class="org-type">thread_t</span> *<span class="org-variable-name">m_hWorkerThreads</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32447;&#31243;&#30340;thread&#32467;&#26500;</span>
    <span class="org-type">WorkerContext</span> *<span class="org-variable-name">m_pContexts</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32447;&#31243;&#30340;context</span>
    <span class="org-type">int</span> <span class="org-variable-name">m_nType</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20160;&#20040;&#31867;&#22411;&#32447;&#31243;&#27744;,TT_EXEC,TT_NETWORK,TT_DISK</span>
    <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">m_fInit</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32447;&#31243;&#21021;&#22987;&#21270;&#22238;&#35843;&#20989;&#25968;</span>

    <span class="org-type">int</span> <span class="org-function-name">_AddWorker</span>(<span class="org-type">int</span> <span class="org-variable-name">nAdd</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22686;&#21152;&#22810;&#23569;&#20010;&#24037;&#20316;&#32447;&#31243;</span>
    <span class="org-type">int</span> <span class="org-function-name">_DelWorker</span>(<span class="org-type">int</span> <span class="org-variable-name">nDel</span>, <span class="org-type">bool</span> <span class="org-variable-name">bFinal</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21462;&#28040;&#22810;&#23569;&#20010;&#24037;&#20316;&#32447;&#31243;</span>
  <span class="org-keyword">public</span>:
    <span class="org-function-name">CThreadPool</span>(<span class="org-type">int</span> <span class="org-variable-name">type</span>, <span class="org-type">int</span> <span class="org-variable-name">nMaxWorkers</span>, <span class="org-type">bool</span> <span class="org-variable-name">bShareQ</span>);
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">CThreadPool</span>();
    <span class="org-type">int</span> <span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nWorkers</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>=<span class="org-constant">NULL</span>);
    <span class="org-type">void</span> <span class="org-function-name">Stop</span>();
    <span class="org-type">void</span> <span class="org-function-name">QueueJob</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>, <span class="org-type">int</span> <span class="org-variable-name">nWhich</span>);
    <span class="org-type">void</span> <span class="org-function-name">QueueEmergentJob</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>, <span class="org-type">int</span> <span class="org-variable-name">nWhich</span>);
    <span class="org-type">bool</span> <span class="org-function-name">CancelJob</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>, <span class="org-type">int</span> <span class="org-variable-name">nWhich</span>);
};
</pre>
</div>
<p>
对于线程池部分的话我们比较关心这么几件事情：
</p>
<ul class="org-ul">
<li>如何增加删除线程的
</li>
<li>线程是如何进行工作的
</li>
<li>如何往线程里面增加取消任务
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> How Thread Works</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
了解线程是怎么工作的，可以看看线程执行的函数是怎么定义的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span>*
<span class="org-function-name">WorkerProc</span>(<span class="org-type">void</span>* <span class="org-variable-name">pData</span>)
{
    <span class="org-type">WorkerContext</span>* <span class="org-variable-name">pCtx</span> = (<span class="org-type">WorkerContext</span>*)pData;
    <span class="org-type">JobQ</span>* <span class="org-variable-name">pJobQ</span> = pCtx-&gt;pJobQ;
    <span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>;

    TRACE4(<span class="org-string">"%s worker#%d started...\n"</span>, ThreadType2Str(pCtx-&gt;type), pCtx-&gt;id);
    pCtx-&gt;thread_id = thread_getid();
    <span class="org-keyword">if</span> (pCtx-&gt;fInit) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26377;&#21021;&#22987;&#21270;&#20989;&#25968;&#30340;&#35805;&#37027;&#20040;&#25191;&#34892;&#21021;&#22987;&#21270;&#20989;&#25968;</span>
        pCtx-&gt;fInit(pCtx-&gt;type, pCtx-&gt;id);
    }
    <span class="org-keyword">while</span> (1) {
        pJob = pJobQ-&gt;pop_front(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#27425;&#24471;&#21040;&#19968;&#20010;Job</span>
        ASSERT_NOT_EQUAL((<span class="org-type">Job</span>*)<span class="org-constant">NULL</span>, pJob);
        <span class="org-keyword">if</span> (pJob-&gt;fProc != 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#26222;&#36890;Job&#30340;&#35805;&#37027;&#20040;&#26159;&#35843;&#29992;&#37324;&#38754;&#30340;Job::fProc&#36807;&#31243;</span>
            pCtx-&gt;bDoing = <span class="org-constant">true</span>;
            pJob-&gt;fProc(pJob);
            pCtx-&gt;bDoing = <span class="org-constant">false</span>;
        }
        <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#26159;&#25511;&#21046;Job&#65292;&#20027;&#35201;&#26159;&#29992;&#20110;&#32467;&#26463;&#32447;&#31243;&#20351;&#29992;&#30340;</span>
            <span class="org-type">ControlJob</span>* <span class="org-variable-name">pCtl</span> = (<span class="org-type">ControlJob</span>*)pJob;
            <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>pCtl-&gt;fProc(pCtl, pCtx)) {
                <span class="org-keyword">break</span>;
            }
        }
    }
    TRACE4(<span class="org-string">"%s worker#%d stopped.\n"</span>, ThreadType2Str(pCtx-&gt;type), pCtx-&gt;id);
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>

<p>
普通的Job会在每个Man里面单独提到，我们看看控制Job是怎么定义的。在ThreadPool里面就有一个TermianationJob.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">TerminationJob</span> : <span class="org-type">ControlJob</span> {
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
};

<span class="org-keyword">static</span> <span class="org-type">bool</span>
<span class="org-function-name">TerminateWorker</span>(<span class="org-type">ControlJob</span>* <span class="org-variable-name">pCtl</span>, <span class="org-type">WorkerContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-type">TerminationJob</span>* <span class="org-variable-name">pT</span> = (<span class="org-type">TerminationJob</span>*)pCtl;
    <span class="org-keyword">if</span> (pT-&gt;id!=-1 &amp;&amp; pT-&gt;id!=pCtx-&gt;id) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#22240;&#20026;&#20849;&#20139;&#38431;&#21015;&#32780;&#27809;&#26377;&#35753;&#23545;&#24212;&#32447;&#31243;&#24471;&#21040;Job&#30340;&#35805;&#65292;&#37027;&#20040;&#37325;&#26032;&#25918;&#20837;&#36825;&#20010;Job.</span>
        pCtx-&gt;pJobQ-&gt;push_back((<span class="org-type">Job</span>*)pCtl); <span class="org-comment-delimiter">// </span><span class="org-comment">should be shared queue</span>
        thread_yield();                     <span class="org-comment-delimiter">// </span><span class="org-comment">re-enqueue this job until the owner consumes it</span>
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
<p>
通过这种方式来通知线程主动退出。理论上因为shared Queue可能会造成所有永远不会退出但是实际应该不会。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> AddWorker &amp; DelWorker</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
AddWorker非常简单
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">CThreadPool</span>::<span class="org-function-name">_AddWorker</span>(<span class="org-type">int</span> <span class="org-variable-name">nAdd</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    <span class="org-keyword">for</span> (i=0; i&lt;nAdd &amp;&amp; m_nWorkers&lt;m_nMaxWorkers; i++) {
        m_pContexts[m_nWorkers].fInit = m_fInit;
        <span class="org-keyword">if</span> (m_pContexts[m_nWorkers].pJobQ == <span class="org-constant">NULL</span>) {
            m_pContexts[m_nWorkers].pJobQ = <span class="org-keyword">new</span> <span class="org-type">JobQ</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#20026;&#27599;&#19968;&#20010;WorkerContext&#20998;&#37197;&#19968;&#20010;JobQ.&#23545;&#20110;&#20849;&#20139;Q&#30340;&#35805;&#22312;&#21021;&#22987;&#21270;&#23601;&#20998;&#37197;&#22909;&#20102;&#12290;</span>
        }
        <span class="org-keyword">if</span> (0 != thread_create(&amp;m_hWorkerThreads[m_nWorkers], <span class="org-constant">NULL</span>, WorkerProc, &amp;m_pContexts[m_nWorkers])) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#21551;&#21160;&#32447;&#31243;&#21363;&#21487;</span>
            PERROR(<span class="org-string">"thread_create"</span>);
            <span class="org-keyword">break</span>;
        }
        m_nWorkers ++;
    }
    <span class="org-keyword">return</span> i;
}
</pre>
</div>

<p>
DelWorker因为有ControlJob的辅助所以可以很好地解决，只需要在每个线程后面增加一个TerminationJob即可
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">CThreadPool</span>::<span class="org-function-name">_DelWorker</span>(<span class="org-type">int</span> <span class="org-variable-name">nDel</span>, <span class="org-type">bool</span> <span class="org-variable-name">bFinal</span>)
{
    <span class="org-type">TerminationJob</span> *<span class="org-variable-name">pTerminations</span> = <span class="org-keyword">new</span> <span class="org-type">TerminationJob</span>[nDel];
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    TRACE4(<span class="org-string">"%s start terminating %d workers...\n"</span>, ThreadType2Str(m_nType), nDel);
    <span class="org-keyword">for</span> (i=0; <span class="org-type">i</span>&lt;nDel &amp;&amp; m_nWorkers&gt;0; i++) {
        m_nWorkers --;
        DLINK_INITIALIZE(&amp;pTerminations[m_nWorkers].link);
        pTerminations[m_nWorkers].fZero = 0;
        pTerminations[m_nWorkers].fProc = TerminateWorker;
        pTerminations[m_nWorkers].id = bFinal ? -1 : m_nWorkers;
        m_pContexts[m_nWorkers].pJobQ-&gt;push_back((<span class="org-type">Job</span>*)&amp;pTerminations[m_nWorkers]);
    }
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span>=m_nWorkers; j&lt;i+m_nWorkers; j++) {
        TRACE4(<span class="org-string">"%s wait for worker #%d.\n"</span>, ThreadType2Str(m_nType), j);
        thread_join(m_hWorkerThreads[j], <span class="org-constant">NULL</span>);
    }
    TRACE4(<span class="org-string">"%s end terminating workers.\n"</span>, ThreadType2Str(m_nType));
    <span class="org-keyword">delete</span>[] pTerminations;
    <span class="org-keyword">return</span> i;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> QueueJob &amp; CancelJob</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
相对来说QueueJob也更加简单一些，直接投递到某个线程对应的WorkerContext里面即可。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">QueueJob</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>, <span class="org-type">int</span> <span class="org-variable-name">nWhich</span>) {
     <span class="org-type">int</span> <span class="org-variable-name">nJobs</span> = atomic_add(&amp;m_nJobs, 1);
    <span class="org-keyword">if</span> (-1 == nWhich) {
        nWhich = nJobs % m_nWorkers;
    }
    atomic_add(&amp;m_pContexts[nWhich].nJobs, 1);
    m_pContexts[nWhich].pJobQ-&gt;push_back(pJob);
}
</pre>
</div>

<p>
而CancelJob则是通过加锁替换这个Job来完成的，还是比较精巧的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span>
<span class="org-function-name">DoNothing</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>)
{
    free(pJob);
}

<span class="org-type">bool</span> <span class="org-constant">CThreadPool</span>::<span class="org-function-name">CancelJob</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>, <span class="org-type">int</span> <span class="org-variable-name">nWhich</span>)
{
    <span class="org-type">Job</span>* <span class="org-variable-name">p</span> = ZeroAlloc&lt;<span class="org-type">Job</span>&gt;(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#37197;&#19968;&#20010;Job,&#32780;DoNothing&#23601;&#26159;&#23558;&#20854;&#37322;&#25918;&#25481;</span>
    p-&gt;fProc = DoNothing;
    <span class="org-keyword">if</span> (m_pContexts[nWhich].pJobQ-&gt;replace(pJob, p)) { <span class="org-comment-delimiter">// </span><span class="org-comment">replace&#36825;&#20010;&#24037;&#20316;&#26159;&#19968;&#20010;&#21152;&#38145;&#23436;&#25104;&#30340;</span>
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
    free(p); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;Cancel&#30340;&#35805;&#37027;&#20040;&#36820;&#22238;&#22833;&#36133;&#20294;&#26159;&#20063;&#20250;&#37322;&#25918;&#25481;&#20869;&#23384;</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> TranBuf</h3>
<div class="outline-text-3" id="text-2-3">
<p>
TranBuf.h CTranBufPool是一个内存分配器。对于很多系统来说，合理地使用资源是非常必要的。
</p>

<p>
作者linsd对于内存分配器看法是这样的：
</p>
<blockquote>
<p>
要得到稳定的高吞吐，对内存的合理使用是必要条件。是否用Ring Buffer倒不一定，简单的buffer pool效果也差不多。另外，为了应付极限情况，还需要为buffer请求分级，当资源不足时优先给紧急请求。也可设定高低几条watermark，让各种复杂条件下的资源使用变得平顺。
</p>
</blockquote>
<p>
了解一下真实系统里面定制化的内存分配器是非常有帮助的(相对应地来说 <a href="TCMalloc.html">TCMalloc</a> 是通用内存分配器).
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
首先看看CTranBufPool的数据结构，看看里面每个字段含义和作用.对于TranBuf来说的话内部
本质还是一个sample allocator，也是按照固定的BlockSize来进行分配的。构造函数可以看到水位线三个阈值都是0.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">CTranBufPool</span> : <span class="org-keyword">public</span> <span class="org-type">CBufPoolV</span> {
  <span class="org-keyword">struct</span> <span class="org-type">Handle</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;BlockSize&#23383;&#33410;&#20869;&#23384;&#20869;&#23384;&#30001;&#19968;&#20010;Handle&#31649;&#29702;.</span>
    <span class="org-type">DLINK</span> <span class="org-variable-name">link</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#37197;&#20986;&#26469;&#20043;&#21518;&#22810;&#20010;Handle&#32452;&#25104;&#29615;&#24418;&#21452;&#21521;&#38142;&#34920;.</span>
    <span class="org-type">char</span>* <span class="org-variable-name">pBuffer</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#20010;BlockSize&#30340;&#20869;&#23384;.</span>
    <span class="org-type">Handle</span>* <span class="org-variable-name">pRealHdl</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#30495;&#23454;Handler.&#36825;&#20010;&#20250;&#22312;&#21518;&#38754;&#35299;&#37322;.</span>
    <span class="org-type">int</span> <span class="org-variable-name">nRef</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24341;&#29992;&#35745;&#25968;.</span>
    <span class="org-type">int</span> <span class="org-variable-name">nConsBuf</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#33258;&#24049;&#24341;&#29992;&#30340;pBuffer&#21518;&#38754;&#36824;&#26377;&#22810;&#23569;&#20010;&#36830;&#32493;&#20869;&#23384;.</span>
  };
  <span class="org-keyword">typedef</span> <span class="org-type">TLinkedList</span>&lt;<span class="org-type">Handle</span>&gt; <span class="org-type">FreeList</span>; <span class="org-comment-delimiter">//</span>
  <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">map</span>&lt;<span class="org-type">char</span>*, <span class="org-type">Handle</span>*&gt; <span class="org-type">BufferMap</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">buffer&#21644;Handle&#26144;&#23556;.</span>

  <span class="org-type">FreeList</span> <span class="org-variable-name">m_FreeList</span>;
  <span class="org-type">BufferMap</span> <span class="org-variable-name">m_BufferMap</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nBlockSize &#27599;&#20010;sample object&#21363;BlockSize</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nBufferSize 1&#27425;&#36830;&#32493;&#24320;&#36767;&#22810;&#23569;&#23383;&#33410;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nBlockBase log2(BlockSize)</span>
  <span class="org-type">int</span> <span class="org-variable-name">m_nBlockSize</span>, <span class="org-variable-name">m_nBufferSize</span>, <span class="org-variable-name">m_nBlockBase</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nAlloc &#19968;&#27425;&#24320;&#36767;&#22810;&#23569;&#20010;BlockSize.&#20854;&#20013;m_nBufferSize=nAlloc*m_nBlockSize</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nMaxBuffers &#26368;&#22810;&#20998;&#37197;&#22810;&#23569;&#20010;Blcok</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nBuffers &#24403;&#21069;&#20998;&#37197;&#20102;&#22810;&#23569;&#20010;Block</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nWaterMarks &#20998;&#20026;3&#20010;&#27700;&#20301;&#32447;</span>
  <span class="org-type">int</span> <span class="org-variable-name">m_nAlloc</span>, <span class="org-variable-name">m_nMaxBuffers</span>, <span class="org-variable-name">m_nBuffers</span>, <span class="org-variable-name">m_nWaterMarks</span>[3];

  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nMin. &#19968;&#24320;&#22987;&#33267;&#23569;&#20998;&#37197;m_nMin*nAlloc&#20010;Block</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">m_nMax &#26368;&#22810;&#20998;&#37197;m_nMax*nAlloc&#21733;block.&#20854;&#20013;m_nMaxBuffers=m_nMax*nAlloc.</span>
  <span class="org-type">int</span> <span class="org-variable-name">m_nMin</span>, <span class="org-variable-name">m_nMax</span>;
};

  <span class="org-function-name">CTranBufPool</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">nCategory</span>) : CBufPoolV(name, nCategory) {
    m_nBuffers = 0;
    m_nBlockSize = m_nBufferSize = m_nAlloc = m_nMaxBuffers = m_nMin = 0;
    m_nWaterMarks[0] = m_nWaterMarks[1] = m_nWaterMarks[2] = 0;
</pre>
</div>
<p>
可以看到TranBuf分配方式是每次分配nAlloc个Block(这个过程在后面叫做AllocOnce).每个Block是BlockSize字节.
然后至少分配m_nMin*nAlloc(首先调用m_nMin个AllocOnce过程),最多分配m_nMax*nAlloc个Block.每个内存
不够的话都会调用AllocOnce这个过程。
</p>

<p>
这里稍微解释一下RealHdl这个字段的意思。对于单个Block分配出来的内存块，RealHdl==this.但是如果是
连续跨越多个Block内存快的话，那么每个Block对应的Handle里面RealHdl对应的是首地址的Handle.这样做的好处就是，
如果希望对这个内存块增加或者是减少引用计数的话，只是指引到一个Handle，对里面字段修改引用计数。否则的话，
需要遍历每个Block对应的Handle修改引用技术。
</p>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> Create</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
大部分Create代码都是在设置参数，最后调用m_nMin次AllocOnce来分配初始的内存块。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-function-name">Create</span>(<span class="org-type">int</span> <span class="org-variable-name">nBlockSize</span>, <span class="org-type">int</span> <span class="org-variable-name">nAlloc</span>, <span class="org-type">int</span> <span class="org-variable-name">nMin</span>, <span class="org-type">int</span> <span class="org-variable-name">nMax</span>, <span class="org-type">double</span> <span class="org-variable-name">fRatio1</span>, <span class="org-type">double</span> <span class="org-variable-name">fRatio2</span>) {
  m_nUnitSize = nBlockSize;
  m_nBlockSize = nBlockSize;
  m_nBlockBase = Log_2(nBlockSize);
  <span class="org-keyword">if</span> (-1 == m_nBlockBase) {
    TRACE0(<span class="org-string">"Fatal: invalid block size of %d\n"</span>, nBlockSize);
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
  m_nAlloc = nAlloc;
  m_nMaxBuffers = nMax * nAlloc;
  m_nBufferSize = m_nBlockSize * m_nAlloc;
  m_nBuffers = 0;
  m_nMax = nMax;
  m_nMin = nMin;
  <span class="org-keyword">if</span> (0 != fRatio1 &amp;&amp; 0 != fRatio2) {
    m_nWaterMarks[0] = (<span class="org-type">int</span>)((<span class="org-type">double</span>)m_nMaxBuffers * fRatio1);
    m_nWaterMarks[1] = (<span class="org-type">int</span>)((<span class="org-type">double</span>)m_nMaxBuffers * fRatio2);
    m_nWaterMarks[2] = m_nMaxBuffers - 1;
  }
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; m_nMin; i++) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>AllocOnce()) <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#27809;&#26377;&#24517;&#35201;&#22238;&#28378;&#65292;&#27599;&#27425;&#25104;&#21151;&#37117;&#20250;&#35760;&#24405;&#29366;&#24577;&#65292;&#22312;Destroy&#37324;&#38754;&#20250;&#37322;&#25918;&#25481;&#12290;</span>
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3"><span class="section-number-4">2.3.3</span> AllocOnce</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
之前说过AllocOnce是分配一个连续内存块，每个Block大小是m_nBlockSize,而个数是nAlloc.
同时还需要分配nAlloc个Handle.每个Handle管理一个Block.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-function-name">AllocOnce</span>() {
  <span class="org-type">char</span>* <span class="org-variable-name">pBuffer</span> = (<span class="org-type">char</span>*)AlignAlloc(m_nBlockSize, m_nBufferSize);
  <span class="org-type">Handle</span>* <span class="org-variable-name">pHdl</span> = (<span class="org-type">Handle</span>*)ZeroAlloc(<span class="org-type">m_nAlloc</span> * <span class="org-keyword">sizeof</span>(Handle));
  <span class="org-keyword">if</span> (pBuffer &amp;&amp; pHdl) {
    m_BufferMap.insert(<span class="org-constant">BufferMap</span>::value_type(pBuffer, pHdl)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35760;&#24405;&#19979;&#36825;&#20010;&#36830;&#32493;&#22359;&#30340;&#20869;&#23384;&#22320;&#22336;&#21644;Handle&#22320;&#22336;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;Destroy&#26102;&#20505;&#26377;&#29992;.</span>
    m_nBuffers += m_nAlloc;
    pBuffer += m_nBufferSize - m_nBlockSize;
    pHdl += m_nAlloc - 1;

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; m_nAlloc; i++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;&#25105;&#25152;&#26377;&#30340;Block&#21152;&#20837;&#21040;&#38142;&#34920;&#37324;&#38754;&#21435;.</span>
      pHdl-&gt;pBuffer = pBuffer;
      pHdl-&gt;nRef = 0;
      pHdl-&gt;nConsBuf = i + 1;
      pHdl-&gt;pRealHdl = pHdl;
      m_FreeList.push_back(pHdl); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;ConsBuf&#22823;&#30340;Handle&#25918;&#22312;&#38142;&#34920;&#26368;&#21518;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#21518;&#38754;&#20869;&#23384;&#20998;&#37197;&#31574;&#30053;&#23601;&#21487;&#20197;&#21457;&#29616;&#65292;&#23545;&#20110;&#20998;&#37197;&#36830;&#32493;Handle&#30340;&#35805;&#37117;&#26159;&#20174;&#26368;&#21518;&#24320;&#22987;&#30340;&#12290;</span>

      pBuffer -= m_nBlockSize;
      pHdl --;
    }
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }
  <span class="org-keyword">if</span> (pBuffer)
    free(pBuffer);
  <span class="org-keyword">if</span> (pHdl)
    free(pHdl);
  <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4"><span class="section-number-4">2.3.4</span> GetHandle</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
GetHandle是通过传入buffer首地址来确定管理这个buffer的Handle.但是注意不是RealHdl.
如果需要对这个内存做引用计数的话，应该是对RealHdl做引用计数。可以看看下面的AddRef实现。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Handle</span>* <span class="org-function-name">GetHandle</span>(<span class="org-type">char</span>* <span class="org-variable-name">pBuffer</span>) {
  <span class="org-constant">BufferMap</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span> = m_BufferMap.upper_bound(pBuffer);
  <span class="org-keyword">if</span> (it != m_BufferMap.begin()) {
    it --;

    <span class="org-type">char</span>* <span class="org-variable-name">pHead</span> = it-&gt;first;
    ASSERT(pHead &lt;= pBuffer);
    <span class="org-keyword">if</span> (pBuffer &lt; pHead + m_nBufferSize) {
      <span class="org-type">int</span> <span class="org-variable-name">n</span> = (pBuffer - pHead) &gt;&gt; m_nBlockBase;
      <span class="org-type">Handle</span>* <span class="org-variable-name">pHdl</span> = it-&gt;second + n;
      ASSERT(pHdl-&gt;pBuffer == pHead + (((<span class="org-type">uint32</span>)n) &lt;&lt; m_nBlockBase));
      <span class="org-keyword">return</span> pHdl;
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-5" class="outline-4">
<h4 id="sec-2-3-5"><span class="section-number-4">2.3.5</span> AddRef</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
对某块内存进行引用计数。并且强大的是这个内存地址不必是分配的首地址，可以是连续内存内部任意地址。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">AddRef</span>(<span class="org-type">char</span>* <span class="org-variable-name">p</span>, <span class="org-type">bool</span> <span class="org-variable-name">bCheck</span> = <span class="org-constant">false</span>) {
  <span class="org-type">Handle</span>* <span class="org-variable-name">pHdl</span> = GetHandle(p);
  <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == pHdl) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bCheck) {
      <span class="org-keyword">return</span> -1;
    }
    RaiseError(Invalid_Block);
  }

  <span class="org-type">int</span> <span class="org-variable-name">n</span> = ++ pHdl-&gt;pRealHdl-&gt;nRef;
  ASSERT(2 &lt;= n);
  <span class="org-keyword">return</span> n;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-6" class="outline-4">
<h4 id="sec-2-3-6"><span class="section-number-4">2.3.6</span> Destroy</h4>
<div class="outline-text-4" id="text-2-3-6">
<p>
Destroy是将AllocOnce分配的内存和Handle全部回收。因为得到了所有分配内存和Handle的起始地址
保存在map里面所以释放并不麻烦.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">Destroy</span>() {
  m_FreeList.Init();
  m_nBuffers = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#20998;&#37197;&#35745;&#25968;&#28165;&#38646;.</span>

  <span class="org-constant">BufferMap</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span>;
  <span class="org-keyword">for</span> (it = m_BufferMap.begin(); it != m_BufferMap.end(); it++) {
    free(it-&gt;first);
    free(it-&gt;second);
  }
  m_BufferMap.clear();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-7" class="outline-4">
<h4 id="sec-2-3-7"><span class="section-number-4">2.3.7</span> Allocate</h4>
<div class="outline-text-4" id="text-2-3-7">
<p>
分配内存。可以从参数里面看出来语义是说分配多少个Block.nPriority参数是说使用哪个水位线。
如果超过水位线的话，那么会使用相应的策略来处理(打印日志)。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;freelist&#37324;&#38754;&#20998;&#37197;&#19968;&#20010;block&#20986;&#26469;.</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">_ALLOC_TRAN_BUF</span>(<span class="org-variable-name">p</span>, <span class="org-variable-name">how</span>)                     \
  p = m_FreeList.how();                           \
  ASSERT(DLINK_IS_STANDALONE(&amp;p-&gt;link));          \
  ASSERT(0 == p-&gt;nRef);                           \
  ASSERT(p-&gt;pRealHdl == p);                       \
  p-&gt;nRef = 1

  <span class="org-type">char</span>* <span class="org-function-name">Allocate</span>(<span class="org-type">uint32</span> <span class="org-variable-name">nPriority</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span> = 1) {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    ASSERT(0 != count);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#23581;&#35797;&#20998;&#37197;&#20004;&#27425;&#12290;&#31532;&#19968;&#27425;&#19981;&#36827;&#34892;AllocOnce.&#22914;&#26524;&#31532;&#19968;&#27425;&#22833;&#36133;&#30340;&#35805;&#37027;&#20040;&#31532;&#20108;&#27425;&#20250;&#23581;&#35797;&#12290;</span>
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 2; i++) {
      n = (<span class="org-type">int</span>)m_FreeList.size();
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24403;&#21069;&#20998;&#37197;&#20869;&#23384;&#22823;&#20110;water mark&#30340;&#35805;&#20250;&#25171;&#21360;&#26085;&#24535;&#65292;&#20294;&#26159;&#20026;&#20102;&#36807;&#24555;&#30340;&#25171;&#21360;&#36825;&#37324;&#25511;&#21046;&#20102;&#25171;&#21360;&#38388;&#38548;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#36825;&#37324;&#21487;&#20197;&#30475;&#21040;&#36825;&#20010;&#26159;&#38750;&#22810;&#32447;&#31243;&#30340;&#12290;&#20174;&#21518;&#38754;BufHandle&#20351;&#29992;&#26469;&#30475;&#30830;&#23454;&#26159;&#36825;&#26679;&#30340;&#12290;</span>
      <span class="org-keyword">if</span> (m_nBuffers - n &gt; m_nWaterMarks[nPriority]) {
        <span class="org-keyword">if</span> (nPriority != 0) {
          <span class="org-keyword">static</span> <span class="org-type">time_t</span> <span class="org-variable-name">last</span> = 0;
          <span class="org-type">time_t</span> <span class="org-variable-name">now</span> = time(<span class="org-constant">NULL</span>);
          <span class="org-keyword">if</span> (now - last &gt;= 30) {   <span class="org-comment-delimiter">// </span><span class="org-comment">avoid too frequent print</span>
            <span class="org-type">int</span> <span class="org-variable-name">n1</span> = m_nMaxBuffers - m_nBuffers + n;
            <span class="org-type">int</span> <span class="org-variable-name">n2</span> = m_nMaxBuffers - m_nWaterMarks[nPriority];
            TRACE0(<span class="org-string">"Warning: available tran buf (#%d) touches watermark(#%d, %.f%%)\n"</span>,
                   n1, n2, (<span class="org-type">double</span>)(<span class="org-type">n1</span> * 100) / m_nMaxBuffers);
            last = now;
          }
        }
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
      }
      <span class="org-keyword">if</span> (n &gt;= count) {  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;free list&#37324;&#38754;&#20869;&#23481;&gt;=count&#30340;&#35805;&#65292;&#20294;&#26159;&#26377;&#21487;&#33021;&#27809;&#26377;&#36830;&#32493;&#20869;&#23384;&#29992;&#26469;&#20998;&#37197;&#12290;</span>
        <span class="org-type">Handle</span>* <span class="org-variable-name">pHdl</span>, *<span class="org-variable-name">pTmp</span>;
        <span class="org-keyword">if</span> (1 == count) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20998;&#37197;1&#20010;&#30340;&#35805;&#65292;&#37027;&#20040;&#30452;&#25509;&#20174;&#21069;&#38754;&#20998;&#37197;</span>
          _ALLOC_TRAN_BUF(pHdl, pop_front);
          <span class="org-keyword">return</span> pHdl-&gt;pBuffer;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#20250;&#20174;&#21518;&#38754;&#20998;&#37197;&#65292;&#22240;&#20026;&#21518;&#38754;Consecutive Buffer&#30340;&#27010;&#29575;&#20250;&#26356;&#39640;&#12290;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Big block are formed by multiple consecutive blocks.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">We try from the tail of free list, which brings higher probability.</span>
        _ALLOC_TRAN_BUF(pHdl, pop_back);
        <span class="org-type">int</span> <span class="org-variable-name">i</span> = 1;
        <span class="org-keyword">if</span> (pHdl-&gt;nConsBuf &gt;= count) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30475;&#30475;&#26368;&#21518;&#30340;Handle&#30340;consectutive number&#26159;&#21542;&#36275;&#22815;.</span>
          <span class="org-keyword">for</span> ( ; i &lt; count; i++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#30475;&#30475;&#26159;&#21542;&#34987;&#21344;&#29992;(&#36890;&#36807;&#24341;&#29992;&#35745;&#25968;&#21028;&#26029;).&#36825;&#37324;&#27809;&#26377;&#32454;&#30475;&#38142;&#34920;&#30340;&#32452;&#32455;&#12290;</span>
            pTmp = pHdl + i;
            <span class="org-variable-name">UNLIKELY_IF</span> (0 != pTmp-&gt;nRef) {
              <span class="org-keyword">break</span>;
            }
            m_FreeList.remove(pTmp);
            DLINK_INSERT_PREV(&amp;pHdl-&gt;link, &amp;pTmp-&gt;link);
            pTmp-&gt;pRealHdl = pHdl;
            pTmp-&gt;nRef = 1;
          }
        }
        <span class="org-keyword">if</span> (i == count) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20998;&#37197;OK&#30340;&#35805;,&#37027;&#20040;&#36820;&#22238;</span>
          <span class="org-keyword">return</span> pHdl-&gt;pBuffer;
        } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#36827;&#34892;&#22238;&#28378;.</span>
          <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; j++) {
            pTmp = pHdl + j;
            DLINK_INITIALIZE(&amp;pTmp-&gt;link);
            pTmp-&gt;pRealHdl = pTmp;
            pTmp-&gt;nRef = 0;
            m_FreeList.push_front(pTmp);
          }
        }
      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20998;&#37197;&#20869;&#23384;&#36229;&#38480;&#25110;&#32773;&#26159;AllocOnce&#20998;&#37197;&#22833;&#36133;&#30340;&#35805;&#65292;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;&#12290;</span>
      <span class="org-keyword">if</span> (m_nBuffers &gt;= m_nMaxBuffers || <span class="org-negation-char">!</span>AllocOnce()) {
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
      }
    }
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-8" class="outline-4">
<h4 id="sec-2-3-8"><span class="section-number-4">2.3.8</span> Free</h4>
<div class="outline-text-4" id="text-2-3-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#ifdef</span>  _DEBUG
<span class="org-preprocessor">#define</span> <span class="org-function-name">_FREE_TRAN_BUF</span>(<span class="org-variable-name">p</span>, <span class="org-variable-name">how</span>)                              \
  memset(p-&gt;pBuffer, 0xCC, m_nBlockSize);             \
  m_FreeList.how(p)
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">_FREE_TRAN_BUF</span>(<span class="org-variable-name">p</span>, <span class="org-variable-name">how</span>)                              \
  m_FreeList.how(p)
<span class="org-preprocessor">#endif</span>

  <span class="org-type">int</span> <span class="org-function-name">Free</span>(<span class="org-type">char</span>* <span class="org-variable-name">p</span>, <span class="org-type">bool</span> <span class="org-variable-name">bCheck</span> = <span class="org-constant">false</span>) {
    <span class="org-type">Handle</span>* <span class="org-variable-name">pHdl</span> = GetHandle(p);
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == pHdl) {
      <span class="org-keyword">if</span> (bCheck) {
        RaiseError(Invalid_Block);
      }
      <span class="org-keyword">return</span> -1;
    }

    pHdl = pHdl-&gt;pRealHdl;
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = -- pHdl-&gt;nRef; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20462;&#25913;&#24341;&#29992;&#35745;&#25968;&#12290;</span>
    <span class="org-keyword">if</span> (0 == n) {
      <span class="org-type">Handle</span>* <span class="org-variable-name">pTmp</span> = dlink_get_prev(pHdl);
      <span class="org-keyword">if</span> (pTmp == pHdl) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#19968;&#20010;Block&#30340;&#35805;.</span>
        ASSERT_EQUAL(pHdl-&gt;pRealHdl, pHdl);
        ASSERT_EQUAL(0, pHdl-&gt;nRef);
        _FREE_TRAN_BUF(pHdl, push_front);
        <span class="org-keyword">return</span> 0;
      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">here comes big block</span>
      <span class="org-type">Handle</span>* <span class="org-variable-name">p</span> = pHdl; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#30693;&#36947;&#36825;&#20010;Handle&#32452;&#32455;&#31216;&#20026;&#29615;&#24418;&#21452;&#21521;&#38142;&#34920;&#12290;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#26679;&#25353;&#29031;AllocOnce&#30340;&#39034;&#24207;&#65292;&#23558;consecutive number&#22823;&#30340;handle&#25918;&#22312;&#26411;&#23614;.</span>
      <span class="org-keyword">do</span> {
        pHdl = pTmp;
        pTmp = dlink_get_prev(pTmp);
        ASSERT_EQUAL(1, pHdl-&gt;nRef);
        ASSERT_EQUAL(p, pHdl-&gt;pRealHdl);
        pHdl-&gt;pRealHdl = pHdl;
        pHdl-&gt;nRef = 0;
        DLINK_INITIALIZE(&amp;pHdl-&gt;link);
        _FREE_TRAN_BUF(pHdl, push_back);
      } <span class="org-keyword">while</span> (p != pTmp);
      ASSERT_EQUAL(p, p-&gt;pRealHdl);
      ASSERT_EQUAL(0, p-&gt;nRef);
      DLINK_INITIALIZE(&amp;p-&gt;link);
      _FREE_TRAN_BUF(p, push_back);
      <span class="org-keyword">return</span> 0;
    }
    <span class="org-keyword">return</span> n;
  }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> BufHandle</h3>
<div class="outline-text-3" id="text-2-4">
<p>
如果说TranBuf是底层内存分配器的话，那BufHandle就是应用层的内存分配器。BufHandle底层是通过
两个TranBuf来进行分配的。BufHandle本质上是chained的形式，主要是为了节省mem copy以及适应
network IO app的。通过全局的BufHandlePool对象来分配内存。
</p>
</div>

<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> OverView</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
首先我们看看BufHandle结构以及提供的API.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">BufHandle</span> {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">_next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#24335;&#25351;&#38024;.</span>
  <span class="org-type">char</span>* <span class="org-variable-name">pBuf</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31649;&#29702;&#30340;&#20869;&#23384;.</span>
  <span class="org-type">int</span> <span class="org-variable-name">nBufLen</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">available buffer length &#21487;&#29992;&#38271;&#24230;</span>
  <span class="org-type">int</span> <span class="org-variable-name">nDataLen</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">occupied data length &#21344;&#29992;&#38271;&#24230;</span>
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;[pHdl,pNext)&#36825;&#20010;&#21306;&#38388;&#19978;&#38754;&#22238;&#25910;nLen&#38271;&#24230;&#20986;&#26469;&#20998;&#37197;&#20986;&#21435;.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">Reclaim</span>(<span class="org-type">int</span> <span class="org-variable-name">nLen</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;TranBuf&#30340;&#21442;&#25968;.&#36825;&#20010;&#24212;&#35813;&#22312;Kylin&#35843;&#29992;&#20043;&#21069;&#23601;&#35774;&#32622;&#22909;&#65292;&#22914;&#26524;&#25171;&#31639;&#20351;&#29992;BufHandle&#30340;&#35805;&#12290;</span>
<span class="org-type">void</span> <span class="org-function-name">SetTranBuf</span>(<span class="org-type">int</span> <span class="org-variable-name">nSmallNum</span>, <span class="org-type">int</span> <span class="org-variable-name">nBigNum</span>,
                <span class="org-type">int</span> <span class="org-variable-name">nSmallSize</span> = 4096,
                <span class="org-type">float</span> <span class="org-variable-name">fLowMark</span> = 0.6f,
                <span class="org-type">float</span> <span class="org-variable-name">fHighMark</span> = 0.9f);

<span class="org-comment-delimiter">// </span><span class="org-comment">NOTICE:&#36825;&#37324;&#22914;&#26524;&#19981;&#20801;&#35768;&#22833;&#36133;&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#20250;&#30452;&#25509;&#25243;&#20986;&#24322;&#24120;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">inPool&#34920;&#31034;&#36825;&#20010;buf&#26159;&#21542;&#22312;pool&#37324;&#38754;&#22914;&#26524;&#26159;&#30340;&#35805;&#37027;&#20040;&#21487;&#20197;&#30452;&#25509;&#20351;&#29992;&#24341;&#29992;&#35745;&#25968;&#20248;&#21270;&#20943;&#23569;copy</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">pBuf&#34920;&#31034;src&#20869;&#23384;&#22320;&#22336;,nLen&#34920;&#31034;src&#20869;&#23384;&#38271;&#24230;.pNext&#34920;&#31034;allocate handle&#20043;&#21518;next&#23383;&#27573;&#20540;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;inPool&#30340;&#35805;&#65292;&#37027;&#20040;&#20174;TranBufPool&#37324;&#38754;&#20998;&#37197;.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">AllocateHdl</span>(<span class="org-type">bool</span> <span class="org-variable-name">bInPool</span> = <span class="org-constant">false</span>, <span class="org-type">char</span>* <span class="org-variable-name">pBuf</span> = <span class="org-constant">NULL</span>,
                       <span class="org-type">int</span> <span class="org-variable-name">nLen</span> = 0, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span> = <span class="org-constant">NULL</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;TranBufPool&#37324;&#38754;&#20998;&#37197;&#20801;&#35768;&#22833;&#36133;.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">AllocateHdlCanFail</span>(<span class="org-type">int</span> <span class="org-variable-name">nSize</span> = 0);
<span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;big pool&#37324;&#38754;&#20998;&#37197;1&#20010;block.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">AllocateBigHdl</span>();
<span class="org-type">BufHandle</span>* <span class="org-function-name">AllocateBigHdlCanFail</span>();

<span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;&#36825;&#20010;Handle.</span>
<span class="org-type">void</span> <span class="org-function-name">FreeHdl</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#24335;&#37322;&#25918;[pHdl,pNext)&#30340;&#38142;&#24335;&#37324;&#38754;&#30340;&#31354;&#38388;.</span>
<span class="org-type">void</span> <span class="org-function-name">ChainFreeHdl</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#21517;&#23383;&#21462;&#24471;&#19981;&#22826;&#22909;&#21548;&#65292;&#26412;&#36136;&#26469;&#35828;&#23601;&#26159;&#36827;&#34892;Clone</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">pnLen&#25968;&#25454;&#38271;&#24230;&#26159;&#22810;&#23569;.bCopyNonTranBuf&#34920;&#31034;&#22914;&#26524;&#19981;&#33021;&#22815;&#20570;&#24341;&#29992;&#35745;&#25968;&#30340;&#35805;&#65292;&#26159;&#21542;&#38656;&#35201;copy.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">CloneHdlAndTerminate</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>,
                                <span class="org-type">int</span>* <span class="org-variable-name">pnLen</span> = <span class="org-constant">NULL</span>, <span class="org-type">bool</span> <span class="org-variable-name">bCopyNonTranBuf</span> = <span class="org-constant">true</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> SetTranBuf</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
首先我们先看看CBufHandlePool的结构然后在看这个API
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#32487;&#25215;&#20110;TObjectPool&#23545;&#35937;&#27744;&#21487;&#20197;&#30452;&#25509;&#39640;&#25928;&#20998;&#37197;&#20986;BufHandle&#23545;&#35937;&#20986;&#26469;.</span>
<span class="org-keyword">class</span> <span class="org-type">CBufHandlePool</span> : <span class="org-keyword">public</span> <span class="org-type">TObjectPool</span>&lt;BufHandle&gt; {
  <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">m_lock</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22810;&#32447;&#31243;&#23433;&#20840;.</span>
  <span class="org-type">CTranBufPool</span> <span class="org-variable-name">m_TranBufPool</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">tran buf pool</span>
  <span class="org-type">CTranBufPool</span> <span class="org-variable-name">m_BigBufPool</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">big buf pool</span>
};

  <span class="org-function-name">CBufHandlePool</span>() : TObjectPool&lt;BufHandle&gt;(<span class="org-string">"BufHandle"</span>, BUFPOOL_C2),
    <span class="org-variable-name">m_TranBufPool</span>(<span class="org-string">"TranBuffer"</span>, BUFPOOL_C1),
    <span class="org-variable-name">m_BigBufPool</span>(<span class="org-string">"BigBuffer"</span>, BUFPOOL_C1) {
    m_lock = 0;
    Create(1024, 1);

    <span class="org-type">int</span> <span class="org-variable-name">nAlloc</span> = s_nTranBuf;
    <span class="org-type">int</span> <span class="org-variable-name">nMax</span> = 1;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#27425;&#19981;&#35201;&#20998;&#37197;&#36229;&#36807;512M.&#20294;&#26159;&#20026;&#20102;&#20445;&#25345;&#20869;&#23384;&#24635;&#37327;&#20801;&#35768;nMax&#22686;&#22823;.</span>
    <span class="org-keyword">while</span> ((s_nBufSize / 1024) * nAlloc &gt; 524288) { <span class="org-comment-delimiter">/* </span><span class="org-comment">Max alloc: 512M */</span>
      nAlloc &gt;&gt;= 1;
      nMax &lt;&lt;= 1;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">tranbuf&#35774;&#32622;&#21442;&#25968;.</span>
    m_TranBufPool.Create(s_nBufSize, nAlloc, 1, nMax, s_fLowMark, s_fHighMark);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#30475;&#21040;big buf&#30340;block size&#38750;&#24120;&#22823;.&#24182;&#19988;watermark&#38750;&#24120;&#39640;.&#20998;&#37197;&#27425;&#25968;&#22312;[0,10]&#20043;&#38388;.</span>
    m_BigBufPool.Create(SZ_BIG_BUF, s_nBigTranBuf, 0, 10, 0.9, 0.9);
  }

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#20363;&#27169;&#24335;.</span>
<span class="org-keyword">static</span> <span class="org-type">CBufHandlePool</span>* <span class="org-variable-name">s_pBufHandlePool</span> = <span class="org-constant">NULL</span>;
<span class="org-keyword">static</span> <span class="org-type">CBufHandlePool</span>* <span class="org-function-name">GetBufHdlPool</span>() {
  <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != s_pBufHandlePool) {
    <span class="org-keyword">return</span> s_pBufHandlePool;
  } <span class="org-keyword">else</span> {
    LOCK_THIS_BLOCK;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == s_pBufHandlePool) {
      s_pBufHandlePool = <span class="org-keyword">new</span> <span class="org-type">CBufHandlePool</span>;
    }
    <span class="org-keyword">return</span> s_pBufHandlePool;
  }
}
</pre>
</div>

<p>
然后来看看这些参数是来如何设置的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-variable-name">s_nTranBuf</span> = 1024;
<span class="org-type">int</span> <span class="org-variable-name">s_nBufSize</span> = 4096;
<span class="org-type">int</span> <span class="org-variable-name">s_nBigTranBuf</span> = 64;
<span class="org-type">float</span> <span class="org-variable-name">s_fLowMark</span> = 0.6f;
<span class="org-type">float</span> <span class="org-variable-name">s_fHighMark</span> = 0.9f;

<span class="org-type">void</span> <span class="org-function-name">SetTranBuf</span>(<span class="org-type">int</span> <span class="org-variable-name">nSmallNum</span>, <span class="org-type">int</span> <span class="org-variable-name">nBigNum</span>, <span class="org-type">int</span> <span class="org-variable-name">nSmallSize</span>, <span class="org-type">float</span> <span class="org-variable-name">fLowMark</span>, <span class="org-type">float</span> <span class="org-variable-name">fHighMark</span>) {
  LOCK_THIS_BLOCK;

  s_nTranBuf = nSmallNum; <span class="org-comment-delimiter">// </span><span class="org-comment">tran buf&#24212;&#35813;&#27599;&#27425;alloc&#22810;&#23569;&#20010;block.</span>
  s_nBigTranBuf = nBigNum; <span class="org-comment-delimiter">// </span><span class="org-comment">big tran buf&#27599;&#27425;&#24212;&#35813;allocate&#22810;&#23569;&#20010;block.</span>
  s_nBufSize = nSmallSize; <span class="org-comment-delimiter">// </span><span class="org-comment">tran buf&#30340;blocksize.</span>
  s_fLowMark = fLowMark;
  s_fHighMark = fHighMark;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> DoAllocate</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
这个是底层确保一定分配成功API(如果失败抛异常).来看看实现.使用hang住当前操作等待其他线程归还内存.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#20160;&#20040;pool&#37324;&#38754;&#36827;&#34892;&#20998;&#37197;&#65292;&#23581;&#35797;&#22810;&#23569;&#27425;&#20998;&#37197;.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">DoAllocate</span>(<span class="org-type">CTranBufPool</span>* <span class="org-variable-name">pPool</span>, <span class="org-type">int</span> <span class="org-variable-name">nRetry</span>) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>;

  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nRetry; i++) {
    LOCK;
    pHdl = <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Allocate(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#20174;&#23545;&#35937;&#27744;&#37324;&#38754;&#20998;&#37197;BufHandle&#23545;&#35937;.</span>
    pHdl-&gt;pBuf = pPool-&gt;Allocate(i &gt; 0 ? 2 : 1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#20174;tran buf pool&#37324;&#38754;&#20998;&#37197;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#31532;&#19968;&#27425;&#25353;&#29031;water mark1&#26469;&#20998;&#37197;,&#20043;&#21518;&#25353;&#29031;water mark2&#26469;&#20998;&#37197;.</span>
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == pHdl-&gt;pBuf) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20998;&#37197;&#22833;&#36133;&#30340;&#35805;&#65292;&#37027;&#20040;&#36820;&#22238;&#23545;&#35937;&#27744;.</span>
      <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Free(pHdl);
      pHdl = <span class="org-constant">NULL</span>;
    }
    UNLOCK;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != pHdl) <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25104;&#21151;&#30452;&#25509;&#36820;&#22238;.</span>
      <span class="org-keyword">return</span> pHdl;
    <span class="org-keyword">if</span> (i &gt; 1) {
      TRACE0(<span class="org-string">"No enough memory, sleep %d\n"</span>, i + 1);
    }
    sleep(1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#20250;hang&#20303;&#31561;&#24453;&#37322;&#25918;.</span>
  }
  RaiseError(TODO_NO_ENOUGH_MEMORY); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#20998;&#37197;&#25104;&#21151;&#37027;&#20040;&#23601;&#20250;&#25243;&#20986;&#24322;&#24120;.</span>
  <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> DoAllocateCanFail</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
底层不一定保证分配成功，可能返回NULL表示失败.只是尝试一次分配.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">BufHandle</span>* <span class="org-function-name">DoAllocateCanFail</span>(<span class="org-type">CTranBufPool</span>* <span class="org-variable-name">pPool</span>, <span class="org-type">int</span> <span class="org-variable-name">nSize</span>) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>;
  <span class="org-type">int</span> <span class="org-variable-name">nBlockSize</span> = pPool-&gt;GetBlockSize();
  ASSERT(0 != nSize);

  LOCK;
  pHdl = <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Allocate();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20197;water mark0&#20026;&#26631;&#35760;.</span>
  <span class="org-keyword">if</span> (nSize == nBlockSize) {
    pHdl-&gt;pBuf = pPool-&gt;Allocate(0);
  } <span class="org-keyword">else</span> {
    pHdl-&gt;pBuf = pPool-&gt;Allocate(0, (nSize + nBlockSize - 1) / nBlockSize);
  }
  <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == pHdl-&gt;pBuf) {
    <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Free(pHdl);
    pHdl = <span class="org-constant">NULL</span>;
  }
  UNLOCK;
  <span class="org-keyword">return</span> pHdl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-5" class="outline-4">
<h4 id="sec-2-4-5"><span class="section-number-4">2.4.5</span> _DoAddRef</h4>
<div class="outline-text-4" id="text-2-4-5">
<p>
对于BufHandle的引用技术和TranPool引用计数有点不同，并且平时思考的也不同。BufHandle的引用计数
只是针对头部的BufHandle增加计数而共用其他部分的BufHandle.
</p>

<p>
(NOTICE):(不过在外部调用可以看到,CloneAndTerminate实际上也还是遍历了所有的Handle做引用计数).
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">BufHandle</span>* <span class="org-function-name">_DoAddRef</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>, <span class="org-type">BufHandle</span>** * <span class="org-variable-name">pppLast</span>) {
  <span class="org-keyword">if</span> (-1 != m_TranBufPool.AddRef(pHdl-&gt;pBuf) || -1 != m_BigBufPool.AddRef(pHdl-&gt;pBuf)) {
    <span class="org-type">BufHandle</span>* <span class="org-variable-name">pTmp</span> = <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Allocate();
    pTmp-&gt;_next = pNext;
    pTmp-&gt;pBuf = pHdl-&gt;pBuf;
    pTmp-&gt;nBufLen = pHdl-&gt;nDataLen;
    pTmp-&gt;nDataLen = pHdl-&gt;nDataLen;
    *pppLast = &amp;pTmp-&gt;_next;
    <span class="org-keyword">return</span> pTmp;
  }
  <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-6" class="outline-4">
<h4 id="sec-2-4-6"><span class="section-number-4">2.4.6</span> _DoFree</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
只是释放单个BufHandle对象.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">_DoFree</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>) {
  <span class="org-keyword">if</span> (-1 == m_TranBufPool.Free(pHdl-&gt;pBuf))
    m_BigBufPool.Free(pHdl-&gt;pBuf);
  <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Free(pHdl);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-7" class="outline-4">
<h4 id="sec-2-4-7"><span class="section-number-4">2.4.7</span> AllocateBig</h4>
<div class="outline-text-4" id="text-2-4-7">
<p>
从BigTranBufPool里面分配大块内存.注意对于大块内存而言的话只允许分配一个Block.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">BufHandle</span>* <span class="org-function-name">AllocateBig</span>(<span class="org-type">bool</span> <span class="org-variable-name">bCanFail</span>) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>;

  pHdl = bCanFail
         ? DoAllocateCanFail(&amp;m_BigBufPool, SZ_BIG_BUF)
         : DoAllocate(&amp;m_BigBufPool, 60); <span class="org-comment-delimiter">// </span><span class="org-comment">60s&#30340;&#24310;&#36831;.</span>
  <span class="org-keyword">if</span> (pHdl) {
    pHdl-&gt;_next = <span class="org-constant">NULL</span>;
    pHdl-&gt;nBufLen = SZ_BIG_BUF;
    pHdl-&gt;nDataLen = 0;
  }
  <span class="org-keyword">return</span> pHdl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-8" class="outline-4">
<h4 id="sec-2-4-8"><span class="section-number-4">2.4.8</span> AllocateCanFail</h4>
<div class="outline-text-4" id="text-2-4-8">
<p>
从TranBufPool里面分配连续内存出来.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">BufHandle</span>* <span class="org-function-name">AllocateCanFail</span>(<span class="org-type">int</span> <span class="org-variable-name">nSize</span>) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span> = DoAllocateCanFail(&amp;m_TranBufPool, nSize);
  <span class="org-keyword">if</span> (pHdl) {
    pHdl-&gt;_next = <span class="org-constant">NULL</span>;
    pHdl-&gt;nBufLen = nSize;
    pHdl-&gt;nDataLen = 0;
  }
  <span class="org-keyword">return</span> pHdl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-9" class="outline-4">
<h4 id="sec-2-4-9"><span class="section-number-4">2.4.9</span> AllocForBuf</h4>
<div class="outline-text-4" id="text-2-4-9">
<p>
为某个buf分配内存.把buf内容copy进来.并且设置pNext.pppLast表示最后一个节点的next字段指针(三指针比较难理解&#x2026;)
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">BufHandle</span>* <span class="org-function-name">AllocForBuf</span>(<span class="org-type">char</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">nLen</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>, <span class="org-type">BufHandle</span>** * <span class="org-variable-name">pppLast</span>) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pFirst</span>, *<span class="org-variable-name">pHdl</span>, **<span class="org-variable-name">ppLast</span>;

  pFirst = <span class="org-constant">NULL</span>;
  ppLast = &amp;pFirst;
  <span class="org-keyword">while</span> (nLen &gt; 0) {
    pHdl = DoAllocate(&amp;m_TranBufPool, 120); <span class="org-comment-delimiter">// </span><span class="org-comment">120s&#24310;&#36831;.</span>

    pHdl-&gt;nBufLen = s_nBufSize;
    pHdl-&gt;nDataLen = nLen &gt; s_nBufSize ? s_nBufSize : nLen;
    memcpy(pHdl-&gt;pBuf, pBuf, pHdl-&gt;nDataLen);
    pBuf += pHdl-&gt;nDataLen;
    nLen -= pHdl-&gt;nDataLen;

    pHdl-&gt;_next = pNext; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;next&#23383;&#27573;&#20869;&#23481;</span>
    *ppLast = pHdl;
    ppLast = &amp;pHdl-&gt;_next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#24471;&#21040;&#26368;&#21518;&#19968;&#20010;item&#30340;next&#23383;&#27573;&#25351;&#38024;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#22240;&#20026;&#35774;&#32622;&#20102;pNext&#25152;&#20197;&#24863;&#35273;&#19981;&#26159;&#29305;&#21035;&#26377;&#29992;.</span>
  }
  <span class="org-keyword">if</span> (pppLast) {
    *pppLast = ppLast;
  }
  <span class="org-keyword">return</span> pFirst;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-10" class="outline-4">
<h4 id="sec-2-4-10"><span class="section-number-4">2.4.10</span> Allocate</h4>
<div class="outline-text-4" id="text-2-4-10">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;inpool&#30340;&#35805;&#65292;&#37027;&#20040;pubuf&#24517;&#39035;&#26159;pool&#20998;&#37197;&#20986;&#26469;&#30340;&#65292;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#25105;&#20204;&#21482;&#26159;&#38024;&#23545;&#36825;&#20010;buffer&#20570;&#19968;&#20010;&#24341;&#29992;&#35745;&#25968;</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;inpool&#30340;&#35805;&#65292;nLen==0&#25110;&#32773;&#26159;pBuf==NULL,&#20998;&#37197;&#20986;&#19968;&#20010;&#31354;&#21333;&#20803;&#20986;&#26469;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#38656;&#35201;&#20570;&#19968;&#20010;&#20869;&#23384;copy.&#20351;&#29992;&#19978;&#38754;AllocForBuf&#30340;API.</span>
<span class="org-type">BufHandle</span>* <span class="org-function-name">Allocate</span>(<span class="org-type">bool</span> <span class="org-variable-name">bInPool</span> = <span class="org-constant">false</span>, <span class="org-type">char</span>* <span class="org-variable-name">pBuf</span> = <span class="org-constant">NULL</span>,
                    <span class="org-type">int</span> <span class="org-variable-name">nLen</span> = 0, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span> = <span class="org-constant">NULL</span>
                   ) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>;

  <span class="org-variable-name">UNLIKELY_IF</span> (<span class="org-constant">false</span> == bInPool) {
    LOCK;
    pHdl = <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Allocate();
    <span class="org-keyword">if</span> (-1 == m_TranBufPool.AddRef(pBuf))
      m_BigBufPool.AddRef(pBuf);
    UNLOCK;

    pHdl-&gt;_next = pNext;
    pHdl-&gt;pBuf = pBuf;
    pHdl-&gt;nBufLen = nLen;
    pHdl-&gt;nDataLen = nLen;
    <span class="org-keyword">return</span> pHdl;
  }
  <span class="org-keyword">if</span> (pBuf == <span class="org-constant">NULL</span> || nLen == 0) {
    pHdl = DoAllocate(&amp;m_TranBufPool, 120);

    pHdl-&gt;_next = pNext;
    pHdl-&gt;nBufLen = s_nBufSize;
    pHdl-&gt;nDataLen = nLen;
    <span class="org-keyword">return</span> pHdl;
  }

  <span class="org-keyword">return</span> AllocForBuf(pBuf, nLen, pNext, <span class="org-constant">NULL</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-11" class="outline-4">
<h4 id="sec-2-4-11"><span class="section-number-4">2.4.11</span> ChainFree</h4>
<div class="outline-text-4" id="text-2-4-11">
<p>
释放[pHdl,pNext)链上的所有item.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">ChainFree</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pTmp</span>;
  LOCK;
  <span class="org-keyword">for</span> ( ; pHdl != pNext; pHdl = pTmp) {
    ASSERT(<span class="org-constant">NULL</span> != pHdl);
    pTmp = pHdl-&gt;_next;
    _DoFree(pHdl);
  }
  UNLOCK;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-12" class="outline-4">
<h4 id="sec-2-4-12"><span class="section-number-4">2.4.12</span> CloneAndTerminate</h4>
<div class="outline-text-4" id="text-2-4-12">
<p>
这个API的语义在之前已经解释过了，来看看代码.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">BufHandle</span>* <span class="org-function-name">CloneAndTerminate</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">BufHandle</span>* <span class="org-variable-name">pNext</span>,
                             <span class="org-type">int</span>* <span class="org-variable-name">pnLen</span>, <span class="org-type">bool</span> <span class="org-variable-name">bCopyNonTranBuf</span>
                            ) {
  <span class="org-type">BufHandle</span>* <span class="org-variable-name">pFirst</span>, *<span class="org-variable-name">pTmp</span>, **<span class="org-variable-name">ppLast</span>, **<span class="org-variable-name">ppLastTmp</span>;
  <span class="org-type">int</span> <span class="org-variable-name">nLen</span> = 0;

  pFirst = <span class="org-constant">NULL</span>;
  ppLast = &amp;pFirst;
  LOCK;
  <span class="org-keyword">for</span> ( ; pHdl != pNext; pHdl = pHdl-&gt;_next) {
    pTmp = _DoAddRef(pHdl, <span class="org-constant">NULL</span>, &amp;ppLastTmp); <span class="org-comment-delimiter">// </span><span class="org-comment">&#30475;&#30475;&#26159;&#21542;&#21487;&#20197;&#22312;&#30452;&#25509;&#20570;&#24341;&#29992;&#35745;&#25968;.</span>
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == pTmp) {
      <span class="org-keyword">if</span> (bCopyNonTranBuf) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#38656;&#35201;copy&#20986;&#26469;&#30340;&#35805;.</span>
        UNLOCK;
        pTmp = AllocForBuf(pHdl-&gt;pBuf, pHdl-&gt;nDataLen, <span class="org-constant">NULL</span>, &amp;ppLastTmp);
        LOCK;
      } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26174;&#31034;&#35828;&#19981;copy&#21482;&#26159;&#24341;&#29992;&#20869;&#23384;&#30340;&#35805;,&#37027;&#20040;&#21482;&#26159;&#24320;&#36767;Handle&#23545;&#35937;.</span>
        pTmp = <span class="org-constant">TObjectPool</span>&lt;<span class="org-type">BufHandle</span>&gt;::Allocate();
        pTmp-&gt;pBuf = pHdl-&gt;pBuf;
        pTmp-&gt;nDataLen = pTmp-&gt;nBufLen = pHdl-&gt;nDataLen;
        pTmp-&gt;_next = <span class="org-constant">NULL</span>;
        ppLastTmp = &amp;pTmp-&gt;_next;
      }
    }
    nLen += pHdl-&gt;nDataLen;
    *ppLast = pTmp;
    ppLast = ppLastTmp;
  }
  UNLOCK;

  <span class="org-keyword">if</span> (pnLen) {
    *pnLen = nLen;
  }
  <span class="org-keyword">if</span> (nLen) {
    <span class="org-keyword">return</span> pFirst;
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#22833;&#36133;&#30340;&#35805;&#37027;&#20040;&#37322;&#25918;&#24050;&#32463;&#20998;&#37197;&#20986;&#26469;&#30340;.</span>
  ChainFreeHdl(pFirst, <span class="org-constant">NULL</span>);
  <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Kylin</h3>
<div class="outline-text-3" id="text-2-5">
<p>
这个模块主要负责框架的启动和停止，做了一些琐碎的事情方便用户，主要是下面这两个函数
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#21551;&#21160;&#26694;&#26550;&#65292;&#20351;&#29992;&#22810;&#23569;&#20010;CPU,&#32593;&#32476;&#21644;&#30913;&#30424;&#32447;&#31243;&#65292;&#33267;&#23569;1&#20010;CPU&#21644;1&#20010;&#32593;&#32476;&#32447;&#31243;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">f&#34920;&#31034;&#32447;&#31243;&#21021;&#22987;&#21270;&#20989;&#25968;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">nTimerPrecision&#20250;&#24433;&#21709;&#21040;&#23450;&#26102;&#22120;&#23454;&#29616;.&#22914;&#26524;&#36229;&#26102;&#22312;&#26102;&#38388;&#31934;&#24230;&#19968;&#19979;&#30340;&#35805;&#37117;&#20250;&#36890;&#36807;ExecMan&#30452;&#25509;&#35302;&#21457;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#37117;&#20250;&#24517;&#39035;&#36890;&#36807;RunTimer&#26469;&#36827;&#34892;&#26816;&#26597;</span>
<span class="org-type">APF_ERROR</span> <span class="org-function-name">InitKylin</span>(<span class="org-type">int</span> <span class="org-variable-name">nExecWorkers</span>, <span class="org-type">int</span> <span class="org-variable-name">nNetWorkers</span>, <span class="org-type">int</span> <span class="org-variable-name">nDiskWorkers</span>,
                    <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">f</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nTimerPrecision</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">bWait&#34920;&#31034;&#26159;&#21542;&#31561;&#24453;ExecMan&#30340;&#32447;&#31243;&#27744;&#27491;&#24120;&#20572;&#27490;&#65292;&#36825;&#20010;&#20250;&#22312;ExecMan&#37096;&#20998;&#25552;&#21040;</span>
<span class="org-type">APF_ERROR</span> <span class="org-function-name">StopKylin</span>(<span class="org-type">bool</span> <span class="org-variable-name">bWait</span>);
</pre>
</div>
<p>
对于InitKylin里面事情就是启动几个Manager，还做了一件tricky事情就是将SIGPIPE信号忽略了。而StopKylin就是停止这些Manager.我们需要仔细关注的就是这些Manager的启停。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> ExecMan</h3>
<div class="outline-text-3" id="text-2-6">
</div><div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1"><span class="section-number-4">2.6.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
我们首先看看ExecMan的接口
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#define</span> <span class="org-variable-name">g_pExecMan</span> <span class="org-constant">CExecMan</span>::Instance() <span class="org-comment-delimiter">// </span><span class="org-comment">&#30452;&#25509;&#20351;&#29992;&#23439;g_pExecMan&#23601;&#21487;&#20197;&#21333;&#20363;</span>

<span class="org-keyword">class</span> <span class="org-type">CExecMan</span>
{
    DECLARE_SINGLETON(<span class="org-type">CExecMan</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#20363;&#27169;&#24335;</span>
    <span class="org-keyword">public</span>:
    ~<span class="org-function-name">CExecMan</span>();
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nWorkers</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nTimerPrecision</span>);
    <span class="org-type">void</span> <span class="org-function-name">Stop</span>(<span class="org-type">bool</span> <span class="org-variable-name">bWait</span>);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#19968;&#20010;&#20219;&#21153;</span>
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">QueueExec</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">bool</span> <span class="org-variable-name">bClientReferred</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#19968;&#20010;&#32039;&#24613;&#20219;&#21153;</span>
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">QueueExecEmergent</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">bool</span> <span class="org-variable-name">bClientReferred</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">todo:</span>
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">ProxyExec</span>(<span class="org-type">int</span> <span class="org-variable-name">nAckCode</span>, <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span>, <span class="org-type">PROXY_EXEC_PROC</span> <span class="org-variable-name">fProc</span>, <span class="org-type">ProxyExecCtx</span>* <span class="org-variable-name">pCtx</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25552;&#20132;&#19968;&#20010;&#23450;&#26102;&#22120;&#20219;&#21153;</span>
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">DelayExec</span>(<span class="org-type">int</span> <span class="org-variable-name">nAction</span>, <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>, <span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21462;&#28040;&#19968;&#20010;&#20219;&#21153;</span>
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">CancelExec</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26816;&#26597;&#23450;&#26102;&#22120;</span>
    <span class="org-type">void</span> <span class="org-function-name">RunTimer</span>();

  <span class="org-keyword">private</span>:
    <span class="org-type">CThreadPool</span> <span class="org-variable-name">m_ThreadPool</span>;
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">m_nCurJobs</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#36816;&#34892;&#26399;&#38388;&#26377;&#22810;&#23569;Job&#27491;&#22312;&#34987;&#25552;&#20132;</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2"><span class="section-number-4">2.6.2</span> Start &amp; Stop</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Start逻辑很简单，包括计算1s对应多少cycle数目以及启动线程池。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CExecMan</span>::<span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nWorkers</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nTimerPrecision</span>)
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#31639;&#19968;&#19979;CPU&#19968;&#20010;tick&#26377;&#22810;&#23569;&#20010;cycle&#25968;&#30446;&#65292;&#36825;&#26679;&#21487;&#20197;&#36890;&#36807;rdstc&#36716;&#25442;&#25104;&#20026;&#26102;&#38388;</span>
    g_nCycleStart = rdtsc();
    g_nLastTick = 0;
    g_nTickPrecision = (nTimerPrecision &gt;= 1000) ? 1000 : nTimerPrecision;
    g_nCyclesInTick = GetCpuFreq() / (1000 / g_nTickPrecision);
    <span class="org-keyword">if</span> (0 &lt; m_ThreadPool.Start(nWorkers, fInit)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21551;&#21160;&#32447;&#31243;&#27744;</span>
        AtomicSetValue(m_nCurJobs, 0);
        <span class="org-keyword">return</span> APFE_OK;
    }
    <span class="org-keyword">return</span> APFE_SYS_ERROR;
}
</pre>
</div>

<p>
Stop逻辑的话可能需要仔细理解一下
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">bWait&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#31561;&#24453;kylin&#30340;&#32447;&#31243;&#27744;&#27491;&#24120;&#32467;&#26463;&#65292;&#25191;&#34892;&#23436;&#25104;&#32447;&#31243;&#27744;&#37324;&#38754;&#20219;&#21153;&#20026;&#27490;&#12290;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#26029;&#20462;&#27491;m_nCurJobs&#20316;&#29992;&#26159;&#20026;&#20102;&#38459;&#27490;&#26032;&#20219;&#21153;&#30340;&#25552;&#20132;&#12290;&#36825;&#20010;&#25105;&#20204;&#21487;&#20197;&#22312;QueuExec&#37096;&#20998;&#32852;&#21512;&#36215;&#26469;&#19968;&#36215;&#30475;&#30475;</span>
<span class="org-type">void</span> <span class="org-constant">CExecMan</span>::<span class="org-function-name">Stop</span>(<span class="org-type">bool</span> <span class="org-variable-name">bWait</span>)
{
    <span class="org-keyword">if</span> (bWait) {
        <span class="org-type">int</span> <span class="org-variable-name">n</span>;
        <span class="org-keyword">while</span> (0 != (n=atomic_comp_swap(&amp;m_nCurJobs, LARGE_ENOUGH_NEGATIVE, 0))) {
            <span class="org-keyword">if</span> (LARGE_ENOUGH_NEGATIVE == n) {
                <span class="org-keyword">return</span>;
            }
            Sleep(1);
        }
        m_ThreadPool.Stop();
    }
    <span class="org-keyword">else</span> {
        AtomicSetValue(m_nCurJobs, LARGE_ENOUGH_NEGATIVE);
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6-3" class="outline-4">
<h4 id="sec-2-6-3"><span class="section-number-4">2.6.3</span> QueueExec</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
QueueExec和QueueExecEmergent逻辑非常相似，只不过底层调用线程池的QueueJob和QueueEmergentJob.我们这里只看QueueExec.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span>
<span class="org-function-name">Proc</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>)
{
    <span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span> = (<span class="org-type">AsyncContext</span>*)pJob;
    <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span> = pCtx-&gt;pClient;

    pCtx-&gt;fProc = <span class="org-constant">NULL</span>;
    pClient-&gt;OnCompletion(pCtx);
    pClient-&gt;Release();
}

<span class="org-comment-delimiter">// </span><span class="org-comment">bClientReferref&#34920;&#26126;&#29992;&#25143;&#26159;&#21542;&#21152;&#20102;&#24341;&#29992;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25353;&#29031;sunxiao&#30340;&#35828;&#26126;&#65292;&#25105;&#20204;&#36825;&#37324;&#26368;&#22909;&#27704;&#36828;&#20889;true,&#28982;&#21518;&#25105;&#20204;&#22312;&#22806;&#38754;&#35843;&#29992;&#28857;&#33258;&#24049;AddRef&#21644;DecRef</span>
<span class="org-type">APF_ERROR</span> <span class="org-constant">CExecMan</span>::<span class="org-function-name">QueueExec</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">bool</span> <span class="org-variable-name">bClientReferred</span>)
{
    VERIFY_OR_RETURN(<span class="org-constant">NULL</span> != pCtx, APFE_INVALID_ARGS);
    VERIFY_OR_RETURN(<span class="org-constant">NULL</span> != pCtx-&gt;pClient, APFE_INVALID_ARGS);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;atomic +1 &lt;0&#30340;&#35805;&#65292;&#37027;&#20040;&#35828;&#26126;&#36825;&#20010;&#26102;&#20505;m_nCurJobs&#24050;&#32463;&#34987;&#32622;&#36807;LARGE_ENOUGH_NEGATIVE&#20102;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#28982;&#25105;&#20204;&#26159;&#26377;&#20551;&#35774;m_nCurJobs&#19981;&#20250;&#38750;&#24120;&#24555;&#22320;&#22797;&#20301;&#65292;&#21487;&#20197;&#35748;&#20026;&#36825;&#20010;&#26159;&#25104;&#31435;&#30340;</span>
    <span class="org-keyword">if</span> (atomic_add(&amp;m_nCurJobs, 1) &gt;= 0) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: if the number of workers is dynamic, we may need to lock and re-dispatch exisiting events...</span>
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bClientReferred) {
            pCtx-&gt;pClient-&gt;AddRef();
        }
        pCtx-&gt;fProc = Proc; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32622;ctx&#30340;fProc&#20026;Proc</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#26681;&#25454;client&#30340;AsyncId&#26469;&#20915;&#23450;&#25351;&#27966;&#21040;&#21738;&#19968;&#20010;&#32447;&#31243;&#24037;&#20316;</span>
        m_ThreadPool.QueueJob((<span class="org-type">Job</span>*)pCtx, pCtx-&gt;pClient-&gt;GetAsyncId() % m_ThreadPool.GetWorkerCount());
        atomic_add(&amp;m_nCurJobs, -1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#24403;&#21069;&#27491;&#22312;&#25552;&#20132;&#30340;Jobs&#20010;&#25968;-1.</span>
        <span class="org-keyword">return</span> APFE_OK;
    }
    <span class="org-keyword">if</span> (bClientReferred) {
        pCtx-&gt;pClient-&gt;Release();
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#23558;m_nCurJobs&#37325;&#32622;</span>
    AtomicSetValue(m_nCurJobs, LARGE_ENOUGH_NEGATIVE);
    <span class="org-keyword">if</span> (IsKylinRunning()) {
        TRACE0(<span class="org-string">"Fatal error: Exec workers are not started\n"</span>);
    }
    <span class="org-keyword">return</span> APFE_NO_WORKER;
}
</pre>
</div>
<p>
我们这里可以看到m_nCurJobs在QueueExec和Stop之间的配合。然后我们稍微看看Proc这个过程，对于CPU任务直接调用OnCompletion然后调用Release.
</p>
</div>
</div>

<div id="outline-container-sec-2-6-4" class="outline-4">
<h4 id="sec-2-6-4"><span class="section-number-4">2.6.4</span> Timer</h4>
<div class="outline-text-4" id="text-2-6-4">
<p>
定时器任务加入是DelayExec,检查触发是RunTimer.如果查看CallGraph的话会发现RunTimer都是在网络部分调用的，我们在网络部分看看触发的时机。
DelayExec里面的逻辑会根据定时时间来判断如何实现，如果定时时间超过g_nTickPrecision，那么会将超时时间加入一个map里面去，然后让RunTimer去触发。
否则会加入线程池里面去。对于加入到map里面的fProc有一个特殊的标记(JOB_PROC)2.在CancelExec时候会认识这个特殊标记，将事件从map中删除。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CExecMan</span>::<span class="org-function-name">DelayExec</span>(<span class="org-type">int</span> <span class="org-variable-name">nAction</span>, <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>, <span class="org-type">AsyncContext</span>* <span class="org-variable-name">pCtx</span>)
{
    VERIFY_OR_RETURN(<span class="org-constant">NULL</span> != pClient, APFE_INVALID_ARGS);
    VERIFY_OR_RETURN(<span class="org-constant">NULL</span> != pCtx, APFE_INVALID_ARGS);

    pCtx-&gt;nAction = nAction;
    pCtx-&gt;pClient = pClient;
    pCtx-&gt;fProc = (<span class="org-type">JOB_PROC</span>)2;

    <span class="org-keyword">if</span> (g_nTickPrecision &lt;= nMilliseconds) {
        pClient-&gt;AddRef();

        s_Lock.Lock();
        <span class="org-comment-delimiter">/* </span><span class="org-comment">milliseconds -&gt; ticks */</span>
        nMilliseconds = g_nLastTick + nMilliseconds / g_nTickPrecision;
        pCtx-&gt;nErrCode = nMilliseconds;
        s_TimerMap.insert(nMilliseconds, pCtx);
        s_Lock.Unlock();
        <span class="org-keyword">return</span> APFE_OK;
    }

    <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>;
    s_Lock.Lock();
    err = QueueExec(pCtx, <span class="org-constant">false</span>);
    s_Lock.Unlock();
    <span class="org-keyword">return</span> err;
}
</pre>
</div>

<p>
然后我看看看RunTimer这个部分。这个部分非常简单，就是根据当前时间判断map里面哪些定时器需要进行触发，然后将触发逻辑作为Job丢入CPU线程池。
我们这里不看RunTimer具体代码，反而倒是对外面的一些小细节比较感兴趣。我们不希望RunTimer被多个实例调用，只要有一个实例调用就OK，使用CToken完成。
当然可以使用mutex+try_lock来实现但是开销应该会更大。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CExecMan</span>::<span class="org-function-name">RunTimer</span>()
{
    <span class="org-keyword">static</span> <span class="org-type">CToken</span> <span class="org-variable-name">token</span>;
    <span class="org-variable-name">UNLIKELY_IF</span> (<span class="org-negation-char">!</span>token.TryAcquire(1)) {
        <span class="org-keyword">return</span>;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    token.Release(1);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6-5" class="outline-4">
<h4 id="sec-2-6-5"><span class="section-number-4">2.6.5</span> Example</h4>
<div class="outline-text-4" id="text-2-6-5">
<p>
我们这里给的例子非常简单，但是希望有启发性.我们从1开始进行打印，每打印1个数字就认为当前任务结束，一直无限打印。
但是我们同时会启动一个定时器，只允许我们做1.2s钟时间的打印。如果我们在1.2s内打印数字个数超过了100个的话，那么我们重启一个定时器1.2s，
而这次打印数字个数阈值为200个之后每次翻倍，直到1.2s内没有打印我们所希望个数的话程序退出。在主线程100ms来检查ExecMan的RunTimer.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;time.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"stdafx.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Kylin.h"</span>

<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">worker</span>=16;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">PRINT</span>=0;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">TIMEOUT</span>=1;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">TIMEOUT_MS</span>=1200;

<span class="org-keyword">class</span> <span class="org-type">XAsyncClient</span>:<span class="org-keyword">public</span> <span class="org-type">CAsyncClient</span>{
  <span class="org-keyword">public</span>:
    <span class="org-type">AsyncContext</span> <span class="org-variable-name">print_ctx</span>;
    <span class="org-type">AsyncContext</span> <span class="org-variable-name">delay_ctx</span>;
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">int</span> <span class="org-variable-name">current_number</span>;
    <span class="org-type">int</span> <span class="org-variable-name">threshold</span>;
    <span class="org-type">int</span> <span class="org-variable-name">last_working_number</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">stop</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#26086;stop&#37027;&#20040;&#31435;&#21051;&#21518;&#38754;&#20869;&#23481;&#37117;&#19981;&#25171;&#21360;&#20102;</span>
    <span class="org-function-name">XAsyncClient</span>(<span class="org-type">int</span> <span class="org-variable-name">id_</span>):
            id(id_),
            current_number(1),
            threshold(100),
            last_working_number(0),
            stop(<span class="org-constant">false</span>){
        InitAsyncContext(&amp;print_ctx);
        InitAsyncContext(&amp;delay_ctx);
        print_ctx.pClient=<span class="org-keyword">this</span>;
        delay_ctx.pClient=<span class="org-keyword">this</span>;
    }
    <span class="org-type">int</span> <span class="org-function-name">Release</span>(){ <span class="org-comment-delimiter">// </span><span class="org-comment">Release&#36890;&#24120;&#37117;&#26159;&#36825;&#26679;&#20889;&#30340;</span>
        <span class="org-type">int</span> <span class="org-variable-name">n</span>=<span class="org-constant">CAsyncClient</span>::Release();
        <span class="org-keyword">if</span>(n==0){
            <span class="org-keyword">delete</span> <span class="org-keyword">this</span>;
        }
        <span class="org-keyword">return</span> n;
    }
    <span class="org-type">void</span> <span class="org-function-name">Start</span>(){ <span class="org-comment-delimiter">// </span><span class="org-comment">&#21551;&#21160;&#26102;&#20505;&#25105;&#20204;&#21457;&#36215;&#20004;&#20010;Job</span>
        print_ctx.nAction=PRINT;
        <span class="org-constant">CAsyncClient</span>::AddRef();
        g_pExecMan-&gt;QueueExec(&amp;print_ctx,<span class="org-constant">true</span>);
        <span class="org-constant">CAsyncClient</span>::AddRef();
        g_pExecMan-&gt;DelayExec(TIMEOUT,<span class="org-keyword">this</span>,TIMEOUT_MS,&amp;delay_ctx);
    }
    <span class="org-type">void</span> <span class="org-function-name">Print</span>(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d,current:%d\n"</span>,id,<span class="org-constant">CAsyncClient</span>::GetRef(),
                current_number);
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">ctx</span>){
        <span class="org-keyword">switch</span>(ctx-&gt;nAction){ <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#21035;&#22788;&#29702;&#36825;&#20004;&#20010;&#31867;&#22411;Job</span>
            <span class="org-keyword">case</span> PRINT:
                <span class="org-keyword">if</span>(stop){
                    <span class="org-keyword">break</span>;
                }
                fprintf(stderr,<span class="org-string">"(%d)%d\n"</span>,id,current_number);
                current_number++;
                <span class="org-keyword">if</span>((current_number-last_working_number)&gt;=threshold){
                    <span class="org-comment-delimiter">// </span><span class="org-comment">update</span>
                    last_working_number=current_number;
                    threshold*=2;
                    <span class="org-comment-delimiter">// </span><span class="org-comment">canel timer.</span>
                    fprintf(stderr,<span class="org-string">"(%d)==============================restart timer==============================\n"</span>,id);
                    g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
                    g_pExecMan-&gt;DelayExec(TIMEOUT,<span class="org-keyword">this</span>,TIMEOUT_MS,&amp;delay_ctx);
                }
                <span class="org-constant">CAsyncClient</span>::AddRef();
                g_pExecMan-&gt;QueueExec(&amp;print_ctx,<span class="org-constant">true</span>);
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> TIMEOUT:
                fprintf(stderr,<span class="org-string">"(%d)********************quit********************\n"</span>,id);
                atomic_add(&amp;worker,-1);
                stop=<span class="org-constant">true</span>;
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                assert(0);
        }
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    <span class="org-comment-delimiter">// </span><span class="org-comment">use 4 exec threads.</span>
    InitKylin(4,0,0);
    <span class="org-comment-delimiter">// </span><span class="org-comment">100ms</span>
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span> <span class="org-variable-name">spec</span>={0,100*1000000};
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">worker_num</span>=worker;
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt; <span class="org-type">XAsyncClient</span>* &gt; <span class="org-variable-name">vec</span>;
    <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>=0;i&lt;worker_num;i++){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=<span class="org-keyword">new</span> <span class="org-type">XAsyncClient</span>(i);
        vec.push_back(client);
        client-&gt;Start();
    }
    <span class="org-keyword">while</span>(1){
        nanosleep(&amp;spec,<span class="org-constant">NULL</span>);
        <span class="org-comment-delimiter">//</span><span class="org-comment">Sleep(1);</span>
        <span class="org-keyword">if</span>(AtomicGetValue(worker)==0){
            StopKylin(<span class="org-constant">true</span>);
            <span class="org-keyword">break</span>;
        }<span class="org-keyword">else</span>{ <span class="org-comment-delimiter">// </span><span class="org-comment">&#20027;&#32447;&#31243;&#25105;&#20204;&#27599;&#38548;100ms&#26816;&#26597;&#19968;&#27425;&#36229;&#26102;&#24773;&#20917;</span>
            g_pExecMan-&gt;RunTimer();
        }
    }
    <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>=0;i&lt;worker_num;i++){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=vec[i];
        client-&gt;Print(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36864;&#20986;&#26102;&#20505;&#25171;&#21360;&#19968;&#19979;&#20449;&#24687;</span>
        <span class="org-keyword">delete</span> client;
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> DiskMan</h3>
<div class="outline-text-3" id="text-2-7">
</div><div id="outline-container-sec-2-7-1" class="outline-4">
<h4 id="sec-2-7-1"><span class="section-number-4">2.7.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
我们首先看看和磁盘相关的两个比较重要的类。因为磁盘操作不像CPU操作一样不需要任何辅助数据结构，磁盘操作需要一些信息比如fd等，磁盘操作需要一个特殊的磁盘Context。
然后每次发起磁盘操作使用另外一个结构Request.这里名字上和原来的CPU事件并不太一样，我们可能需要习惯一下。实际上如果我们需要映射到CPU事件里面的话，这两个Context应该结合在一起。
只不过这里DiskContext不是经常变动的部分，而DiskRequest是经常变动的部分所以分离开了。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;&#30913;&#30424;&#25805;&#20316;&#30456;&#20851;&#30340;Context</span>
<span class="org-keyword">struct</span> <span class="org-type">DiskContext</span> {
    <span class="org-type">int</span> <span class="org-variable-name">fd</span>;
    <span class="org-type">int</span> <span class="org-variable-name">diskno</span>;<span class="org-comment-delimiter">// </span><span class="org-comment">which disk</span>
    <span class="org-type">CAsyncClient</span> *<span class="org-variable-name">pClient</span>;
    <span class="org-type">uint64</span> <span class="org-variable-name">nCurOff</span>, <span class="org-variable-name">nRead</span>, <span class="org-variable-name">nWrite</span>;
    <span class="org-type">char</span>* <span class="org-variable-name">pPath</span>;<span class="org-comment-delimiter">// </span><span class="org-comment">file path</span>
    <span class="org-type">int</span> <span class="org-variable-name">nFlag</span>;<span class="org-comment-delimiter">// </span><span class="org-comment">file open flag</span>
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;&#19968;&#27425;&#21457;&#36215;&#30340;&#35831;&#27714;</span>
<span class="org-keyword">struct</span> <span class="org-type">DiskRequest</span> {
    <span class="org-keyword">union</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#20351;&#29992;&#36825;&#31181;&#26041;&#24335;&#32431;&#31929;&#26159;&#20026;&#20102;&#20889;&#36215;&#26469;&#26041;&#20415;</span>
        <span class="org-type">AsyncContext</span> <span class="org-variable-name">async</span>;
        <span class="org-type">Job</span> <span class="org-variable-name">job</span>;
    };
    <span class="org-comment-delimiter">/* </span><span class="org-comment">!!the first element must be AsyncContext */</span>
    <span class="org-type">void</span> *<span class="org-variable-name">buf</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#20889;&#25918;&#21040;&#20160;&#20040;&#22320;&#26041;</span>
    <span class="org-type">int</span> <span class="org-variable-name">request</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#20889;&#22810;&#23569;&#23383;&#33410;&#25968;&#25454;</span>
    <span class="org-type">int</span> <span class="org-variable-name">xfered</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">&#24403;&#21069;&#23454;&#38469;&#35835;&#20889;&#20102;&#22810;&#23569;&#25968;&#25454;</span>
    <span class="org-type">uint64</span> <span class="org-variable-name">off</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#20160;&#20040;&#20559;&#31227;&#19978;&#35835;&#20889;</span>
    <span class="org-type">DiskContext</span> *<span class="org-variable-name">pCtx</span>;
};
</pre>
</div>
<p>
然后在看看DiskMan接口
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#define</span> <span class="org-variable-name">g_pDiskMan</span> <span class="org-constant">CDiskMan</span>::Instance() <span class="org-comment-delimiter">// </span><span class="org-comment">&#30452;&#25509;&#20351;&#29992;&#23439;g_pDiskMan&#23601;&#21487;&#20197;&#21333;&#20363;</span>

<span class="org-keyword">class</span> <span class="org-type">CDiskMan</span>
{
    DECLARE_SINGLETON(<span class="org-type">CDiskMan</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#20363;&#27169;&#24335;</span>
    <span class="org-keyword">public</span>:
    ~<span class="org-function-name">CDiskMan</span>();

    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nDisks</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>);
    <span class="org-type">void</span> <span class="org-function-name">Stop</span>();

    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Associate</span>(<span class="org-type">int</span> <span class="org-variable-name">diskno</span>, <span class="org-type">int</span> <span class="org-variable-name">fd</span>, <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span>, <span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>);
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Associate</span>(<span class="org-type">int</span> <span class="org-variable-name">diskno</span>, <span class="org-type">char</span>* <span class="org-variable-name">pPath</span>, <span class="org-type">int</span> <span class="org-variable-name">nFlag</span>, <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span>, <span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>);
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Deassociate</span>(<span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>);

    <span class="org-type">void</span> <span class="org-function-name">Read</span>(<span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">DiskRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Write</span>(<span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">DiskRequest</span>* <span class="org-variable-name">pReq</span>);

  <span class="org-keyword">private</span>:
    <span class="org-type">CThreadPool</span> <span class="org-variable-name">m_ThreadPool</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">m_bStarted</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7-2" class="outline-4">
<h4 id="sec-2-7-2"><span class="section-number-4">2.7.2</span> Start &amp; Stop</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
启动停止逻辑非常简单，就是让线程池启动和停止
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CDiskMan</span>::<span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nDisks</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>)
{
    ASSERT(nDisks &lt;= MAX_NR_DISKS);
    ASSERT(<span class="org-negation-char">!</span>IsStarted());
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO::: if 0 then check the number of disks</span>
    <span class="org-keyword">if</span> (m_ThreadPool.Start(nDisks, fInit) &gt; 0) {
        m_bStarted = <span class="org-constant">true</span>;
        <span class="org-keyword">return</span> APFE_OK;
    }
    <span class="org-keyword">return</span> APFE_SYS_ERROR;
}

<span class="org-type">void</span> <span class="org-constant">CDiskMan</span>::<span class="org-function-name">Stop</span>()
{
    <span class="org-keyword">if</span> (m_bStarted) {
        m_bStarted = <span class="org-constant">false</span>;
        m_ThreadPool.Stop();
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7-3" class="outline-4">
<h4 id="sec-2-7-3"><span class="section-number-4">2.7.3</span> Associate &amp; Deassociate</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
逻辑非常简单，就是进行一下DiskContext和CAsyncClient初始化的工作。关于DiskContext里面各个字段含义的话，都是在Read/Write时候解释的。
关于这里最重点的绑定内容就是diskno.diskno非常作用类似于CPU事件里面的AsyncId.相同AsyncId可以分摊到同一个CPU线程这件可以免去加锁开销，
而diskno可以让多个DiskContext分摊到同一个Disk线程，不同线程绑定不同的磁盘驱动器，这样可以让同一个磁盘驱动器仅仅为几个文件服务。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CDiskMan</span>::<span class="org-function-name">Associate</span>(<span class="org-type">int</span> <span class="org-variable-name">diskno</span>, <span class="org-type">char</span>* <span class="org-variable-name">pPath</span>, <span class="org-type">int</span> <span class="org-variable-name">nFlag</span>,
                              <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span>, <span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>)
{
    pContext-&gt;fd = -1;
    pContext-&gt;diskno = diskno;
    pContext-&gt;pClient = pClient;
    pContext-&gt;nCurOff = pContext-&gt;nRead = pContext-&gt;nWrite = 0;
    pContext-&gt;pPath = pPath;
    pContext-&gt;nFlag = nFlag;
    pClient-&gt;AddRef();
    <span class="org-keyword">return</span> APFE_OK;
}

<span class="org-type">APF_ERROR</span> <span class="org-constant">CDiskMan</span>::<span class="org-function-name">Deassociate</span>(<span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>)
{
    <span class="org-keyword">if</span> (pContext-&gt;pPath &amp;&amp; pContext-&gt;fd!=-1) {
        close(pContext-&gt;fd);
    }
    pContext-&gt;pClient-&gt;Release();
    <span class="org-keyword">return</span> APFE_OK;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7-4" class="outline-4">
<h4 id="sec-2-7-4"><span class="section-number-4">2.7.4</span> Read &amp; Write</h4>
<div class="outline-text-4" id="text-2-7-4">
<p>
文件的Read/Write非常简单，因为本身就是一个阻塞的过程，发起一次就可以保证读取所有内容了，所以不像网络一样需要多次发起。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CDiskMan</span>::<span class="org-function-name">Read</span>(<span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">DiskRequest</span>* <span class="org-variable-name">pReq</span>)
{
    pReq-&gt;async.nAction = AA_READ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;nAction,&#28982;&#21518;QueueTask,Task&#20013;&#22238;&#35843;&#23601;&#26159;ReadOp</span>
    QUEUE_TASK(pContext, pReq, ReadOp, pBuf, count);
}

<span class="org-type">void</span> <span class="org-constant">CDiskMan</span>::<span class="org-function-name">Write</span>(<span class="org-type">DiskContext</span>* <span class="org-variable-name">pContext</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">DiskRequest</span>* <span class="org-variable-name">pReq</span>)
{
    pReq-&gt;async.nAction = AA_WRITE; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;nAction,&#28982;&#21518;QueueTask,Task&#20013;&#22238;&#35843;&#23601;&#26159;WriteOp</span>
    QUEUE_TASK(pContext, pReq, WriteOp, pBuf, count);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#30475;&#21040;&#36825;&#37324;pClient&#24050;&#32463;&#24110;&#25105;&#20204;AddRef&#20102;&#65292;&#25152;&#20197;&#25105;&#20204;&#22312;&#23454;&#38469;&#32534;&#20889;App&#19981;&#38656;&#35201;&#20877;&#27425;AddRef</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">QUEUE_TASK</span>(<span class="org-variable-name">pContext</span>, <span class="org-variable-name">pReq</span>, <span class="org-variable-name">f</span>, <span class="org-variable-name">pBuf</span>, <span class="org-variable-name">count</span>)                  \
    pContext-&gt;pClient-&gt;AddRef();                                    \
    pReq-&gt;async.pClient = pContext-&gt;pClient;                        \
    pReq-&gt;job.fProc = f;                                            \
    pReq-&gt;buf = pBuf;                                               \
    pReq-&gt;request = count;                                          \
    pReq-&gt;xfered = 0;                                               \
    pReq-&gt;pCtx = pContext;                                          \
    m_ThreadPool.QueueJob(&amp;pReq-&gt;job, pContext-&gt;diskno)
</pre>
</div>

<p>
从上面分析的话，所有重要的工作都分摊在了ReadOp和WriteOp上面。我们需要做的是Dig下去看看两个是怎么工作的。但是很不幸，两个函数里面内容都是使用了宏DiskOp.
DiskOp(a,b,c)其中a表示对应的系统调用叫什么名字，b表示这个Job,c表示读写(没有使用).
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span>
<span class="org-function-name">ReadOp</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>)
{
    DISK_OP(read, pJob, 0);
}

<span class="org-keyword">static</span> <span class="org-type">void</span>
<span class="org-function-name">WriteOp</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>)
{
    DISK_OP(write, pJob, 1);
}
</pre>
</div>

<p>
继续Dig看看DISKOP是怎么工作的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#23436;&#25104;&#20043;&#21518;&#35774;&#32622;ErrCode,&#24182;&#19988;&#21152;&#20837;CPU&#32447;&#31243;&#27744;&#12290;&#29992;&#25143;&#26368;&#32456;&#22788;&#29702;&#30340;&#35805;&#38656;&#35201;&#24378;&#21046;&#36716;&#25442;DiskRequest.</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">NotifyClient</span>(<span class="org-variable-name">err</span>, <span class="org-variable-name">req</span>)    {                                     \
        req-&gt;async.nErrCode = err;                                      \
        g_pExecMan-&gt;QueueExec((<span class="org-type">AsyncContext</span>*)req, <span class="org-constant">true</span>);                \
    }

<span class="org-comment-delimiter">// </span><span class="org-comment">1.&#21487;&#20197;&#30475;&#21040;&#22914;&#26524;fd==-1&#30340;&#35805;&#20250;&#33258;&#21160;&#25171;&#24320;&#25991;&#20214;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">2.&#21028;&#26029;&#19968;&#19979;&#21457;&#36215;&#30340;off&#21644;context&#26159;&#21542;&#19968;&#33268;&#65292;&#19981;&#19968;&#33268;&#30340;&#35805;&#20351;&#29992;pread/pwrite,&#28982;&#21518;&#20462;&#25913;off</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">3.&#35835;&#21462;&#23436;&#25104;&#20043;&#21518;&#20351;&#29992;NotifyClient&#36890;&#30693;App</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">DISK_OP</span>(<span class="org-variable-name">op</span>, <span class="org-variable-name">j</span>, <span class="org-variable-name">rw</span>)                                              \
    <span class="org-type">DiskRequest</span>* <span class="org-variable-name">pReq</span> = CONTAINING_RECORD(j, DiskRequest, job);         \
    <span class="org-type">DiskContext</span>* <span class="org-variable-name">pCtx</span> = pReq-&gt;pCtx;                                     \
    <span class="org-variable-name">UNLIKELY_IF</span> (-1 == pCtx-&gt;fd) {                                      \
        pCtx-&gt;fd = open(pCtx-&gt;pPath, pCtx-&gt;nFlag, 0644);                \
        <span class="org-variable-name">UNLIKELY_IF</span> (-1 == pCtx-&gt;fd) {                                  \
            NotifyClient(errno, pReq);                                  \
            <span class="org-keyword">return</span>;                                                     \
        }                                                               \
    }                                                                   \
    <span class="org-type">uint64</span> <span class="org-variable-name">cost</span> = rdtsc();                                              \
    <span class="org-type">int</span> <span class="org-variable-name">len</span>;                                                            \
    <span class="org-keyword">if</span> (pReq-&gt;off != pCtx-&gt;nCurOff) {                                   \
        len = p ## op(pCtx-&gt;fd, pReq-&gt;buf, pReq-&gt;request, pReq-&gt;off);   \
        pCtx-&gt;nCurOff = pReq-&gt;off;                                      \
    }                                                                   \
    <span class="org-keyword">else</span> {                                                              \
        len = op(pCtx-&gt;fd, pReq-&gt;buf, pReq-&gt;request);                   \
    }                                                                   \
    <span class="org-keyword">if</span> (len &gt;= 0) {                                                     \
        cost = rdtsc() - cost;                                          \
        <span class="org-type">int</span> <span class="org-variable-name">which</span> = (pCtx-&gt;diskno&lt;&lt;1) + rw;                             \
        g_nDiskStats[which] += len;                                     \
        g_nDiskCosts[which] += cost;                                    \
        pCtx-&gt;nCurOff += len;                                           \
        pReq-&gt;off += len;                                               \
        pReq-&gt;xfered = len;                                             \
        NotifyClient(0, pReq);                                          \
    }                                                                   \
    <span class="org-keyword">else</span> {                                                              \
        NotifyClient(errno, pReq);                                      \
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7-5" class="outline-4">
<h4 id="sec-2-7-5"><span class="section-number-4">2.7.5</span> Example</h4>
<div class="outline-text-4" id="text-2-7-5">
<p>
例子非常简单就是我们首先发起一个磁盘操作写文件然后在将去读取出来。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;time.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"stdafx.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Kylin.h"</span>

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">worker_num</span>=8;
<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">worker</span>=worker_num;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">fname_prefix</span>=<span class="org-string">"hello"</span>;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">content</span>=<span class="org-string">"world"</span>;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">READ</span>=0;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">WRITE</span>=1;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">disk_thread_num</span>=4;

<span class="org-keyword">class</span> <span class="org-type">XDiskRequest</span>:<span class="org-keyword">public</span> <span class="org-type">DiskRequest</span>{
  <span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">nAction</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">what kind of operation we init.</span>
};

<span class="org-keyword">class</span> <span class="org-type">XAsyncClient</span>:<span class="org-keyword">public</span> <span class="org-type">CAsyncClient</span>{
  <span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-type">DiskContext</span> <span class="org-variable-name">disk_ctx</span>;
    <span class="org-type">XDiskRequest</span> <span class="org-variable-name">disk_req</span>;
    <span class="org-function-name">XAsyncClient</span>(<span class="org-type">int</span> <span class="org-variable-name">id_</span>):
            <span class="org-function-name">id</span>(id_){
        <span class="org-comment-delimiter">// </span><span class="org-comment">make filename.</span>
        <span class="org-type">char</span> <span class="org-variable-name">tmp</span>[128];
        snprintf(tmp,<span class="org-keyword">sizeof</span>(tmp),<span class="org-string">"%s_%d"</span>,fname_prefix,id);
        name=tmp;
        g_pDiskMan-&gt;Associate(id%disk_thread_num,<span class="org-keyword">const_cast</span>&lt;<span class="org-type">char</span>*&gt;(name.c_str()),O_RDWR | O_CREAT,<span class="org-keyword">this</span>,&amp;disk_ctx);
    }
    ~<span class="org-function-name">XAsyncClient</span>(){
        g_pDiskMan-&gt;Deassociate(&amp;disk_ctx);
    }
    <span class="org-type">void</span> <span class="org-function-name">Start</span>(){
        disk_req.nAction=WRITE;
        <span class="org-type">char</span>* <span class="org-variable-name">s</span>=strdup(content);
        <span class="org-comment-delimiter">// </span><span class="org-comment">ctx off=0.write from the beginning</span>
        g_pDiskMan-&gt;Write(&amp;disk_ctx,s,strlen(s)+1,&amp;disk_req);
    }
    <span class="org-type">void</span> <span class="org-function-name">Print</span>(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d\n"</span>,id,<span class="org-constant">CAsyncClient</span>::GetRef());
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">ctx</span>){
        <span class="org-type">XDiskRequest</span>* <span class="org-variable-name">req</span>=(<span class="org-type">XDiskRequest</span>*)ctx;
        <span class="org-keyword">if</span>(req-&gt;nAction==WRITE){
            assert(req-&gt;xfered==req-&gt;request);
            <span class="org-comment-delimiter">// </span><span class="org-comment">free written buffer.</span>
            free(req-&gt;buf);
            <span class="org-comment-delimiter">// </span><span class="org-comment">begin to read.</span>
            disk_req.nAction=READ;
            disk_req.off=0; <span class="org-comment-delimiter">// </span><span class="org-comment">read from beginning</span>
            <span class="org-type">char</span>* <span class="org-variable-name">s</span>=(<span class="org-type">char</span>*)malloc(req-&gt;request);
            g_pDiskMan-&gt;Read(&amp;disk_ctx,s,req-&gt;request,&amp;disk_req);
        }<span class="org-keyword">else</span> <span class="org-keyword">if</span>(req-&gt;nAction==READ){
            assert(req-&gt;xfered==req-&gt;request);
            fprintf(stderr,<span class="org-string">"(%d)%s\n"</span>,id,req-&gt;buf);
            <span class="org-comment-delimiter">// </span><span class="org-comment">free read buffer.</span>
            free(req-&gt;buf);
            atomic_add(&amp;worker,-1);
        }
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    <span class="org-comment-delimiter">// </span><span class="org-comment">use 4 disk threads.</span>
    InitKylin(1,1,disk_thread_num);
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt; <span class="org-type">XAsyncClient</span>* &gt; <span class="org-variable-name">vec</span>;
    <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>=0;i&lt;worker_num;i++){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=<span class="org-keyword">new</span> <span class="org-type">XAsyncClient</span>(i);
        vec.push_back(client);
        client-&gt;Start();
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">100ms.</span>
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span> <span class="org-variable-name">timeout</span>={0,100*1000000};
    <span class="org-keyword">while</span>(1){
        nanosleep(&amp;timeout,<span class="org-constant">NULL</span>);
        <span class="org-keyword">if</span>(AtomicGetValue(worker)==0){
            StopKylin(<span class="org-constant">true</span>);
            <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>=0;i&lt;worker_num;i++){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=vec[i];
        client-&gt;Print();
        <span class="org-keyword">delete</span> client;
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> NetworkMan</h3>
<div class="outline-text-3" id="text-2-8">
</div><div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1"><span class="section-number-4">2.8.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
和网络相关的也有两个比较重要的类。同样和DiskMan相同，NetworkMan也提供了NetContext和NetRequest.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#32593;&#32476;&#35831;&#27714;</span>
<span class="org-keyword">struct</span> <span class="org-type">NetRequest</span> {
    <span class="org-keyword">union</span> {
        <span class="org-type">AsyncContext</span> <span class="org-variable-name">async</span>;
        <span class="org-type">DLINK</span> <span class="org-variable-name">link</span>;
    };
    <span class="org-comment-delimiter">/* </span><span class="org-comment">!! the first element must be AsyncContext */</span>
    <span class="org-keyword">union</span> {
        <span class="org-type">BufHandle</span> <span class="org-variable-name">hdl</span>;
        <span class="org-keyword">struct</span> {
            <span class="org-type">BufHandle</span> *<span class="org-variable-name">pHdl</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">not used by read</span>
            <span class="org-type">void</span>* <span class="org-variable-name">buf</span>;
            <span class="org-type">int</span> <span class="org-variable-name">len</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">buffer len</span>
            <span class="org-type">int</span> <span class="org-variable-name">request</span>;        <span class="org-comment-delimiter">// </span><span class="org-comment">request len</span>
        };
    };
    <span class="org-type">int</span> <span class="org-variable-name">xfered</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24050;&#32463;&#35835;&#21462;&#20102;&#22810;&#23569;&#20010;&#23383;&#33410;</span>
    <span class="org-type">uint32</span> <span class="org-variable-name">ip</span>;                  <span class="org-comment-delimiter">// </span><span class="org-comment">for UDP</span>
    <span class="org-type">uint16</span> <span class="org-variable-name">port</span>;                <span class="org-comment-delimiter">// </span><span class="org-comment">for UDP</span>
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Socket&#30456;&#20851;&#29366;&#24577;</span>
<span class="org-keyword">enum</span> <span class="org-type">SocketState</span> {
    <span class="org-variable-name">SS_VOID</span> = 0,
    <span class="org-variable-name">SS_LISTENING_0</span>,
    <span class="org-variable-name">SS_LISTENING</span>,
    <span class="org-variable-name">SS_CONNECTING_0</span>,
    <span class="org-variable-name">SS_CONNECTING</span>,
    <span class="org-variable-name">SS_CONNECTED_0</span>,
    <span class="org-variable-name">SS_CONNECTED</span>,
    <span class="org-variable-name">SS_ERROR</span>,
    <span class="org-variable-name">SS_SHUTDOWN</span>,
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Socket Flag</span>
<span class="org-keyword">enum</span> <span class="org-type">SocketFlag</span> {
    <span class="org-variable-name">SF_DIRECT_CALLBACK</span>  = 0x1, <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#23436;&#25104;&#20043;&#21518;&#22238;&#35843;&#20989;&#25968;&#30452;&#25509;&#22312;Network&#32447;&#31243;&#25191;&#34892;&#32780;&#19981;&#20002;&#21040;CPU&#32447;&#31243;</span>
    <span class="org-variable-name">SF_PERMANENT</span>        = 0x2, <span class="org-comment-delimiter">// </span><span class="org-comment">todo:???</span>
    <span class="org-variable-name">SF_UDP</span>              = 0x4, <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;UDP&#21327;&#35758;</span>
    <span class="org-variable-name">SF_DONT_EXHAUST</span>     = 0x8, <span class="org-comment-delimiter">// </span><span class="org-comment">todo:???</span>
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#32593;&#32476;&#30456;&#20851;&#25805;&#20316;&#30340;Context</span>
<span class="org-keyword">struct</span> <span class="org-type">NetContext</span> {
    <span class="org-type">SOCKET</span> <span class="org-variable-name">s</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32593;&#32476;socket</span>
    <span class="org-type">SocketState</span> <span class="org-variable-name">state</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">socket&#29366;&#24577;</span>

    <span class="org-type">DLINK</span> <span class="org-variable-name">link</span>;                 <span class="org-comment-delimiter">// </span><span class="org-comment">to link all active sockets</span>
    <span class="org-type">CLockedInt</span> <span class="org-variable-name">tWrite</span>, <span class="org-variable-name">tRead</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">todo:???</span>
    <span class="org-type">TranQueue</span> <span class="org-variable-name">qRead</span>, <span class="org-variable-name">qWrite</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#20889;&#35831;&#27714;&#38431;&#21015;&#65292;push_back&#21644;pop_front&#38656;&#35201;&#21152;&#38145;&#20294;&#26159;&#19981;&#29992;&#31561;&#24453;&#12290;</span>
    <span class="org-type">NetRequest</span> *<span class="org-variable-name">pReadReq</span>, *<span class="org-variable-name">pWriteReq</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#35835;&#20889;&#35831;&#27714;</span>
    <span class="org-type">BufHandle</span> <span class="org-variable-name">wHdl</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;BufHandle,StartWrite&#37324;&#38754;&#22810;&#27425;&#20889;&#30340;&#35805;&#24403;&#21069;BufHandle&#23601;&#20445;&#23384;&#22312;&#36825;&#37324;&#12290;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">nDelayRead&#34920;&#31034;&#26159;&#21542;&#24050;&#32463;&#21457;&#29983;&#20102;Delay&#25805;&#20316;&#65292;&#19981;&#20801;&#35768;&#22810;&#27425;&#21457;&#36215;Delay&#25805;&#20316;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">nEnabled&#34920;&#31034;&#24403;&#21069;Context&#26159;&#21542;&#21487;&#29992;</span>
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">nDelayRead</span>, <span class="org-variable-name">nEnabled</span>;
    <span class="org-type">uint32</span> <span class="org-variable-name">nTimeout</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36229;&#26102;&#26102;&#38388;</span>
    <span class="org-type">uint64</span> <span class="org-variable-name">tTimeoutCycle</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36229;&#26102;&#26102;&#38388;&#36716;&#25442;&#25104;&#20026;&#30340;cycle,&#31867;&#20284;&#20110;&#19968;&#20010;&#32477;&#23545;&#30340;&#36229;&#26102;&#26102;&#38388;</span>

    <span class="org-type">CAsyncClient</span> *<span class="org-variable-name">pClient</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#32852;&#30340;client</span>
    <span class="org-type">CEPoller</span>* <span class="org-variable-name">pPoller</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24213;&#23618;poller</span>
    <span class="org-type">uint32</span> <span class="org-variable-name">flag</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">socket flag</span>

    <span class="org-keyword">union</span> {
        <span class="org-keyword">struct</span> {                    <span class="org-comment-delimiter">// </span><span class="org-comment">for connect</span>
            <span class="org-type">uint32</span> <span class="org-variable-name">ip</span>;
            <span class="org-type">uint16</span> <span class="org-variable-name">port</span>;
        };
        <span class="org-type">uint32</span> <span class="org-variable-name">backlog</span>;             <span class="org-comment-delimiter">// </span><span class="org-comment">for listen  // listen&#30340;bakclog</span>
    };
};
</pre>
</div>
<p>
然后我们看看NetworkMan的接口
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#define</span> <span class="org-variable-name">g_pNetworkMan</span>       <span class="org-constant">CNetworkMan</span>::Instance() <span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#20363;</span>

<span class="org-keyword">typedef</span> <span class="org-type">TLockedQueue</span>&lt;NetContext, <span class="org-type">TStlList</span>&lt;<span class="org-type">NetContext</span>*&gt; &gt; <span class="org-type">NetContexts</span>;
<span class="org-keyword">class</span> <span class="org-type">CNetworkMan</span>
{
    DECLARE_SINGLETON(<span class="org-type">CNetworkMan</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#20363;</span>
    <span class="org-keyword">public</span>:
    ~<span class="org-function-name">CNetworkMan</span>();

    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nWorkers</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>);
    <span class="org-type">void</span> <span class="org-function-name">Stop</span>();

    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Associate</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>);
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Deassociate</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>);

    <span class="org-type">void</span> <span class="org-function-name">Listen</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">int</span> <span class="org-variable-name">backlog</span>);
    <span class="org-type">void</span> <span class="org-function-name">Connect</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">void</span> *<span class="org-variable-name">pWriteBuf</span>,
                 <span class="org-type">int</span> <span class="org-variable-name">nWriteCount</span>, <span class="org-type">uint32</span> <span class="org-variable-name">timeout</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Monitor</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>);
    <span class="org-type">bool</span> <span class="org-function-name">Delay</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>);

    <span class="org-type">void</span> <span class="org-function-name">Read</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>, <span class="org-type">int</span> <span class="org-variable-name">request</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Write</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);

    <span class="org-type">void</span> <span class="org-function-name">Read</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Write</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);

  <span class="org-keyword">private</span>:
    <span class="org-type">CThreadPool</span> <span class="org-variable-name">m_ThreadPool</span>;
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">m_bStarted</span>;
    <span class="org-type">NetContexts</span> <span class="org-variable-name">m_NetContexts</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31649;&#29702;&#30340;NetContext</span>
};
</pre>
</div>
<p>
虽然这个部分叫做NetworkMan,但是里面比较重要的逻辑部分都放在了EPoller里面来完成的，对于NetworkMan只不过是一个发起者的角色罢了。
对于NetworkMan部分的话还需要关注的是SocketState这个东西，因为对于EPoller来说的话只能够发现Socket究竟是可读还是可写，
我们必须根据SocketState来判断下一步应该进行什么操作。在最后的的话我们会给出SocketState的每个状态解释。
</p>
</div>
</div>

<div id="outline-container-sec-2-8-2" class="outline-4">
<h4 id="sec-2-8-2"><span class="section-number-4">2.8.2</span> Start &amp; Stop</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
过程大致是这样的，将EPoller.Run包装在一个MyJob对象里面，然后将MyJob丢入到线程池里面进行运行。一旦线程池取到MyJob,
调用的函数是EPoller.run方法。也就是说每个队列里面始终只有1个Job，所以在Stop时候我们只需要将EPoller.Close()就可以了。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Start</span>(<span class="org-type">int</span> <span class="org-variable-name">nWorkers</span>, <span class="org-type">THREAD_INIT_PROC</span> <span class="org-variable-name">fInit</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = m_ThreadPool.Start(nWorkers, fInit);
    <span class="org-keyword">if</span> (n &gt; 0) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span>=0; i&lt;n; i++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;s_Jobs&#26159;&#38745;&#24577;&#23545;&#35937;</span>
            s_Jobs[i].poller.Create(256);
            s_Jobs[i].job.fProc = Polling;
            s_Jobs[i].count = 0;
            DLINK_INITIALIZE(&amp;s_Jobs[i].job.link);
            m_ThreadPool.QueueJob(&amp;s_Jobs[i].job, i);
        }
        AtomicSetValue(m_bStarted, 1);
        <span class="org-keyword">return</span> APFE_OK;
    }
    <span class="org-keyword">return</span> APFE_SYS_ERROR;
}

<span class="org-type">void</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Stop</span>()
{
    <span class="org-keyword">if</span> (1 == atomic_comp_swap(&amp;m_bStarted, -1, 1)) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: stop all pollers</span>
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = m_ThreadPool.GetWorkerCount();
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span>=0; i&lt;n; i++) {
            s_Jobs[i].poller.Close(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#38656;&#35201;Close&#21363;&#21487;</span>
        }
        <span class="org-comment-delimiter">//</span><span class="org-comment">m_ThreadPool.Stop();</span>
    }
}
</pre>
</div>

<p>
然后我们看看MyJob以及对应的Polling是如何实现的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">MyJob</span> {
    <span class="org-type">Job</span> <span class="org-variable-name">job</span>;
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">count</span>;
    <span class="org-type">CEPoller</span> <span class="org-variable-name">poller</span>;
};
<span class="org-keyword">static</span> <span class="org-type">MyJob</span> <span class="org-variable-name">s_Jobs</span>[MAX_NR_NETWORK_WORKERS];
<span class="org-keyword">static</span> <span class="org-type">void</span>
<span class="org-function-name">Polling</span>(<span class="org-type">Job</span>* <span class="org-variable-name">pJob</span>)
{
    <span class="org-type">MyJob</span>* <span class="org-variable-name">pMyJob</span> = CONTAINING_RECORD(pJob, MyJob, job);
    pMyJob-&gt;poller.Run(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#30452;&#25509;&#35843;&#29992;poller.Run()&#21363;&#21487;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-3" class="outline-4">
<h4 id="sec-2-8-3"><span class="section-number-4">2.8.3</span> Associate &amp; Deassociate</h4>
<div class="outline-text-4" id="text-2-8-3">
<p>
Associate和Deassociate逻辑非常简单，无非就是将NetContext和网络线程池里面的EPoller绑定起来，将NetContext里面的fd给epoll来管理。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Associate</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span> = APFE_NOT_CREATED;
    ASSERT(pCtx-&gt;state &gt; SS_VOID);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: we have to be careful here, if the number of pollers is dynamic</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36873;&#25321;&#19968;&#20010;&#20851;&#32852;fd&#27604;&#36739;&#23569;&#30340;Poller&#26469;&#32465;&#23450;</span>
    <span class="org-type">int</span> <span class="org-variable-name">x1</span>=AtomicGetValue(s_Jobs[0].count), <span class="org-variable-name">m</span>=0, <span class="org-variable-name">n</span>;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span>=1; i&lt;m_ThreadPool.GetWorkerCount(); i++) {
        n = AtomicGetValue(s_Jobs[i].count);
        <span class="org-keyword">if</span> (n &lt; x1) {
            x1 = n;
            m = i;
        }
    }
    <span class="org-comment-delimiter">//</span><span class="org-comment">int m = atomic_add(&amp;n, 1) % m_ThreadPool.GetWorkerCount();</span>
    pCtx-&gt;pPoller = &amp;s_Jobs[m].poller;
    atomic_add(&amp;s_Jobs[m].count, 1);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36873;&#25321;&#22909;&#36825;&#20010;Poller&#20043;&#21518;&#65292;&#28982;&#21518;&#35843;&#29992;Poller-&gt;Associate&#21644;&#36825;&#20010;NetContext&#36827;&#34892;&#20851;&#32852;</span>
    m_NetContexts.push_back(pCtx);
    <span class="org-keyword">if</span> (APFE_OK != (err=pCtx-&gt;pPoller-&gt;Associate(pCtx))) {
        m_NetContexts.remove(pCtx);
    }
    <span class="org-keyword">return</span> err;
}

<span class="org-type">APF_ERROR</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Deassociate</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>;
    <span class="org-type">MyJob</span>* <span class="org-variable-name">pJob</span>;

    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != pCtx-&gt;pPoller) {
        <span class="org-keyword">if</span> (APFE_OK == (err=pCtx-&gt;pPoller-&gt;Deassociate(pCtx))) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35299;&#38500;&#20851;&#32852;</span>
            m_NetContexts.remove(pCtx);
            pJob = CONTAINING_RECORD(pCtx-&gt;pPoller, MyJob, poller);
            atomic_add(&amp;pJob-&gt;count, -1);
        }
        <span class="org-keyword">return</span> err;
    }
    m_NetContexts.remove(pCtx);
    <span class="org-keyword">return</span> APFE_OK;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-4" class="outline-4">
<h4 id="sec-2-8-4"><span class="section-number-4">2.8.4</span> Listen</h4>
<div class="outline-text-4" id="text-2-8-4">
<p>
发起Listen操作
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Listen</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">int</span> <span class="org-variable-name">backlog</span>)
{
    pCtx-&gt;backlog = backlog;
    pCtx-&gt;pClient-&gt;AddRef(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;AddRef&#20102;</span>
    pCtx-&gt;state = SS_LISTENING_0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#29366;&#24577;</span>
    Associate(pCtx);
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: error with Associate</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-5" class="outline-4">
<h4 id="sec-2-8-5"><span class="section-number-4">2.8.5</span> Connect</h4>
<div class="outline-text-4" id="text-2-8-5">
<p>
发起Connect操作，注意这里还填写了WriteReq,timeout以及nAction=AA_CONNECT.对于pReq的话应该是在connect之后发起的写操作。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Connect</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>,
                          <span class="org-type">void</span> *<span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">uint32</span> <span class="org-variable-name">timeout</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    ASSERT(<span class="org-constant">NULL</span> != pReq);

    pCtx-&gt;ip = ip;
    pCtx-&gt;port = port;

    pReq-&gt;async.nAction = AA_CONNECT;
    pReq-&gt;pHdl = <span class="org-constant">NULL</span>;
    pReq-&gt;buf = pBuf;
    pReq-&gt;request = count;
    pReq-&gt;xfered = 0;
    pCtx-&gt;pWriteReq = pReq;
    pCtx-&gt;nTimeout = timeout;

    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;state = SS_CONNECTING_0;
    Associate(pCtx);
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: error with Associate</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-6" class="outline-4">
<h4 id="sec-2-8-6"><span class="section-number-4">2.8.6</span> Monitor</h4>
<div class="outline-text-4" id="text-2-8-6">
<p>
发起Monitor操作。所谓Monitor操作的话是指创建Socket成功之后的操作。代码这里的意图是创建服务端的Socket成功之后准备监听的状态。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Monitor</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;state = SS_CONNECTED_0;
    Associate(pCtx);
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: error with Associate</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-7" class="outline-4">
<h4 id="sec-2-8-7"><span class="section-number-4">2.8.7</span> Delay</h4>
<div class="outline-text-4" id="text-2-8-7">
<p>
发起一个读超时的操作
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Delay</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>)
{
    <span class="org-type">bool</span> <span class="org-variable-name">bRet</span> = <span class="org-constant">false</span>;
    <span class="org-type">int</span> <span class="org-variable-name">bDelay</span> = AtomicSetValue(pCtx-&gt;nDelayRead, 1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#33021;&#22815;&#37325;&#22797;&#21457;&#36215;</span>
    <span class="org-keyword">if</span> (0 == bDelay) {
        pCtx-&gt;pClient-&gt;AddRef();
        pCtx-&gt;pPoller-&gt;Delay(pCtx, nMilliseconds);
        bRet = <span class="org-constant">true</span>;
    }
    <span class="org-keyword">return</span> bRet;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-8" class="outline-4">
<h4 id="sec-2-8-8"><span class="section-number-4">2.8.8</span> Read &amp; Write</h4>
<div class="outline-text-4" id="text-2-8-8">
<p>
Read/Write过程非常简单，就是将Request封装好之后交给EPoller来处理。所以这里可以知道大部分的事情都是在Poller里面完成的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Read</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    pReq-&gt;xfered = 0;
    pCtx-&gt;pPoller-&gt;Read(pCtx, pReq);
}
<span class="org-type">void</span> <span class="org-constant">CNetworkMan</span>::<span class="org-function-name">Write</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    pReq-&gt;xfered = 0;
    pCtx-&gt;pPoller-&gt;Write(pCtx, pReq);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8-9" class="outline-4">
<h4 id="sec-2-8-9"><span class="section-number-4">2.8.9</span> SocketState</h4>
<div class="outline-text-4" id="text-2-8-9">
<ul class="org-ul">
<li>SS_VOID = 0, // 初始状态
</li>
<li>SS_LISTENING_0,  // 发起listen操作
</li>
<li>SS_LISTENING, // 执行listen之后
</li>
<li>SS_CONNECTING_0, // 发起connect操作
</li>
<li>SS_CONNECTING, // 执行connect之后,下一步是SS_CONNECTED,但是下次发起write操作
</li>
<li>SS_CONNECTED_0, // 启动monitor操作,下一步是SS_CONNECTED,但是下次发起read操作
</li>
<li>SS_CONNECTED, // 连接建立成功
</li>
<li>SS_ERROR, // socket错误
</li>
<li>SS_SHUTDOWN, // 对端已经关闭
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> EPoller</h3>
<div class="outline-text-3" id="text-2-9">
</div><div id="outline-container-sec-2-9-1" class="outline-4">
<h4 id="sec-2-9-1"><span class="section-number-4">2.9.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
对于EPoller来说的话里面每个接口似乎都很重要，所以有必要对每一个接口都进行分析。首先看看EPoller的完整接口
</p>
<div class="org-src-container">

<pre class="src src-C+">class CEPoller
{
    int m_fd; // epoll fd
    uint64 m_nRead, m_nWrite; // 读写字节数统计
    typedef TMultiMap&lt;uint64, NetContext&gt; DelayedList;
    DelayedList m_DelayedList; // 定时列表
    CSpinLock m_DListLock;  // 定时列表锁

    bool StartWrite(NetContext* pCtx, bool bForce);
    bool StartRead(NetContext* pCtx, bool bUser);
    void DoWithDelayed();
    bool DoConnect(NetContext* pCtx);

  public:
    CEPoller() { m_fd = 0; m_nRead = m_nWrite = 0; }
    ~CEPoller() { Close(); }

    APF_ERROR Create(int size);
    void Close();

    APF_ERROR Associate(NetContext* pCtx);
    APF_ERROR Deassociate(NetContext* pCtx);
    APF_ERROR Run();

    bool CancelDelay(NetContext* pCtx);
    void Delay(NetContext* pCtx, uint32 nMilliseconds);
    void Read(NetContext* pCtx, NetRequest* pReq);
    void Write(NetContext* pCtx, NetRequest* pReq);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9-2" class="outline-4">
<h4 id="sec-2-9-2"><span class="section-number-4">2.9.2</span> Create &amp; Close</h4>
<div class="outline-text-4" id="text-2-9-2">
<p>
Create和Close无非就是创建epoll fd
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Create</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>)
{
    m_fd = sys_epoll_create(size);
    <span class="org-keyword">if</span> (0 &lt; m_fd)
        <span class="org-keyword">return</span> APFE_OK;
    PERROR(<span class="org-string">"epoll_create"</span>);
    <span class="org-keyword">return</span> GetLastError();
}

<span class="org-type">void</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Close</span>()
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO::: cancel epoll_waiting...</span>
    <span class="org-keyword">if</span> (m_fd) {
        close(m_fd);
        m_fd = 0;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9-3" class="outline-4">
<h4 id="sec-2-9-3"><span class="section-number-4">2.9.3</span> Associate &amp; Deassociate</h4>
<div class="outline-text-4" id="text-2-9-3">
<p>
将NetContext的fd放入epoll中进行关联.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Associate</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">epoll_event</span> <span class="org-variable-name">ev</span>;
    ASSERT(pCtx-&gt;state &gt; SS_VOID);

    SetNonBlock(pCtx-&gt;s); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#35774;&#32622;&#25104;&#20026;&#38750;&#38459;&#22622;&#27169;&#24335;</span>
    ev.events = EPOLLIN | EPOLLOUT | EPOLLERR | EPOLLET;
    ev.data.ptr = pCtx;

    <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE0("before CEPoller::Associate\n");</span>
    pCtx-&gt;pClient-&gt;AddRef(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;AddRef</span>
    TRACE1(<span class="org-string">"Associate %x -&gt; %s\n"</span>, pCtx-&gt;s, pCtx-&gt;pClient-&gt;GetName());
    <span class="org-keyword">if</span> (0 == sys_epoll_ctl(m_fd, EPOLL_CTL_ADD, pCtx-&gt;s, &amp;ev)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21152;&#20837;&#21040;epoll&#37324;&#38754;</span>
        <span class="org-keyword">return</span> APFE_OK;
    }
    PERROR(<span class="org-string">"epoll_ctl in Associate"</span>);
    pCtx-&gt;pClient-&gt;Release();
    <span class="org-keyword">return</span> GetLastError();
}

<span class="org-type">APF_ERROR</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Deassociate</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-keyword">if</span> (pCtx-&gt;s != INVALID_SOCKET) {
        <span class="org-keyword">if</span> (0 == sys_epoll_ctl(m_fd, EPOLL_CTL_DEL, pCtx-&gt;s, <span class="org-constant">NULL</span>)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;epoll&#21024;&#38500;</span>
            TRACE1(<span class="org-string">"Deassociate %x\n"</span>, pCtx-&gt;s);
            pCtx-&gt;s = INVALID_SOCKET;
            <span class="org-keyword">return</span> APFE_OK;
        }
        <span class="org-keyword">return</span> GetLastError();
    }
    <span class="org-keyword">return</span> APFE_ALREADY_FREED;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9-4" class="outline-4">
<h4 id="sec-2-9-4"><span class="section-number-4">2.9.4</span> DoConnect</h4>
<div class="outline-text-4" id="text-2-9-4">
<p>
DoConnect是真实地进行connect操作
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">DoConnect</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-type">SOCKADDR_IN</span> <span class="org-variable-name">sa</span>;
    ZeroMemory(&amp;sa, <span class="org-keyword">sizeof</span>(SOCKADDR_IN));
    sa.sin_port = htons(pCtx-&gt;port);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = pCtx-&gt;ip;

    AtomicSetValue(pCtx-&gt;state, SS_CONNECTING);
    pCtx-&gt;tTimeoutCycle = 0;

    <span class="org-type">int</span> <span class="org-variable-name">err</span> = connect(pCtx-&gt;s, (LPSOCKADDR)&amp;sa, <span class="org-keyword">sizeof</span>(sa));
    <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE0("connect = %d, %d, %s\n", err, errno, strerror(errno));</span>
    <span class="org-keyword">if</span> (EINPROGRESS == errno) {
        <span class="org-keyword">if</span> (INFINITE != pCtx-&gt;nTimeout) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#38656;&#35201;&#35774;&#32622;&#36229;&#26102;&#30340;&#35805;</span>
            Delay(pCtx, pCtx-&gt;nTimeout); <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#20250;&#21457;&#36215;&#19968;&#20010;&#36229;&#26102;&#25805;&#20316;</span>
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
    <span class="org-keyword">return</span> 0 == err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9-5" class="outline-4">
<h4 id="sec-2-9-5"><span class="section-number-4">2.9.5</span> Delay &amp; CancalDelay</h4>
<div class="outline-text-4" id="text-2-9-5">
<p>
Delay操作无非就是将超时事件到DelayedList里面，而CancalDelay是将对应的超时事件从DelayedList里面删除。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Delay</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>)
{
    <span class="org-type">uint64</span> <span class="org-variable-name">nCycle</span> = rdtsc();
    nCycle += (GetCpuFreq() * nMilliseconds) / 1000;

    m_DListLock.Lock();
    m_DelayedList.insert(nCycle, pCtx);
    m_DListLock.Unlock();

    pCtx-&gt;tTimeoutCycle = nCycle; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36716;&#25442;&#25104;&#20026;&#32477;&#23545;&#36229;&#26102;&#26102;&#38388;&#65292;&#21333;&#20301;&#26159;cycle.</span>
}

<span class="org-type">bool</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">CancelDelay</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>)
{
    <span class="org-type">bool</span> <span class="org-variable-name">bRet</span> = <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (0 != pCtx-&gt;tTimeoutCycle) {
        m_DListLock.Lock();
        bRet = m_DelayedList.remove(pCtx-&gt;tTimeoutCycle, pCtx);
        m_DListLock.Unlock();
    }
    <span class="org-keyword">return</span> bRet;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9-6" class="outline-4">
<h4 id="sec-2-9-6"><span class="section-number-4">2.9.6</span> DoWithDelayed &amp; DoWithError</h4>
<div class="outline-text-4" id="text-2-9-6">
<p>
#todo: 这两个部分都非常杂并且细节很多，没有完全看懂。另外一个疑问就是对于Delay这种超时事件的话为什么不放在CPU的超时时间里面去完成。这样似乎会更加优雅。
而现在的情况就是NetworkMan里面管理了一个定时器，而CPU线程也有一个定时器，而从代码编写者的demo来没有使用过networkman定时器。
</p>
</div>
</div>

<div id="outline-container-sec-2-9-7" class="outline-4">
<h4 id="sec-2-9-7"><span class="section-number-4">2.9.7</span> Read &amp; Write</h4>
<div class="outline-text-4" id="text-2-9-7">
<p>
发起Read/Write最后都是调用StartRead/StartWrite
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Read</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    pReq-&gt;async.nAction = AA_READ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;&#30340;Action&#26159;AA_READ</span>
    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;qRead.push_back(pReq); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25918;&#20837;read request queue.</span>
    StartRead(pCtx, <span class="org-constant">true</span>);
}

<span class="org-type">void</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Write</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    pReq-&gt;async.nAction = AA_WRITE; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;&#30340;Action&#26159;AA_WRITE</span>
    pCtx-&gt;pClient-&gt;AddRef();
    pCtx-&gt;qWrite.push_back(pReq); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25918;&#20837;write request queue.</span>
    StartWrite(pCtx, <span class="org-constant">true</span>);
}
</pre>
</div>

<p>
首先我们看看StartRead这个过程。这里所谓的StartRead不过就是尝试阅读访问一下Context看看是否可以读出数据。调用的时机一个是刚发起Read一个是EPoller::Run里面。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">StartRead</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">bool</span> <span class="org-variable-name">bUser</span>)
{
    <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>;
    <span class="org-type">int</span> <span class="org-variable-name">t</span>, <span class="org-variable-name">n</span>;

    <span class="org-keyword">while</span> (0 == (t=pCtx-&gt;tRead.Add())) { <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#36825;&#20010;&#22320;&#26041;&#23436;&#20840;&#27809;&#26377;&#30475;&#25026;</span>
        <span class="org-keyword">if</span> (SS_CONNECTED != AtomicGetValue(pCtx-&gt;state)) {
            TRACE1(<span class="org-string">"Not read due to state=%s\n"</span>, State2Str(pCtx-&gt;state));
            <span class="org-keyword">if</span> (1 == pCtx-&gt;tRead.Set(0)) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
            <span class="org-keyword">continue</span>;
        }
        <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == pCtx-&gt;pReadReq) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24471;&#21040;&#31532;&#19968;&#20010;ReadRequest.</span>
            pCtx-&gt;pReadReq = pCtx-&gt;qRead.pop_front();
        }
        <span class="org-keyword">while</span> (pCtx-&gt;pReadReq) {
            pReq = pCtx-&gt;pReadReq;
            ASSERT(pReq-&gt;len &gt; pReq-&gt;xfered);
            <span class="org-keyword">if</span> (0 == (pCtx-&gt;flag &amp; SF_UDP)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;TCP&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#20351;&#29992;recv&#35835;&#21462;</span>
                n = recv(pCtx-&gt;s, (<span class="org-type">char</span>*)pReq-&gt;buf+pReq-&gt;xfered, pReq-&gt;len-pReq-&gt;xfered, 0);
                <span class="org-keyword">if</span> (AtomicGetValue(g_nQuickAckMode)) {
                    SetQuickAck(pCtx-&gt;s);
                }
            }
            <span class="org-keyword">else</span> {
                <span class="org-type">SOCKADDR_IN</span> <span class="org-variable-name">sa</span>;
                <span class="org-type">socklen_t</span> <span class="org-variable-name">len</span> = <span class="org-keyword">sizeof</span>(sa);
                n = recvfrom(pCtx-&gt;s, (<span class="org-type">char</span>*)pReq-&gt;buf+pReq-&gt;xfered, pReq-&gt;len-pReq-&gt;xfered, 0, (LPSOCKADDR)&amp;sa, &amp;len);
                pReq-&gt;port = ntohs(sa.sin_port);
                pReq-&gt;ip = sa.sin_addr.s_addr;
            }
            <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE5("recv(%x, %p, %d): %d, %d(%s)\n", pCtx-&gt;s, (char*)pReq-&gt;buf+pReq-&gt;xfered,</span>
            <span class="org-comment-delimiter">//      </span><span class="org-comment">pReq-&gt;len-pReq-&gt;xfered, n, errno, strerror(errno));</span>
            <span class="org-keyword">if</span> (0&gt;n &amp;&amp; EAGAIN==errno) {
                pCtx-&gt;tRead.Set(0);
                <span class="org-keyword">return</span> <span class="org-constant">true</span>;
            }
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> (0 &lt; n) {
                m_nRead += n;
                pReq-&gt;xfered += n;
                <span class="org-keyword">if</span> (pReq-&gt;xfered &gt;= pReq-&gt;request) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;xfered&#36229;&#36807;request&#30340;&#35805;&#65292;&#37027;&#20040;&#24819;&#19978;&#36827;&#34892;&#36890;&#30693;</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#38656;&#35201;&#27880;&#24847;&#30340;&#23601;&#26159;&#65292;&#25152;&#35859;&#30340;xfered&#21487;&#33021;&#20250;&#36229;&#36807;request,&#21482;&#35201;buffer&#30340;&#31354;&#38388;&#23481;&#35768;</span>
                    pCtx-&gt;pReadReq = <span class="org-constant">NULL</span>;
                    NotifyClient(0, pCtx, pReq);
                    pCtx-&gt;pReadReq = pCtx-&gt;qRead.pop_front();
                }
                g_pExecMan-&gt;RunTimer(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#35843;&#29992;RunTimer&#26469;&#26816;&#26597;&#36229;&#26102;&#24773;&#20917;</span>
            }
            <span class="org-keyword">else</span> {
                TRACE3(<span class="org-string">"Error in recv(%x, %d): %d, %d(%s)\n"</span>, pCtx-&gt;s, pReq-&gt;len-pReq-&gt;xfered,
                       n, errno, strerror(errno));
                AtomicSetValueIf(pCtx-&gt;state, SS_SHUTDOWN, SS_CONNECTED);
                shutdown(pCtx-&gt;s, SHUT_RDWR);
                pCtx-&gt;tRead.Set(0);
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
        <span class="org-keyword">if</span> (1 == (t=pCtx-&gt;tRead.Set(0))) {
            <span class="org-keyword">return</span> SS_CONNECTED == AtomicGetValue(pCtx-&gt;state); <span class="org-comment-delimiter">// </span><span class="org-comment">app may have called shutdown...</span>
        }
    }
    <span class="org-keyword">if</span> (0 &lt; t)
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    ASSERT(bUser);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">the last one in pCtx-&gt;qRead should be what we just inserted, unless</span>
<span class="org-comment">     * 1. there is concurrent read in other threads; or</span>
<span class="org-comment">     * 2. it has been notified in the failure handler of CSocketV.</span>
<span class="org-comment">     */</span>
    pReq = pCtx-&gt;qRead.pop_back();
    <span class="org-keyword">if</span> (pReq) { <span class="org-comment-delimiter">// </span><span class="org-comment">todo:???</span>
        NotifyClient(APFE_AFTER_BROKEN, pCtx, pReq);
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>

<p>
StartWrite这个过程也是非常相似的，不过为了方便起见的话每个Write操作都是使用BufHandle来管理的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">StartWrite</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">bool</span> <span class="org-variable-name">bUser</span>)
{
    <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>;
    <span class="org-type">int</span> <span class="org-variable-name">t</span>, <span class="org-variable-name">n</span>;

    <span class="org-keyword">while</span> (0 == (t=pCtx-&gt;tWrite.Add())) { <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#23436;&#20840;&#27809;&#26377;&#30475;&#25026;</span>
        <span class="org-keyword">if</span> (SS_CONNECTED != AtomicGetValue(pCtx-&gt;state)) {
            TRACE1(<span class="org-string">"Not write due to state=%s\n"</span>, State2Str(pCtx-&gt;state));
            <span class="org-comment-delimiter">/*</span><span class="org-comment">if (SS_ERROR == pCtx-&gt;state) {</span>
<span class="org-comment">                NetRequest* pReq;</span>
<span class="org-comment">                if (NULL != pCtx-&gt;pWriteReq) {</span>
<span class="org-comment">                    pReq = pCtx-&gt;pWriteReq;</span>
<span class="org-comment">                    pCtx-&gt;pWriteReq = NULL;</span>
<span class="org-comment">                    NotifyClient(APFE_NET_ERROR, pCtx, pReq);</span>
<span class="org-comment">                }</span>
<span class="org-comment">                for (pReq=pCtx-&gt;qWrite.pop_front(); pReq; pReq=pCtx-&gt;qWrite.pop_front()) {</span>
<span class="org-comment">                    NotifyClient(APFE_NET_ERROR, pCtx, pReq);</span>
<span class="org-comment">                }</span>
<span class="org-comment">            }*/</span>
            <span class="org-keyword">if</span> (1 == pCtx-&gt;tWrite.Set(0)) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
            <span class="org-keyword">continue</span>;
        }
        n = 0;
        <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != (pHdl=NotifyAndNextWrite(pCtx, n))) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#27425;&#21462;&#20986;&#19968;&#20010;&#21512;&#36866;&#30340;BufHandle&#20986;&#26469;&#29992;&#20110;&#20889;,&#22914;&#26524;&#24050;&#32463;&#20889;&#23436;&#25104;&#30340;&#35805;&#20250;&#22312;&#37324;&#38754;&#36827;&#34892;&#36890;&#30693;</span>
            ASSERT(0 != pHdl-&gt;nDataLen);
            <span class="org-keyword">if</span> (0 == (pCtx-&gt;flag &amp; SF_UDP)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;tcp&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;send</span>
                n = send(pCtx-&gt;s, pHdl-&gt;pBuf, pHdl-&gt;nDataLen, 0);
            }
            <span class="org-keyword">else</span> {
                <span class="org-type">SOCKADDR_IN</span> <span class="org-variable-name">sa</span>;
                ZeroMemory(&amp;sa, <span class="org-keyword">sizeof</span>(SOCKADDR_IN));
                sa.sin_port = htons(pCtx-&gt;pWriteReq-&gt;port);
                sa.sin_family = AF_INET;
                sa.sin_addr.s_addr = pCtx-&gt;pWriteReq-&gt;ip;
                n = sendto(pCtx-&gt;s, pHdl-&gt;pBuf, pHdl-&gt;nDataLen, 0, (LPSOCKADDR)&amp;sa, <span class="org-keyword">sizeof</span>(sa));
            }
            <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE5("send(%x, %d): %d, %d(%s)\n", pCtx-&gt;s, pHdl-&gt;nDataLen, n, errno, strerror(errno));</span>
            <span class="org-keyword">if</span> (0 &lt; n) {
                pHdl-&gt;nDataLen -= n;
                ASSERT(pHdl-&gt;nDataLen &gt;= 0);
                ASSERT(<span class="org-constant">NULL</span> != pCtx-&gt;pWriteReq);
                pCtx-&gt;pWriteReq-&gt;xfered += n;
                m_nWrite += n;
                g_pExecMan-&gt;RunTimer();
            }
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> (EAGAIN == errno) {
                pCtx-&gt;tWrite.Set(0);
                <span class="org-keyword">return</span> <span class="org-constant">true</span>;
            }
            <span class="org-keyword">else</span> {
                TRACE2(<span class="org-string">"Error in send(%x, %p, %d): %d, %d(%s), %s\n"</span>, pCtx-&gt;s, pHdl-&gt;pBuf,
                    pHdl-&gt;nDataLen, n, errno, strerror(errno), State2Str(pCtx-&gt;state));
                AtomicSetValueIf(pCtx-&gt;state, SS_SHUTDOWN, SS_CONNECTED);
                shutdown(pCtx-&gt;s, SHUT_RDWR);
                pCtx-&gt;tWrite.Set(0);
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
        <span class="org-keyword">if</span> (1 == (t=pCtx-&gt;tWrite.Set(0))) {
            <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }
    }
    <span class="org-keyword">if</span> (0 &lt; t)
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    ASSERT(bUser);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">the last one in pCtx-&gt;qWrite should be what we just inserted, unless</span>
<span class="org-comment">     * 1. there is concurrent write in other threads; or</span>
<span class="org-comment">     * 2. it has been notified in the failure handler of CSocketV.</span>
<span class="org-comment">     */</span>
    <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span> = pCtx-&gt;qWrite.pop_back();
    <span class="org-keyword">if</span> (pReq) { <span class="org-comment-delimiter">// </span><span class="org-comment">todo:???</span>
        NotifyClient(APFE_AFTER_BROKEN, pCtx, pReq);
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
<p>
这里面最主要的过程无非就是NotifyAndNextWrite.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">BufHandle</span>*
<span class="org-function-name">NotifyAndNextWrite</span>(<span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">int</span> <span class="org-variable-name">nWritten</span>)
{
    <span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span> = &amp;pCtx-&gt;wHdl;
    <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>;

    <span class="org-keyword">if</span> (0 == pHdl-&gt;nDataLen) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24403;&#21069;&#30340;DataLen==0&#30340;&#35805;&#37027;&#20040;&#23601;&#38656;&#35201;&#25361;&#36873;&#19979;&#19968;&#20010;BufHandle&#20102;&#12290;</span>
        <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != (pHdl=pHdl-&gt;_next)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;BufHandle&#38142;&#34920;&#30830;&#35748;&#20840;&#37096;&#20889;&#23436;</span>
            pCtx-&gt;wHdl._next = pHdl-&gt;_next;
            pCtx-&gt;wHdl.pBuf = pHdl-&gt;pBuf;
            pCtx-&gt;wHdl.nDataLen = pHdl-&gt;nDataLen;
            ASSERT(pHdl-&gt;nDataLen != 0);
            <span class="org-keyword">return</span> &amp;pCtx-&gt;wHdl;
        }

        <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != pCtx-&gt;pWriteReq) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#30340;Request&#24050;&#32463;&#20889;&#23436;&#65292;&#37027;&#20040;&#38656;&#35201;&#19968;&#27425;&#36890;&#30693;</span>
            ASSERT(0 != nWritten);
            pReq = pCtx-&gt;pWriteReq;
            pCtx-&gt;pWriteReq = <span class="org-constant">NULL</span>;
            NotifyClient(0, pCtx, pReq);
        }
        <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != (pCtx-&gt;pWriteReq=pCtx-&gt;qWrite.pop_front())) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25361;&#36873;&#20986;&#19979;&#19968;&#20010;Request.</span>
            pHdl = &amp;pCtx-&gt;pWriteReq-&gt;hdl;
            <span class="org-keyword">while</span> (pHdl &amp;&amp; 0==pHdl-&gt;nDataLen) {
                pHdl = pHdl-&gt;_next;
            }
            <span class="org-keyword">if</span> (pHdl) {
                pCtx-&gt;wHdl._next = pHdl-&gt;_next;
                pCtx-&gt;wHdl.pBuf = pHdl-&gt;pBuf;
                pCtx-&gt;wHdl.nDataLen = pHdl-&gt;nDataLen;
                <span class="org-keyword">return</span> &amp;pCtx-&gt;wHdl;
            }
            pReq = pCtx-&gt;pWriteReq;
            pCtx-&gt;pWriteReq = <span class="org-constant">NULL</span>;
            NotifyClient(0, pCtx, pReq); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25152;&#26377;&#30340;BufHandle&#20026;NULL&#30340;&#35805;&#65292;&#37027;&#20040;&#20063;&#30452;&#25509;&#36890;&#30693;&#20889;&#23436;</span>
        }
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
    pHdl-&gt;pBuf += nWritten; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24403;&#21069;BufHandle&#27809;&#26377;&#25630;&#23450;&#30340;&#35805;&#65292;&#37027;&#20040;&#20462;&#25913;&#19968;&#19979;&#19979;&#19968;&#27425;&#20889;&#20559;&#31227;.</span>
    <span class="org-keyword">return</span> pHdl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9-8" class="outline-4">
<h4 id="sec-2-9-8"><span class="section-number-4">2.9.8</span> NofityClient</h4>
<div class="outline-text-4" id="text-2-9-8">
<p>
当EPoller发现内部需要进行回调的话，那么就会通过NofityClient来通知客户进行回调。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span>
<span class="org-function-name">NotifyClient</span>(<span class="org-type">int</span> <span class="org-variable-name">nErrCode</span>, <span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    <span class="org-type">CAsyncClient</span>* <span class="org-variable-name">pClient</span> = pCtx-&gt;pClient;

    pReq-&gt;async.nErrCode = nErrCode;
    pReq-&gt;async.pClient = pClient;
    <span class="org-comment-delimiter">//</span><span class="org-comment">int nAction = pReq-&gt;async.nAction;</span>

    TRACE5(<span class="org-string">"Notify client (%p,%d) %d, %d, %p, %p\n"</span>, pClient, pClient-&gt;GetRef(), pReq-&gt;async.nAction, nErrCode, pCtx, pReq);
    <span class="org-keyword">if</span> (0 != (pCtx-&gt;flag &amp; SF_DIRECT_CALLBACK)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;flag&#37324;&#38754;&#26377;SF_DIRECT_CALLBACK,&#37027;&#20040;&#22312;&#26412;&#32447;&#31243;&#25191;&#34892;</span>
        pClient-&gt;OnCompletion((<span class="org-type">AsyncContext</span>*)pReq);
        pClient-&gt;Release();
    }
    <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#21152;&#20837;CPU&#32447;&#31243;&#25191;&#34892;</span>
        g_pExecMan-&gt;QueueExec((<span class="org-type">AsyncContext</span>*)pReq, <span class="org-constant">true</span>);
    }
    <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE0("After EPoll::NotifyClient: %d\n", nAction);</span>
}
</pre>
</div>
<p>
这是NotifyClient的一个版本，另外一个版本的原型是这样的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">NotifyClient</span>(<span class="org-type">int</span> <span class="org-variable-name">nErrCode</span>, <span class="org-type">int</span> <span class="org-variable-name">nAction</span>, <span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>);
</pre>
</div>
<p>
可以看到这个地方没有和任何的NetRequest进行关联，所以在内部实现的话会直接new一个出来，用户在处理这个逻辑时候需要记得释放。
</p>
</div>
</div>

<div id="outline-container-sec-2-9-9" class="outline-4">
<h4 id="sec-2-9-9"><span class="section-number-4">2.9.9</span> Run</h4>
<div class="outline-text-4" id="text-2-9-9">
<p>
过程比较冗长，而且里面很多细节依然并不是非常清楚，但是不妨碍大体的理解
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CEPoller</span>::<span class="org-function-name">Run</span>()
{
    <span class="org-type">NetContext</span>* <span class="org-variable-name">pCtx</span>;
    <span class="org-type">NetRequest</span> *<span class="org-variable-name">pReq</span>;
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MAX_EPOLL_EVENT</span>     64
    <span class="org-keyword">struct</span> <span class="org-type">epoll_event</span> <span class="org-variable-name">events</span>[MAX_EPOLL_EVENT];
    <span class="org-type">int</span> <span class="org-variable-name">nfds</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">bRead</span>, <span class="org-variable-name">bWrite</span>, <span class="org-variable-name">bErr</span>;

    <span class="org-keyword">while</span> (1) {
        TRACE7(<span class="org-string">"epoll_wait start\n"</span>);
        nfds = sys_epoll_wait(m_fd, events, MAX_EPOLL_EVENT, g_nTickPrecision); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36827;&#34892;epoll_wait</span>
        TRACE7(<span class="org-string">"epoll_wait return: nfds=%d\n"</span>, nfds);
        <span class="org-keyword">if</span> (nfds &gt;= 0) {
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span>=0; i&lt;nfds; i++) {
                pCtx = (<span class="org-type">NetContext</span>*)events[i].data.ptr;
                ASSERT(pCtx &amp;&amp; pCtx-&gt;pClient);
                <span class="org-keyword">if</span> (0 == pCtx-&gt;nEnabled) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#21487;&#29992;&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;</span>
                    <span class="org-keyword">continue</span>;
                }
                bRead = (events[i].events &amp; EPOLLIN) ? <span class="org-constant">true</span> : <span class="org-constant">false</span>;
                bWrite = (events[i].events &amp; EPOLLOUT) ? <span class="org-constant">true</span> : <span class="org-constant">false</span>;
                bErr = (events[i].events &amp; EPOLLERR) ? <span class="org-constant">true</span> : <span class="org-constant">false</span>;

<span class="org-preprocessor">#ifdef</span>  _DEBUG
                <span class="org-keyword">if</span> (0 != bErr) {
                    TRACE4(<span class="org-string">"EPOLLERR: %x(%p), state=%s\n"</span>, pCtx-&gt;s, pCtx, State2Str(pCtx-&gt;state));
                }
                <span class="org-keyword">if</span> (bRead) {
                    TRACE7(<span class="org-string">"EPOLLIN: %x(%p), state=%s\n"</span>, pCtx-&gt;s, pCtx, State2Str(pCtx-&gt;state));
                }
                <span class="org-keyword">if</span> (bWrite) {
                    TRACE7(<span class="org-string">"EPOLLOUT: %x(%p), state=%s\n"</span>, pCtx-&gt;s, pCtx, State2Str(pCtx-&gt;state));
                }
<span class="org-preprocessor">#endif</span>
                <span class="org-keyword">switch</span> (AtomicGetValue(pCtx-&gt;state)) {
                <span class="org-keyword">case</span> SS_CONNECTED_0:            <span class="org-comment-delimiter">// </span><span class="org-comment">support for Monitor</span>
                    AtomicSetValue(pCtx-&gt;state, SS_CONNECTED);
                    NotifyClient(APFE_NOTIFY, AA_READ, pCtx);
                    <span class="org-comment-delimiter">// </span><span class="org-comment">no break</span>
                <span class="org-keyword">case</span> SS_CONNECTED: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24050;&#32463;&#36830;&#25509;&#19978;&#30340;&#35805;</span>
                    <span class="org-keyword">if</span> (bRead) {
                        <span class="org-keyword">while</span> (pCtx-&gt;tRead.Get() &gt; 0) {
                            thread_yield();
                        }
                        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>StartRead(pCtx, <span class="org-constant">false</span>)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;Read&#25805;&#20316;</span>
                            DoWithError(pCtx);
                            <span class="org-keyword">break</span>;
                        }
                    }

                    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bErr) {
                        <span class="org-keyword">if</span> (bWrite) {
                            <span class="org-keyword">while</span> (pCtx-&gt;tWrite.Get() &gt; 0) {
                                thread_yield();
                            }
                            <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>StartWrite(pCtx, <span class="org-constant">false</span>)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;Write&#25805;&#20316;</span>
                                DoWithError(pCtx);
                                <span class="org-keyword">break</span>;
                            }
                        }
                    }
                    <span class="org-keyword">else</span> {
                        <span class="org-type">int</span> <span class="org-variable-name">bytes</span> = 0;
                        <span class="org-keyword">if</span> (0 == (pCtx-&gt;flag &amp; SF_DONT_EXHAUST)) {
                            ioctl(pCtx-&gt;s, FIONREAD, &amp;bytes);
                        }
                        <span class="org-keyword">if</span> (0 == bytes) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#22312;&#32531;&#23384;&#37324;&#38754;&#27809;&#26377;&#25968;&#25454;&#30340;&#35805;&#65292;&#21542;&#21017;&#20250;&#20808;&#35302;&#21457;READ&#20107;&#20214;</span>
                            AtomicSetValueIf(pCtx-&gt;state, SS_SHUTDOWN, SS_CONNECTED); <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#23558;&#29366;&#24577;&#32622;&#20026;Shutdown</span>
                            DoWithError(pCtx); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20132;&#32473;&#38169;&#35823;&#22788;&#29702;</span>
                        }
                    }
                    <span class="org-keyword">break</span>;

                <span class="org-keyword">case</span> SS_CONNECTING_0:
                    <span class="org-keyword">if</span> (DoConnect(pCtx)) <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36215;connect</span>
                        <span class="org-keyword">break</span>;
                    bErr = <span class="org-constant">true</span>;

                <span class="org-keyword">case</span> SS_CONNECTING:
                    CancelDelay(pCtx); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#27491;&#22312;&#36830;&#25509;&#30340;&#35805;&#37027;&#20040;&#21462;&#28040;ReConnect&#36229;&#26102;&#26102;&#38388;,Connect&#19978;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#31435;&#21051;&#35302;&#21457;&#20889;&#20107;&#20214;</span>
                    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bErr &amp;&amp; bWrite) {
                        pReq = pCtx-&gt;pWriteReq;
                        pCtx-&gt;pWriteReq = <span class="org-constant">NULL</span>;
                        ASSERT(pReq != pCtx-&gt;qWrite.get_front());

                        <span class="org-keyword">if</span> (0==pReq-&gt;request &amp;&amp; <span class="org-constant">NULL</span>==pReq-&gt;pHdl) {
                            AtomicSetValue(pCtx-&gt;state, SS_CONNECTED);
                            NotifyClient(0, pCtx, pReq); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#20889;&#35831;&#27714;&#30340;&#35805;&#37027;&#20040;&#35302;&#21457;&#22238;&#35843;</span>
                        }
                        <span class="org-keyword">else</span> {
                            pCtx-&gt;qWrite.push_front(pReq);
                            AtomicSetValue(pCtx-&gt;state, SS_CONNECTED);
                        }
                        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>StartWrite(pCtx, <span class="org-constant">false</span>)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26377;&#20889;&#35831;&#27714;&#37027;&#20040;&#31435;&#21051;&#36827;&#34892;Write</span>
                            DoWithError(pCtx);
                        }
                    }
                    <span class="org-keyword">else</span> <span class="org-keyword">if</span> (bErr) {
                        DoWithError(pCtx);
                    }
                    <span class="org-keyword">break</span>;

                <span class="org-keyword">case</span> SS_LISTENING_0:
                    DoListen(pCtx);
                    <span class="org-keyword">break</span>;

                <span class="org-keyword">case</span> SS_LISTENING:
                    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: how to deal with listen failure?</span>
                    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bErr &amp;&amp; bRead) {
                        pCtx-&gt;pClient-&gt;AddRef();
                        NotifyClient(APFE_OK, AA_LISTEN, pCtx); <span class="org-comment-delimiter">// </span><span class="org-comment">AA_LISTEN&#23436;&#27605;&#65292;&#37027;&#20040;&#30456;&#24403;&#20110;&#19979;&#19968;&#27493;&#25105;&#20204;&#38656;&#35201;&#36827;&#34892;accept.</span>
                    }
                    <span class="org-keyword">break</span>;

                <span class="org-keyword">case</span> SS_SHUTDOWN:
                    DoWithError(pCtx);
                    <span class="org-keyword">break</span>;

                <span class="org-keyword">default</span>:
                    <span class="org-keyword">break</span>;
                }
            }

            DoWithDelayed();
            g_pExecMan-&gt;RunTimer();
        }
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> (EINTR != GetLastError()) {
            <span class="org-keyword">if</span> (IsKylinRunning())
                PERROR(<span class="org-string">"Error in epoll_wait"</span>);
            <span class="org-keyword">return</span> GetLastError();
        }
    }
    <span class="org-keyword">return</span> APFE_OK;
}
</pre>
</div>
<p>
可以说看下来的话很多细节都是头昏脑胀的，以及各种情况返回什么样的错误码。估计只有写代码的人才知道里面为什么这么做，里面到底存在什么陷阱。
但是所幸的是写代码的人为我们提供了一个简单的接口可以使用，而且里面设置了很多默认的处理。大部分情况下面我们只需要使用默认处理即可，这个默认类就是Socket.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10"><span class="section-number-3">2.10</span> Socket</h3>
<div class="outline-text-3" id="text-2-10">
</div><div id="outline-container-sec-2-10-1" class="outline-4">
<h4 id="sec-2-10-1"><span class="section-number-4">2.10.1</span> Overview</h4>
<div class="outline-text-4" id="text-2-10-1">
<p>
Socket包含了如何配合使用NetworkMan以及EPoller两个部分，并且里面提供了很多默认的封装。对于我们编写程序的话大部分时候都使用这个类即可。还是首先看看接口
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">socket&#31867;&#22411;</span>
<span class="org-keyword">enum</span> <span class="org-type">SockType</span> {
    <span class="org-variable-name">ST_NONE</span> = 0,
    <span class="org-variable-name">ST_CREATED</span>,
    <span class="org-variable-name">ST_LISTEN</span>,
    <span class="org-variable-name">ST_CONNECTED</span>,
    <span class="org-variable-name">ST_ACCEPTED</span>,
    <span class="org-variable-name">ST_ERROR</span>
};

<span class="org-keyword">class</span> <span class="org-type">CSocketV</span> : <span class="org-keyword">public</span> <span class="org-type">CAsyncClient</span>
{
  <span class="org-keyword">protected</span>:
    <span class="org-type">SOCKET</span> <span class="org-variable-name">m_s</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">socket&#21477;&#26564;</span>
    <span class="org-type">uint16</span> <span class="org-variable-name">m_port</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24037;&#20316;&#22312;&#20160;&#20040;&#31471;&#21475;&#19978;&#65292;&#22914;&#26524;&#26159;connection&#30340;&#35805;&#34920;&#31034;&#23458;&#25143;&#31471;&#30340;&#31471;&#21475;</span>
    <span class="org-type">NetContext</span> <span class="org-variable-name">m_Ctx</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">context</span>
    <span class="org-type">NetRequest</span> <span class="org-variable-name">m_Req</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">request</span>
    <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">m_type</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">socket&#31867;&#22411;</span>
    <span class="org-type">AsyncContext</span>* <span class="org-variable-name">m_pConnCtx</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#20351;&#29992;</span>

    <span class="org-function-name">CSocketV</span>() {
        m_s = INVALID_SOCKET;
        m_port = 0;
        m_type = ST_NONE;
        m_pConnCtx = <span class="org-constant">NULL</span>;
        InitAsyncContext(&amp;m_Req.async);
    }
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">CSocketV</span>() {
        Close();
    }

    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pContext</span>);

    <span class="org-comment-delimiter">// </span><span class="org-comment">false means the connection is to be deleted</span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">OnConnected</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>) { <span class="org-keyword">return</span> 0==nErrCode; }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnListened</span>(<span class="org-type">SOCKET</span> <span class="org-variable-name">s</span>, <span class="org-type">SOCKADDR_IN</span>* <span class="org-variable-name">pSockAddrIn</span>) { closesocket(s); }

    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnWritten</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>) {}
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnRead</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>) {}

    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnBroken</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>) = 0;
    <span class="org-type">bool</span> <span class="org-function-name">Close</span>();

  <span class="org-keyword">public</span>:
    <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">Release</span>() {
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = <span class="org-constant">CAsyncClient</span>::Release();
        <span class="org-keyword">if</span> (n == 0) {
            <span class="org-keyword">delete</span> <span class="org-keyword">this</span>;
        }
        <span class="org-keyword">return</span> n;
    }
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Create</span>(<span class="org-type">bool</span> <span class="org-variable-name">bTCP</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>=0, <span class="org-type">uint32</span> <span class="org-variable-name">ip</span>=0, <span class="org-type">uint32</span> <span class="org-variable-name">flag</span>=0); <span class="org-comment-delimiter">// </span><span class="org-comment">Check SocketFlag in NetworkMan.h</span>
    <span class="org-type">APF_ERROR</span> <span class="org-function-name">Create</span>(<span class="org-type">SOCKET</span> <span class="org-variable-name">s</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">uint32</span> <span class="org-variable-name">flag</span>=0);

    <span class="org-type">void</span> <span class="org-function-name">Listen</span>(<span class="org-type">int</span> <span class="org-variable-name">backlog</span>=64);
    <span class="org-type">void</span> <span class="org-function-name">Connect</span>(<span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">uint32</span> <span class="org-variable-name">timeout</span>=INFINITE<span class="org-comment-delimiter">/*</span><span class="org-comment">in Milliseconds*/</span>);
    <span class="org-type">void</span> <span class="org-function-name">ConnectAndWrite</span>(<span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">uint32</span> <span class="org-variable-name">timeout</span>=INFINITE<span class="org-comment-delimiter">/*</span><span class="org-comment">in Milliseconds*/</span>);
    <span class="org-type">void</span> <span class="org-function-name">ReConnect</span>(<span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>);
    <span class="org-type">bool</span> <span class="org-function-name">Shutdown</span>(<span class="org-type">bool</span> <span class="org-variable-name">bLingerOff</span>=<span class="org-constant">true</span>);

    <span class="org-type">void</span> <span class="org-function-name">Read</span>(<span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">int</span> <span class="org-variable-name">request</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Read</span>(<span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Write</span>(<span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);
    <span class="org-type">void</span> <span class="org-function-name">Write</span>(<span class="org-type">BufHandle</span>* <span class="org-variable-name">pHdl</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>);

<span class="org-preprocessor">#ifdef</span> _UNITTEST
    <span class="org-type">NetContext</span>* <span class="org-function-name">GetCtx</span>() { <span class="org-keyword">return</span> &amp;m_Ctx; }
<span class="org-preprocessor">#endif</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-2" class="outline-4">
<h4 id="sec-2-10-2"><span class="section-number-4">2.10.2</span> Create</h4>
<div class="outline-text-4" id="text-2-10-2">
<p>
对于create的话我们看稍微复杂的一个实现，就是头参数是bTCP的原型实现。注意这里ip=0,port=0的话那么这样对于client来说的话就会随机选择一个端口。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Create</span>(<span class="org-type">bool</span> <span class="org-variable-name">bTCP</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint32</span> <span class="org-variable-name">flag</span>)
{
    <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>;
    ASSERT(<span class="org-negation-char">!</span>IsCreated());
    <span class="org-type">int</span> <span class="org-variable-name">retry</span> = 0;
    <span class="org-type">SOCKADDR_IN</span> <span class="org-variable-name">sa</span>;

<span class="org-constant">retry1</span>:
    m_s = WSASocket(AF_INET, bTCP ? SOCK_STREAM : SOCK_DGRAM, 0, <span class="org-constant">NULL</span>, 0, WSA_FLAG_OVERLAPPED); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;socket.</span>
    <span class="org-keyword">if</span> (INVALID_SOCKET != m_s) {
        atomic_add(&amp;s_nSockets, 1);
        SetReuseAddr(m_s); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#35774;&#32622;reuseadd.</span>
    }
    <span class="org-keyword">else</span> {
        err = WSAGetLastError();
        TRACE0(<span class="org-string">"WSASocket() error: %d(%s)\n"</span>, err, strerror(err));
        <span class="org-keyword">if</span> (retry++ &lt; 10) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;socket&#21487;&#33021;&#20250;&#22240;&#20026;&#21477;&#26564;&#19978;&#32447;&#32780;&#21019;&#24314;&#22833;&#36133;&#65292;&#36825;&#37324;&#20250;&#36827;&#34892;&#37325;&#35797;&#12290;</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">it should be 24: too many open files, we may need to sleep and retry</span>
            Sleep(500);
            TRACE0(<span class="org-string">"Retry %d\n"</span>, retry);
            <span class="org-keyword">goto</span> <span class="org-constant">retry1</span>;
        }
        <span class="org-keyword">else</span> {
            TRACE0(<span class="org-string">"Total sockets: %d\n"</span>, AtomicGetValue(s_nSockets));
            <span class="org-keyword">return</span> err;
        }
    }

    retry = 0;
<span class="org-constant">retry2</span>:
    ZeroMemory(&amp;sa, <span class="org-keyword">sizeof</span>(SOCKADDR_IN));
    sa.sin_port = htons(port);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = ip;

    <span class="org-function-name">UNLIKELY_IF</span> (SOCKET_ERROR == bind(m_s, (LPSOCKADDR)&amp;sa, <span class="org-keyword">sizeof</span>(sa))) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#36827;&#34892;&#32465;&#23450;&#65292;&#20854;&#23454;&#23545;&#20110;client&#21487;&#26377;&#21487;&#26080;&#20294;&#26159;&#27809;&#26377;&#20219;&#20309;&#24433;&#21709;</span>
        err = WSAGetLastError();
        TRACE0(<span class="org-string">"Error in bind(%s, %d): %s\n"</span>, bTCP?<span class="org-string">"TCP"</span>:<span class="org-string">"UDP"</span>, port, strerror(err));

        retry ++;
        <span class="org-keyword">if</span> (retry&lt;3 || (0==port &amp;&amp; retry&lt;10)) { <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#36825;&#37324;&#37325;&#35797;&#21407;&#22240;&#19981;&#22826;&#28165;&#26970;</span>
            Sleep(500);
            TRACE0(<span class="org-string">"Retry %d\n"</span>, retry);
            <span class="org-keyword">goto</span> <span class="org-constant">retry2</span>;
        }

        <span class="org-comment-delimiter">// </span><span class="org-comment">fail to bind</span>
        closesocket(m_s);
        m_s = INVALID_SOCKET;
        <span class="org-keyword">return</span> err;
    }
    <span class="org-keyword">if</span> (0 == port) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20351;&#29992;0&#31471;&#21475;&#26469;&#21019;&#24314;&#30340;&#35805;&#37027;&#20040;&#21487;&#20197;&#36890;&#36807;getsockname&#26469;&#24471;&#21040;&#26368;&#32456;&#32465;&#23450;&#21040;&#30340;&#31471;&#21475;</span>
        <span class="org-type">socklen_t</span> <span class="org-variable-name">namelen</span> = <span class="org-keyword">sizeof</span>(sa);
        getsockname(m_s, (LPSOCKADDR)&amp;sa, &amp;namelen);
        port = ntohs(sa.sin_port);
    }

    InitNetContext(&amp;m_Ctx, m_s, <span class="org-keyword">this</span>, flag);
    m_Ctx.ip = ip;
    m_Ctx.port = port;

    SetName(<span class="org-string">"Socket(%x)"</span>, m_s);
    TRACE4(<span class="org-string">"%s %s created, port=%d\n"</span>, m_name, bTCP?<span class="org-string">"TCP"</span>:<span class="org-string">"UDP"</span>, port);
    m_port = port;
    AtomicSetValue(m_type, ST_CREATED); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26159;&#25104;&#20026;ST_CRERATED&#31867;&#22411;</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bTCP) {
        m_Ctx.flag |= SF_UDP;
        g_pNetworkMan-&gt;Monitor(&amp;m_Ctx);
    }
    <span class="org-keyword">return</span> APFE_OK;
}
</pre>
</div>

<p>
后来我觉得这个Create原型我们也还是值得看看的，因为这个函数原型通常是在server进行accept之后触发的create
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">APF_ERROR</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Create</span>(<span class="org-type">SOCKET</span> <span class="org-variable-name">s</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">uint32</span> <span class="org-variable-name">flag</span>)
{
    ASSERT(<span class="org-negation-char">!</span>IsCreated());

    s_nSockets ++;
    m_s = s;
    m_port = port;
    InitNetContext(&amp;m_Ctx, m_s, <span class="org-keyword">this</span>, flag);
    m_Ctx.port = port;

    AtomicSetValue(m_type, ST_CREATED);
    SetName(<span class="org-string">"Socket(%x)"</span>, m_s);
    g_pNetworkMan-&gt;Monitor(&amp;m_Ctx); <span class="org-comment-delimiter">// </span><span class="org-comment">&#31435;&#21363;&#21551;&#21160;monitor.monitor&#29366;&#24577;&#22312;run&#37324;&#38754;&#30340;&#35805;&#23601;&#20250;&#36890;&#36807;(APFE_NOTIFY,AA_READ)&#26469;&#36890;&#30693;server&#24212;&#35813;&#21457;&#36215;&#35835;&#25805;&#20316;&#20102;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Monitor&#26080;&#38750;&#23601;&#26159;&#36890;&#30693;&#26381;&#21153;&#22120;&#21018;&#36830;&#25509;&#19978;&#26469;&#30340;&#23458;&#25143;&#31471;&#21487;&#35835;&#20102;&#12290;</span>
    <span class="org-keyword">return</span> APFE_OK;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-3" class="outline-4">
<h4 id="sec-2-10-3"><span class="section-number-4">2.10.3</span> Close</h4>
<div class="outline-text-4" id="text-2-10-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Close</span>()
{
    <span class="org-keyword">if</span> (INVALID_SOCKET != m_s) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#22810;&#27425;&#35843;&#29992;Close</span>
        g_pNetworkMan-&gt;Deassociate(&amp;m_Ctx); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;NetContext&#20174;NetworkMan&#35299;&#38500;&#20851;&#32852;</span>
        closesocket(m_s);
        m_s = INVALID_SOCKET;
        atomic_add(&amp;s_nSockets, -1);

        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#22320;&#26041;&#26159;&#36825;&#20040;&#29468;&#27979;&#30340;&#65292;&#26222;&#36890;&#31867;&#22411;socket&#30340;&#35805;&#20165;&#20165;&#26159;&#20026;&#20102;&#21333;&#36830;&#25509;&#36890;&#20449;&#23384;&#22312;&#30340;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36827;&#34892;close&#30340;&#35805;&#23436;&#20840;&#21487;&#20197;&#30452;&#25509;&#20002;&#24323;&#65292;&#32780;&#23545;&#20110;listen&#26469;&#35828;&#30340;&#35805;&#65292;&#22914;&#26524;&#19968;&#26086;&#30452;&#25509;&#20851;&#38381;&#37027;&#20040;&#26381;&#21153;&#23601;&#19981;&#33021;&#22815;&#32500;&#25345;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#35805;&#35828;&#22238;&#26469;&#20010;&#20154;&#24863;&#35273;&#36825;&#20010;&#22320;&#26041;&#36824;&#26159;&#25402;non-sense&#30340;</span>
        <span class="org-keyword">if</span> (ST_LISTEN == AtomicSetValue(m_type, ST_NONE)) {
            Release();
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-4" class="outline-4">
<h4 id="sec-2-10-4"><span class="section-number-4">2.10.4</span> Shutdown</h4>
<div class="outline-text-4" id="text-2-10-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Shutdown</span>(<span class="org-type">bool</span> <span class="org-variable-name">bLingerOff</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">state</span> = AtomicSetValue(m_Ctx.state, SS_SHUTDOWN);
    <span class="org-keyword">if</span> (INVALID_SOCKET != m_s) {
        TRACE2(<span class="org-string">"Shutdown socket(%x), LingerOff=%d\n"</span>, m_s, bLingerOff);
        <span class="org-keyword">if</span> (bLingerOff) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#19981;care&#36825;&#20010;linger&#37096;&#20998;</span>
            SetLingerOff(m_s);
        }
        shutdown(m_s, SHUT_RDWR);
        <span class="org-keyword">if</span> (SS_CONNECTING_0==state &amp;&amp; <span class="org-negation-char">!</span>g_pNetworkMan-&gt;Delay(&amp;m_Ctx, 0)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#22320;&#26041;&#36825;&#20040;&#22788;&#29702;&#21407;&#22240;</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#22240;&#20026;&#22914;&#26524;&#25105;&#20204;&#24403;&#21069;&#26159;&#36825;&#26679;&#29366;&#24577;&#30340;&#35805;&#65292;&#24182;&#19988;&#24050;&#32463;&#21457;&#36215;&#20102;&#19968;&#20010;Delay&#20107;&#20214;&#30340;&#35805;</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#32943;&#23450;&#20250;&#34987;&#36890;&#30693;&#21040;&#28982;&#21518;&#35843;&#29992;NotifyClient&#65292;&#25152;&#20197;&#36825;&#25105;&#20204;&#38656;&#35201;&#39318;&#20808;AddRef.</span>
            AddRef();
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-5" class="outline-4">
<h4 id="sec-2-10-5"><span class="section-number-4">2.10.5</span> Listen</h4>
<div class="outline-text-4" id="text-2-10-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Listen</span>(<span class="org-type">int</span> <span class="org-variable-name">backlog</span>)
{
    ASSERT(IsCreated());

    AtomicSetValue(m_type, ST_LISTEN); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#25104;&#20026;ST_LISTEN&#29366;&#24577;</span>
    g_pNetworkMan-&gt;Listen(&amp;m_Ctx, backlog); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#21457;&#36215;listen</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-6" class="outline-4">
<h4 id="sec-2-10-6"><span class="section-number-4">2.10.6</span> Connect</h4>
<div class="outline-text-4" id="text-2-10-6">
<p>
Connect相关函数有Connect,ConnectAndWrite以及ReConnect,都非常简单通过NetworkMan发起操作
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Connect</span>(<span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">uint32</span> <span class="org-variable-name">timeout</span>)
{
    <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE5("Connecting(%x) %s:%d...\n", m_s, in_ntoa(ip), port);</span>
    ASSERT(IsCreated());
    g_pNetworkMan-&gt;Connect(&amp;m_Ctx, ip, port, <span class="org-constant">NULL</span>, 0, timeout, &amp;m_Req);
}

<span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">ConnectAndWrite</span>(<span class="org-type">uint32</span> <span class="org-variable-name">ip</span>, <span class="org-type">uint16</span> <span class="org-variable-name">port</span>, <span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">uint32</span> <span class="org-variable-name">timeout</span>)
{
    <span class="org-comment-delimiter">//</span><span class="org-comment">TRACE5("Connecting(%x) %s:%d...\n", m_s, in_ntoa(ip), port);</span>
    ASSERT(IsCreated());
    g_pNetworkMan-&gt;Connect(&amp;m_Ctx, ip, port, pBuf, count, timeout, &amp;m_Req);
}

<span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">ReConnect</span>(<span class="org-type">uint32</span> <span class="org-variable-name">nMilliseconds</span>)
{
    m_Ctx.pWriteReq = &amp;m_Req;
    m_Ctx.nDelayRead = 0;
    m_Ctx.tRead.Init();
    m_Ctx.tWrite.Init();
    m_Ctx.state = SS_CONNECTING_0;
    g_pNetworkMan-&gt;Delay(&amp;m_Ctx, nMilliseconds); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#26377;&#36825;&#31181;SS_CONNECTING_0&#29366;&#24577;&#25165;&#20250;&#21457;&#36215;Delay&#20107;&#20214;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-7" class="outline-4">
<h4 id="sec-2-10-7"><span class="section-number-4">2.10.7</span> Read &amp; Write</h4>
<div class="outline-text-4" id="text-2-10-7">
<p>
Read/Write函数也非常简单无非就是包装一些NetRequest然后交给NetworkMan来发起
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Read</span>(<span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">int</span> <span class="org-variable-name">request</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    g_pNetworkMan-&gt;Read(&amp;m_Ctx, pBuf, count, request, pReq);
}

<span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">Write</span>(<span class="org-type">void</span>* <span class="org-variable-name">pBuf</span>, <span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span>)
{
    g_pNetworkMan-&gt;Write(&amp;m_Ctx, pBuf, count, pReq);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-8" class="outline-4">
<h4 id="sec-2-10-8"><span class="section-number-4">2.10.8</span> OnCompletion</h4>
<div class="outline-text-4" id="text-2-10-8">
<p>
其实对于Socket部分最主要的内容还是在这里。上面那些函数无非是做一个Wrapper，而Socket本质上还是一个CAsyncClient要处理各种事件回调。
我们需要仔细看看OnCompletion的过程，因为大部分我们所需要扩展的就是这个部分了。但是如果仔细阅读这个部分的话，还是会发现有很多细节的东西的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CSocketV</span>::<span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">pContext</span>)
{
    <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq</span> = (<span class="org-type">NetRequest</span>*)pContext;
    <span class="org-type">int</span> <span class="org-variable-name">nAction</span> = pContext-&gt;nAction;
    <span class="org-keyword">switch</span> (nAction) {
    <span class="org-keyword">case</span> AA_READ: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;READ&#30340;&#35805;&#65292;&#37027;&#20040;&#35302;&#21457;OnRead&#22238;&#35843;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#33021;&#23384;&#22312;&#30340;ErrCode&#21253;&#25324;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_AFTER_BROKEN todo:how to handle</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_NET_ERROR todo:how to handle</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_NOTIFY &#38656;&#35201;&#25105;&#20204;&#33258;&#24049;&#37322;&#25918;pReq,&#22240;&#20026;&#36825;&#20010;&#26159;new&#20986;&#26469;&#30340;.&#36890;&#24120;&#25105;&#20204;&#26377;&#26032;&#30340;client&#36830;&#25509;&#19978;&#26469;&#24212;&#35813;&#21457;&#36215;&#35835;&#25805;&#20316;&#20102;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_OK &#21457;&#36215;&#30340;&#35835;&#25805;&#20316;&#27809;&#26377;&#20219;&#20309;&#38169;&#35823;</span>
        OnRead(pContext-&gt;nErrCode, pReq);
        <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> AA_WRITE: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;WRITE&#25805;&#20316;&#30340;&#35805;&#65292;&#37027;&#20040;&#35302;&#21457;OnWrite&#22238;&#35843;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#33021;&#23384;&#22312;&#30340;ErrCode&#21253;&#25324;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_AFTER_BROKEN todo:how to handle</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_NET_ERROR todo:how to handle</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_OK &#21457;&#36215;&#30340;&#20889;&#25805;&#20316;&#27809;&#26377;&#20219;&#20309;&#38169;&#35823;</span>
        OnWritten(pContext-&gt;nErrCode, pReq);
        <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> AA_LISTEN: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;LISTEN&#25805;&#20316;&#30340;&#35805;</span>
        <span class="org-keyword">if</span> (0 == pContext-&gt;nErrCode) { <span class="org-comment-delimiter">// </span><span class="org-comment">listen&#35843;&#29992;&#27809;&#26377;&#20219;&#20309;&#38382;&#39064;</span>
            <span class="org-keyword">while</span> (1) {
                <span class="org-type">SOCKADDR_IN</span> <span class="org-variable-name">sa</span>;
                <span class="org-type">socklen_t</span> <span class="org-variable-name">saLen</span> = <span class="org-keyword">sizeof</span>(sa);

                TRACE7(<span class="org-string">"To accept(%x)\n"</span>, m_s);
                <span class="org-type">SOCKET</span> <span class="org-variable-name">s</span> = accept(m_s, (LPSOCKADDR)&amp;sa, &amp;saLen);
                <span class="org-keyword">if</span> (-1 != s) {
                    TRACE1(<span class="org-string">"Accepted(%x) %s:%d = %x\n"</span>, m_s, in_ntoa(sa.sin_addr.s_addr), ntohs(sa.sin_port), s);
                    OnListened(s, &amp;sa); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#27599;&#19968;&#20010;accept&#37117;&#35302;&#21457;OnListened&#22238;&#35843;</span>
                }
                <span class="org-keyword">else</span> {
                    TRACE7(<span class="org-string">"Error in accept(%x)\n"</span>, m_s);
                    <span class="org-keyword">break</span>;
                }
            }
        }
        <span class="org-keyword">delete</span> pReq;
        <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> AA_CONNECT: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25105;&#20204;&#21457;&#36215;&#30340;&#26159;CONNECT&#25805;&#20316;&#30340;&#35805;</span>
        AtomicSetValue(m_type, ST_CONNECTED);
        TRACE1(<span class="org-string">"OnConnected(%x): %d, %p\n"</span>, m_s, pContext-&gt;nErrCode, pContext);
        <span class="org-keyword">if</span> (0 == pContext-&gt;nErrCode) {
            OnConnected(0); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#27809;&#26377;&#20219;&#20309;&#38169;&#35823;&#65292;&#37027;&#20040;&#35302;&#21457;OnConnected(0)</span>
            <span class="org-keyword">break</span>;
        }
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> (OnConnected(pContext-&gt;nErrCode)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;OnConnected(err)&#36820;&#22238;true&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;</span>
            <span class="org-keyword">break</span>;
        }

        pContext-&gt;nErrCode = APFE_CONNECT_ERROR; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#35748;&#20026;connect&#36825;&#26679;&#26159;&#19968;&#20010;&#38169;&#35823;&#30340;&#35805;&#65292;&#37027;&#20040;&#21518;&#38754;&#30340;&#38169;&#35823;&#37117;&#26159;APFE_CONNECT_ERROR</span>
        Release(); <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#36825;&#20010;&#22320;&#26041;&#20026;&#20160;&#20040;&#38656;&#35201;Release</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21407;&#22240;&#26159;&#22240;&#20026;&#20316;&#32773;&#20551;&#35774;&#25105;&#20204;&#32534;&#20889;&#26041;&#24335;&#37117;&#26159;&#22312;&#21021;&#22987;&#21270;&#24320;&#22987;AddRef&#19968;&#19979;&#65292;&#28982;&#21518;&#23545;&#20110;OnBorken&#36825;&#31867;&#38169;&#35823;&#30340;&#35805;&#36890;&#24120;&#38656;&#35201;&#26512;&#26500;CAsyncClient,&#25152;&#20197;Release&#35753;&#25105;&#20204;&#21487;&#20197;&#38144;&#27585;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">goes here</span>

    <span class="org-keyword">case</span> AA_BROKEN: <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;&#26029;&#24320;&#65292;&#21487;&#33021;&#26159;&#23458;&#25143;&#31471;&#30340;&#27491;&#24120;&#20851;&#38381;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#38169;&#35823;&#30721;&#21487;&#33021;&#26377;&#19979;&#38754;&#36825;&#20123;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_CONNECT_ERROR &#36830;&#25509;&#20986;&#29616;&#38169;&#35823;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_TIMEDOUT &#36830;&#25509;&#20986;&#29616;&#36229;&#26102;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_SYS_ERROR todo:???</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">APFE_NET_ERROR todo:???</span>
        TRACE5(<span class="org-string">"CSocket::OnBroken(%x): %d\n"</span>, m_s, pContext-&gt;nErrCode);
        AtomicSetValue(m_type, ST_ERROR);
        ASSERT(<span class="org-constant">NULL</span> == m_Ctx.pReadReq);
        ASSERT(<span class="org-constant">NULL</span> == m_Ctx.pWriteReq);

        m_Ctx.tWrite.Set(LARGE_ENOUGH_NEGATIVE);
        m_Ctx.tRead.Set(LARGE_ENOUGH_NEGATIVE);
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25552;&#20132;&#20102;&#36825;&#20123;&#35831;&#27714;&#30340;&#35805;&#65292;&#37027;&#20040;&#37117;&#20250;&#37325;&#26032;&#35302;&#21457;&#19968;&#27425;OnWritten/OnRead&#24182;&#19988;&#20197;&#23545;&#24212;&#30340;&#38169;&#35823;&#21495;&#36890;&#30693;</span>
        {
            <span class="org-type">NetRequest</span>* <span class="org-variable-name">pReq1</span>;
            <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != (pReq1=m_Ctx.qWrite.pop_front())) {
                OnWritten(pContext-&gt;nErrCode, pReq1);
                Release();
            }
            <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != (pReq1=m_Ctx.qRead.pop_front())) {
                OnRead(pContext-&gt;nErrCode, pReq1);
                Release();
            }
        }
        OnBroken(pContext-&gt;nErrCode);
        <span class="org-comment-delimiter">// </span><span class="org-comment">AA_CONNECT also goes here</span>
        <span class="org-keyword">if</span> (nAction == AA_BROKEN)
            <span class="org-keyword">delete</span> pReq;
        <span class="org-keyword">break</span>;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-10-9" class="outline-4">
<h4 id="sec-2-10-9"><span class="section-number-4">2.10.9</span> Summary</h4>
<div class="outline-text-4" id="text-2-10-9">
<p>
个人觉得kylin的网络异步部分就是spaghetti,所有的nAction以及nErrCode都是相互缠绕.我们可以假设我们的场景类似于RPC然后考虑一下应该如何处理。
</p>
<ul class="org-ul">
<li>OnConnected(APF_ERROR nErrCode).如果nErrCode!=APFE_OK的话那么Close,否则认为连接成功.错误交给OnBorken处理
</li>
<li>OnListened(SOCKET s, SOCKADDR_IN* pSockAddrIn).建立连接即可。
</li>
<li>OnWritten(APF_ERROR nErrCode, NetRequest* pReq).如果nErrCode!=APFE_OK的话，那么Close连接。
</li>
<li>OnRead(APF_ERROR nErrCode, NetRequest* pReq).如果nErrCode=APFE_NOTIFY的话那么发起Read,如果=APFE_OK的话那么处理，其他情况下面Close连接。
</li>
<li>OnBroken(APF_ERROR nErrCode).直接Close即可，但是可以根据nErrCode来判断原因.可能是客户端正常关闭.通常最后需要Release一下，释放这个连接。
</li>
</ul>
<p>
关于具体使用的话可以仔细参考demo/echo.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> demo</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> echo</h3>
<div class="outline-text-3" id="text-3-1">
<p>
echo这个就是客户端连接上之后不断发送1K数据而服务器就直接回复这1K数据
</p>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> client.cc</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;time.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"stdafx.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Kylin.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Socket.h"</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">ERR</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stderr,fmt,##__VA_ARGS__)
<span class="org-preprocessor">#define</span> <span class="org-function-name">DBG</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stdout,fmt,##__VA_ARGS__)
<span class="org-comment-delimiter">//</span><span class="org-comment">#define DBG(fmt,...)</span>

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">connect_timeout_ms</span>=5*1000;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">CONNECT_TIMEOUT</span>=AA_USER_BEGIN;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">read_timeout_ms</span>=1200*1000;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">READ_TIMEOUT</span>=AA_USER_BEGIN+1;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">worker_num</span>=8;
<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">worker</span>=worker_num;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">packet_size</span>=1024;

<span class="org-keyword">class</span> <span class="org-type">XAsyncClient</span>:<span class="org-keyword">public</span> <span class="org-type">CSocketV</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">AsyncContext</span> <span class="org-variable-name">delay_ctx</span>;
    <span class="org-type">char</span> <span class="org-variable-name">packet</span>[packet_size];
    <span class="org-function-name">XAsyncClient</span>(<span class="org-type">int</span> <span class="org-variable-name">id_</span>):<span class="org-function-name">id</span>(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
        memset(packet,0xcc,packet_size);
    }
    ~<span class="org-function-name">XAsyncClient</span>(){
    }
    <span class="org-type">void</span> <span class="org-function-name">Print</span>(){
        ERR(<span class="org-string">"(%d)xref:%d\n"</span>,id,<span class="org-constant">CAsyncClient</span>::GetRef());
    }
    <span class="org-type">void</span> <span class="org-function-name">Close</span>(){
        <span class="org-constant">CSocketV</span>::Close();
        atomic_add(&amp;worker,-1);
    }
    <span class="org-type">void</span> <span class="org-function-name">StartConnnect</span>(){
        <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>=<span class="org-constant">CSocketV</span>::Create(<span class="org-constant">true</span>);
        <span class="org-keyword">if</span>(err==APFE_OK){
            Connect(in_aton(<span class="org-string">"127.0.0.1"</span>),19870);
            <span class="org-comment-delimiter">// </span><span class="org-comment">we don't need to AddRef() right here.</span>
            g_pExecMan-&gt;DelayExec(CONNECT_TIMEOUT,<span class="org-keyword">this</span>,connect_timeout_ms,&amp;delay_ctx);
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnBroken</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release();
    }
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">OnConnected</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>){
        g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
        <span class="org-keyword">if</span>(nErrCode==APFE_OK){
            DBG(<span class="org-string">"APFE_OK OnConnected ready\n"</span>);
            Write(packet,packet_size,&amp;m_Req);
            <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"OnConnected(%s)\n"</span>,APFError2Str(nErrCode));
            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnWritten</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        <span class="org-keyword">if</span>(nErrCode==APFE_OK){
            DBG(<span class="org-string">"APFE_OK OnWritten(%d)\n"</span>,req-&gt;xfered);
            Read(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
            <span class="org-comment-delimiter">// </span><span class="org-comment">we don't need to AddRef() right here.</span>
            g_pExecMan-&gt;DelayExec(READ_TIMEOUT,<span class="org-keyword">this</span>,read_timeout_ms,&amp;delay_ctx);
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
}
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnRead</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
        <span class="org-keyword">if</span>(nErrCode==APFE_OK){
            DBG(<span class="org-string">"APFE_OK OnRead(%d)\n"</span>,req-&gt;xfered);
            Write(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">ctx</span>){
        <span class="org-keyword">switch</span>(ctx-&gt;nAction){
            <span class="org-keyword">case</span> CONNECT_TIMEOUT:
                ERR(<span class="org-string">"connect timeout(%d ms)\n"</span>,connect_timeout_ms);
                Close();
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> READ_TIMEOUT:
                ERR(<span class="org-string">"read timeout(%d ms)\n"</span>,read_timeout_ms);
                Close();
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                <span class="org-constant">CSocketV</span>::OnCompletion(ctx);
                <span class="org-keyword">break</span>;
        }
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    InitKylin(2,2,0);
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt; <span class="org-type">XAsyncClient</span>* &gt; <span class="org-variable-name">vec</span>;
    <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>=0;i&lt;worker_num;i++){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=<span class="org-keyword">new</span> <span class="org-type">XAsyncClient</span>(i);
        vec.push_back(client);
        client-&gt;StartConnnect();
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">100ms.</span>
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span> <span class="org-variable-name">timeout</span>={0,100*1000000};
    <span class="org-keyword">while</span>(1){
        nanosleep(&amp;timeout,<span class="org-constant">NULL</span>);
        <span class="org-keyword">if</span>(AtomicGetValue(worker)==0){
            StopKylin(<span class="org-constant">true</span>);
            <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> server.cc</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;time.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"stdafx.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Kylin.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Socket.h"</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">ERR</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stderr,fmt,##__VA_ARGS__)
<span class="org-preprocessor">#define</span> <span class="org-function-name">DBG</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stdout,fmt,##__VA_ARGS__)
<span class="org-comment-delimiter">//</span><span class="org-comment">#define DBG(fmt,...)</span>

<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">client_id</span>=-1;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">packet_size</span>=1024;
<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">stop</span>=0;
<span class="org-type">void</span> <span class="org-function-name">signal_handler</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>){
    AtomicSetValue(stop,1);
}

<span class="org-keyword">class</span> <span class="org-type">XAsyncClient</span>:<span class="org-keyword">public</span> <span class="org-type">CSocketV</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">AsyncContext</span> <span class="org-variable-name">delay_ctx</span>;
    <span class="org-type">char</span> <span class="org-variable-name">packet</span>[packet_size];
    <span class="org-function-name">XAsyncClient</span>(<span class="org-type">int</span> <span class="org-variable-name">id_</span>):<span class="org-function-name">id</span>(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
        memset(packet,0xcc,packet_size);
    }
    ~<span class="org-function-name">XAsyncClient</span>(){
    }
    <span class="org-type">void</span> <span class="org-function-name">Print</span>(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d\n"</span>,id,<span class="org-constant">CAsyncClient</span>::GetRef());
    }
    <span class="org-type">void</span> <span class="org-function-name">StartServe</span>(){
        <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>=<span class="org-constant">CSocketV</span>::Create(<span class="org-constant">true</span>,19870);
        <span class="org-keyword">if</span>(err==APFE_OK){
            Listen();
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    <span class="org-type">void</span> <span class="org-function-name">OnListened</span>(<span class="org-type">SOCKET</span> <span class="org-variable-name">s</span>,<span class="org-type">SOCKADDR_IN</span>* <span class="org-variable-name">pSockAddrIn</span>){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=<span class="org-keyword">new</span> <span class="org-type">XAsyncClient</span>(atomic_add(&amp;client_id,1));
        <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>=client-&gt;Create(s,pSockAddrIn-&gt;sin_port);
        <span class="org-keyword">if</span>(err==APFE_OK){
            ;
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
            Release();
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnBroken</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release(); <span class="org-comment-delimiter">// </span><span class="org-comment">we have to call 'Release' right here to free connection.</span>
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnWritten</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        <span class="org-keyword">switch</span>(nErrCode){
            <span class="org-keyword">case</span> APFE_OK:
                DBG(<span class="org-string">"APFE_OK OnWritten(%d)\n"</span>,req-&gt;xfered);
                Read(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnRead</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        <span class="org-keyword">switch</span>(nErrCode){
            <span class="org-keyword">case</span> APFE_NOTIFY:
                <span class="org-keyword">delete</span> req;
                DBG(<span class="org-string">"APFE_NOTIFY OnRead ready\n"</span>);
                Read(packet,packet_size,&amp;m_Req);
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> APFE_OK:
                DBG(<span class="org-string">"APFE_OK OnRead(%d)\n"</span>,req-&gt;xfered);
                Write(req-&gt;buf,req-&gt;xfered,&amp;m_Req);
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                <span class="org-keyword">break</span>;
        }
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    signal(SIGINT,signal_handler);
    InitKylin(2,2,0);
    <span class="org-type">XAsyncClient</span> <span class="org-variable-name">client</span>(0);
    client.StartServe();
    <span class="org-comment-delimiter">// </span><span class="org-comment">100ms.</span>
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span> <span class="org-variable-name">timeout</span>={0,100*1000000};
    <span class="org-keyword">while</span>(1){
        nanosleep(&amp;timeout,<span class="org-constant">NULL</span>);
        <span class="org-keyword">if</span>(AtomicGetValue(stop)==1){
            StopKylin(<span class="org-constant">true</span>);
            <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> file-request</h3>
<div class="outline-text-3" id="text-3-2">
<p>
file-request希望可以结合ExecMan,NetworkMan和DiskMan三个Manager写一个简单的demo,功能非常简单就是客户端每次发送一个文件名，服务端得到之后分析出文件名然后将内容返回给client.
消息格式都是头部带上了4个字节的长度，然后后面跟上数据。和之前的echo不同的是我们这里需要采取分段读取。
</p>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> client.cc</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;time.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"stdafx.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Kylin.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Socket.h"</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">ERR</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stderr,fmt,##__VA_ARGS__)
<span class="org-preprocessor">#define</span> <span class="org-function-name">DBG</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stdout,fmt,##__VA_ARGS__)
<span class="org-comment-delimiter">//</span><span class="org-comment">#define DBG(fmt,...)</span>

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">connect_timeout_ms</span>=5*1000;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">CONNECT_TIMEOUT</span>=AA_USER_BEGIN;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">worker_num</span>=1;
<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">worker</span>=worker_num;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">filename</span>=<span class="org-string">"./file-server.cc"</span>;

<span class="org-keyword">class</span> <span class="org-type">XAsyncClient</span>:<span class="org-keyword">public</span> <span class="org-type">CSocketV</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">AsyncContext</span> <span class="org-variable-name">delay_ctx</span>;
    <span class="org-keyword">enum</span> <span class="org-type">status_t</span>{
        <span class="org-variable-name">READ_BOEY_LEN</span>,
        <span class="org-variable-name">READ_BODY_CONTENT</span>,
    };
    <span class="org-type">status_t</span> <span class="org-variable-name">status</span>;
    <span class="org-type">int</span> <span class="org-variable-name">read_body_len</span>;
    <span class="org-function-name">XAsyncClient</span>(<span class="org-type">int</span> <span class="org-variable-name">id_</span>):<span class="org-function-name">id</span>(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
    }
    ~<span class="org-function-name">XAsyncClient</span>(){
    }
    <span class="org-type">void</span> <span class="org-function-name">Print</span>(){
        ERR(<span class="org-string">"(%d)xref:%d\n"</span>,id,<span class="org-constant">CAsyncClient</span>::GetRef());
    }
    <span class="org-type">void</span> <span class="org-function-name">Close</span>(){
        <span class="org-constant">CSocketV</span>::Close();
        atomic_add(&amp;worker,-1);
    }
    <span class="org-type">void</span> <span class="org-function-name">StartConnnect</span>(){
        <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>=<span class="org-constant">CSocketV</span>::Create(<span class="org-constant">true</span>);
        <span class="org-keyword">if</span>(err==APFE_OK){
            Connect(in_aton(<span class="org-string">"127.0.0.1"</span>),19870);
            <span class="org-comment-delimiter">// </span><span class="org-comment">we don't need to AddRef() right here.</span>
            g_pExecMan-&gt;DelayExec(CONNECT_TIMEOUT,<span class="org-keyword">this</span>,connect_timeout_ms,&amp;delay_ctx);
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnBroken</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release();
    }
    <span class="org-type">int</span> <span class="org-function-name">MakeFileRequest</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">fname</span>,<span class="org-type">char</span>** <span class="org-variable-name">request</span>){
        <span class="org-type">int</span> <span class="org-variable-name">len</span>=strlen(fname)+1; <span class="org-comment-delimiter">// </span><span class="org-comment">include trailing '\0'</span>
        <span class="org-type">char</span>* <span class="org-variable-name">tmp</span>=(<span class="org-type">char</span>*)malloc(len+4);
        *(<span class="org-type">int</span>*)tmp=len;
        strcpy(tmp+<span class="org-keyword">sizeof</span>(<span class="org-type">int</span>),fname);
        *request=tmp;
        <span class="org-keyword">return</span> len+4;
    }
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">OnConnected</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>){
        g_pExecMan-&gt;CancelExec(&amp;delay_ctx);
        <span class="org-keyword">if</span>(nErrCode==APFE_OK){
            DBG(<span class="org-string">"OnConnected\n"</span>);
            <span class="org-type">char</span>* <span class="org-variable-name">request</span>=<span class="org-constant">NULL</span>;
            <span class="org-type">int</span> <span class="org-variable-name">request_len</span>=MakeFileRequest(filename,&amp;request);
            DBG(<span class="org-string">"MakeFileRequest (%s)(%d)\n"</span>,filename,request_len);
            Write(request,request_len,&amp;m_Req);
            <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"OnConnected(%s)\n"</span>,APFError2Str(nErrCode));
            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnWritten</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        free(req-&gt;buf);
        <span class="org-keyword">if</span>(nErrCode==APFE_OK){
            DBG(<span class="org-string">"ReadBodyLen\n"</span>);
            status=READ_BOEY_LEN;
            Read(&amp;read_body_len,<span class="org-keyword">sizeof</span>(read_body_len),&amp;m_Req);
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnRead</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        <span class="org-keyword">if</span>(nErrCode==APFE_OK){
            <span class="org-keyword">if</span>(status==READ_BOEY_LEN){
                DBG(<span class="org-string">"ReadBodyLen OK(%d)\n"</span>,read_body_len);
                <span class="org-type">char</span>* <span class="org-variable-name">tmp</span>=(<span class="org-type">char</span>*)malloc(read_body_len);
                status=READ_BODY_CONTENT;
                Read(tmp,read_body_len,&amp;m_Req);
            }<span class="org-keyword">else</span> <span class="org-keyword">if</span>(status==READ_BODY_CONTENT){
                free(req-&gt;buf);
                DBG(<span class="org-string">"ReadBodyContent OK\n"</span>);
                <span class="org-type">char</span>* <span class="org-variable-name">request</span>=<span class="org-constant">NULL</span>;
                <span class="org-type">int</span> <span class="org-variable-name">request_len</span>=MakeFileRequest(filename,&amp;request);
                DBG(<span class="org-string">"MakeFileRequest (%s)(%d)\n"</span>,filename,request_len);
                Write(request,request_len,&amp;m_Req);
            }
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
            Close();
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">ctx</span>){
        <span class="org-keyword">switch</span>(ctx-&gt;nAction){
            <span class="org-keyword">case</span> CONNECT_TIMEOUT:
                ERR(<span class="org-string">"connect timeout(%d ms)\n"</span>,connect_timeout_ms);
                Close();
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                <span class="org-constant">CSocketV</span>::OnCompletion(ctx);
                <span class="org-keyword">break</span>;
        }
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    InitKylin(2,2,0);
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt; <span class="org-type">XAsyncClient</span>* &gt; <span class="org-variable-name">vec</span>;
    <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>=0;i&lt;worker_num;i++){
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=<span class="org-keyword">new</span> <span class="org-type">XAsyncClient</span>(i);
        vec.push_back(client);
        client-&gt;StartConnnect();
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">100ms.</span>
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span> <span class="org-variable-name">timeout</span>={0,100*1000000};
    <span class="org-keyword">while</span>(1){
        nanosleep(&amp;timeout,<span class="org-constant">NULL</span>);
        <span class="org-keyword">if</span>(AtomicGetValue(worker)==0){
            StopKylin(<span class="org-constant">true</span>);
            <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> server.cc</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstdio&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;time.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"stdafx.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Kylin.h"</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"Socket.h"</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">ERR</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stderr,fmt,##__VA_ARGS__)
<span class="org-preprocessor">#define</span> <span class="org-function-name">DBG</span>(<span class="org-variable-name">fmt</span>,...) fprintf(stdout,fmt,##__VA_ARGS__)
<span class="org-comment-delimiter">//</span><span class="org-comment">#define DBG(fmt,...)</span>

<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">client_id</span>=-1;
<span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">stop</span>=0;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">disk_thread_num</span>=4;

<span class="org-type">void</span> <span class="org-function-name">signal_handler</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>){
    AtomicSetValue(stop,1);
}

<span class="org-keyword">class</span> <span class="org-type">XAsyncClient</span>:<span class="org-keyword">public</span> <span class="org-type">CSocketV</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">AsyncContext</span> <span class="org-variable-name">delay_ctx</span>;
    <span class="org-type">DiskContext</span> <span class="org-variable-name">disk_ctx</span>;
    <span class="org-type">DiskRequest</span> <span class="org-variable-name">disk_req</span>;
    <span class="org-keyword">enum</span> <span class="org-type">status_t</span>{
        <span class="org-variable-name">READ_BODY_LEN</span>,
        <span class="org-variable-name">READ_BODY_CONTENT</span>,
    };
    <span class="org-type">status_t</span> <span class="org-variable-name">status</span>;
    <span class="org-type">int</span> <span class="org-variable-name">read_body_len</span>;
    <span class="org-type">char</span>* <span class="org-variable-name">reply</span>;
    <span class="org-type">int</span> <span class="org-variable-name">reply_len</span>;
    <span class="org-function-name">XAsyncClient</span>(<span class="org-type">int</span> <span class="org-variable-name">id_</span>):<span class="org-function-name">id</span>(id_){
        AddRef();
        InitAsyncContext(&amp;delay_ctx);
    }
    ~<span class="org-function-name">XAsyncClient</span>(){
    }
    <span class="org-type">void</span> <span class="org-function-name">Print</span>(){
        fprintf(stderr,<span class="org-string">"(%d)xref:%d\n"</span>,id,<span class="org-constant">CAsyncClient</span>::GetRef());
    }
    <span class="org-type">void</span> <span class="org-function-name">StartServe</span>(){
        <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>=<span class="org-constant">CSocketV</span>::Create(<span class="org-constant">true</span>,19870);
        <span class="org-keyword">if</span>(err==APFE_OK){
            Listen();
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
        }
    }
    <span class="org-type">void</span> <span class="org-function-name">OnListened</span>(<span class="org-type">SOCKET</span> <span class="org-variable-name">s</span>,<span class="org-type">SOCKADDR_IN</span>* <span class="org-variable-name">pSockAddrIn</span>){
        DBG(<span class="org-string">"OnListened\n"</span>);
        <span class="org-type">XAsyncClient</span>* <span class="org-variable-name">client</span>=<span class="org-keyword">new</span> <span class="org-type">XAsyncClient</span>(atomic_add(&amp;client_id,1));
        <span class="org-type">APF_ERROR</span> <span class="org-variable-name">err</span>=client-&gt;Create(s,pSockAddrIn-&gt;sin_port);
        <span class="org-keyword">if</span>(err==APFE_OK){
            ;
        }<span class="org-keyword">else</span>{
            ERR(<span class="org-string">"Create(%s)\n"</span>,APFError2Str(err));
            Release();
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnBroken</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>){
        ERR(<span class="org-string">"OnBroken(%s)\n"</span>,APFError2Str(nErrCode));
        Close();
        Release(); <span class="org-comment-delimiter">// </span><span class="org-comment">we have to call 'Release' right here to free connection.</span>
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnWritten</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        free(req-&gt;buf);
        <span class="org-keyword">switch</span>(nErrCode){
            <span class="org-keyword">case</span> APFE_OK:
                DBG(<span class="org-string">"OnWritten\n"</span>);
                status=READ_BODY_LEN;
                Read(&amp;read_body_len,<span class="org-keyword">sizeof</span>(read_body_len),&amp;m_Req);
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                ERR(<span class="org-string">"OnWritten(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnRead</span>(<span class="org-type">APF_ERROR</span> <span class="org-variable-name">nErrCode</span>,<span class="org-type">NetRequest</span>* <span class="org-variable-name">req</span>){
        <span class="org-keyword">switch</span>(nErrCode){
            <span class="org-keyword">case</span> APFE_NOTIFY:
                <span class="org-keyword">delete</span> req;
                DBG(<span class="org-string">"OnRead APFE_NOTIFY\n"</span>);
                status=READ_BODY_LEN;
                Read(&amp;read_body_len,<span class="org-keyword">sizeof</span>(read_body_len),&amp;m_Req);
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> APFE_OK:
                <span class="org-keyword">if</span>(status==READ_BODY_LEN){
                    DBG(<span class="org-string">"ReadBodyLen OK(%d)\n"</span>,read_body_len);
                    <span class="org-type">char</span>* <span class="org-variable-name">request</span>=(<span class="org-type">char</span>*)malloc(read_body_len);
                    status=READ_BODY_CONTENT;
                    Read(request,read_body_len,&amp;m_Req);
                }<span class="org-keyword">else</span> <span class="org-keyword">if</span>(status==READ_BODY_CONTENT){
                    DBG(<span class="org-string">"ReadBodyContent OK(%s)\n"</span>,req-&gt;buf);
                    <span class="org-type">int</span> <span class="org-variable-name">fd</span>=open((<span class="org-type">char</span>*)req-&gt;buf,O_RDONLY,0666);
                    free(req-&gt;buf);

                    <span class="org-comment-delimiter">// </span><span class="org-comment">init disk read.</span>
                    <span class="org-keyword">struct</span> <span class="org-type">stat</span> <span class="org-variable-name">st_buf</span>;
                    fstat(fd,&amp;st_buf);
                    reply_len=<span class="org-keyword">sizeof</span>(<span class="org-type">int</span>)+st_buf.st_size;
                    reply=(<span class="org-type">char</span>*)malloc(reply_len);
                    *(<span class="org-type">int</span>*)reply=(<span class="org-type">int</span>)st_buf.st_size;
                    g_pDiskMan-&gt;Associate(id%disk_thread_num,fd,<span class="org-keyword">this</span>,&amp;disk_ctx);
                    DBG(<span class="org-string">"ReadDiskContent (%d)\n"</span>,reply_len-<span class="org-keyword">sizeof</span>(<span class="org-type">int</span>));
                    disk_req.off=0; <span class="org-comment-delimiter">// </span><span class="org-comment">read from beginning.</span>
                    g_pDiskMan-&gt;Read(&amp;disk_ctx,reply+<span class="org-keyword">sizeof</span>(<span class="org-type">int</span>),reply_len-<span class="org-keyword">sizeof</span>(<span class="org-type">int</span>),&amp;disk_req);
                }
                <span class="org-keyword">break</span>;
            <span class="org-keyword">default</span>:
                ERR(<span class="org-string">"OnRead(%s)\n"</span>,APFError2Str(nErrCode));
                Close();
                <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">OnCompletion</span>(<span class="org-type">AsyncContext</span>* <span class="org-variable-name">ctx</span>){
        <span class="org-keyword">if</span>(ctx==&amp;(disk_req.async)){
            assert(ctx-&gt;nAction==AA_READ); <span class="org-comment-delimiter">// </span><span class="org-comment">disk read done.</span>
            DBG(<span class="org-string">"request %d, xfered %d %s\n"</span>,disk_req.request,disk_req.xfered,APFError2Str(ctx-&gt;nErrCode));
            assert(disk_req.request==disk_req.xfered);
            g_pDiskMan-&gt;Deassociate(&amp;disk_ctx);
            close(disk_ctx.fd);
            Write(reply,reply_len,&amp;m_Req);
        }<span class="org-keyword">else</span>{
            <span class="org-constant">CSocketV</span>::OnCompletion(ctx);
        }
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    signal(SIGINT,signal_handler);
    InitKylin(2,2,disk_thread_num);
    <span class="org-type">XAsyncClient</span> <span class="org-variable-name">client</span>(0);
    client.StartServe();
    <span class="org-comment-delimiter">// </span><span class="org-comment">100ms.</span>
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span> <span class="org-variable-name">timeout</span>={0,100*1000000};
    <span class="org-keyword">while</span>(1){
        nanosleep(&amp;timeout,<span class="org-constant">NULL</span>);
        <span class="org-keyword">if</span>(AtomicGetValue(stop)==1){
            StopKylin(<span class="org-constant">true</span>);
            <span class="org-keyword">break</span>;
        }
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
