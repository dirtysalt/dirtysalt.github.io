<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Java at Speed</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">Java at Speed</h1>
<p>
<a href="https://www.infoq.com/presentations/java-jvm-perf/">https://www.infoq.com/presentations/java-jvm-perf/</a>
</p>

<p>
azul几个产品解决的问题：
</p>
<ol class="org-ol">
<li>ReadyNow 用于快速预热生成native code，并且减少de-optimization的可能性</li>
<li>Falcon 利用LLVM来生成更加优化的代码，比如利用运行机器的向量化特性</li>
<li>C4 来减少GC Pause造成的latency, 保持比如99.99%pth的latency尽可能低</li>
</ol>
<p>
组合起来就是 Start Fast, Go Fast, Stay Fast.
</p>



<div id="org142eb9f" class="figure">
<p><img src="../images/java-at-speed-azul-prod.png" alt="java-at-speed-azul-prod.png" />
</p>
</div>

<hr />

<p>
Falcon利用LLVM可以针对运行机器生成更好的指令代码
</p>


<div id="org6ae0d42" class="figure">
<p><img src="../images/java-at-speed-falcon.png" alt="java-at-speed-falcon.png" />
</p>
</div>

<hr />

<p>
JIT可以利用运行时信息生成静态编译器做不到的优化，尤其是在某个分支预测执行上，因为JIT可以根据之前运行时收集到的信息，生成更加利于运行期间的指令代码。
</p>


<div id="orge48ef1d" class="figure">
<p><img src="../images/java-at-speed-jit0.png" alt="java-at-speed-jit0.png" />
</p>
</div>


<div id="org0f8acde" class="figure">
<p><img src="../images/java-at-speed-jit1.png" alt="java-at-speed-jit1.png" />
</p>
</div>

<p>
另外JIT可以针对已经加载进来的classes进行类层次分析，如果发现某个类是final的话那么可以直接调用方法而不是虚方法，并且结合上面的预测技术，可以生成更高效的代码。比如下面代码中，如果我们可以推断出只有Dog类型实现了其他getColor, 其他类型都是直接返回color的话，那么就可以做些优化。
</p>


<div id="org9d77a2f" class="figure">
<p><img src="../images/java-at-speed-jit2.png" alt="java-at-speed-jit2.png" />
</p>
</div>

<p>
上面所有这些优化，都是在针对运行时信息收集到一定阶段(warmup)，并且某个假设成立的前提下，才会触发的。如果运行到一定阶段，发现运行轨迹和之前差别很大的话，那么才就会回退到解释器模式(de-optimization).  对于高性能程序，我们当然希望一上来就进行warmup, 很快时间就进入到native模式，但是很可能我们收集的信息和真实运行环境差别很大，导致刚开始是native模式，但是很快又触发了de-optimization.
</p>


<div id="org2054f7e" class="figure">
<p><img src="../images/java-at-speed-jit3.png" alt="java-at-speed-jit3.png" />
</p>
</div>


<div id="orgef5fb64" class="figure">
<p><img src="../images/java-at-speed-jit4.png" alt="java-at-speed-jit4.png" />
</p>
</div>

<p>
设想一个高频交易程序，我们使用fake message的方式来warmup, 但是当真正进行交易的时候，其实是没有走fake message path的，实际情况就如下图。ReadyNow我理解应该是可以收集和利用真实的线上运行程序信息来做warmup, 确保不会出现deoptimization情况
</p>


<div id="org1b452dd" class="figure">
<p><img src="../images/java-at-speed-jit5.png" alt="java-at-speed-jit5.png" />
</p>
</div>


<div id="orgff4c4e7" class="figure">
<p><img src="../images/java-at-speed-jit6.png" alt="java-at-speed-jit6.png" />
</p>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/java-at-speed.html';this.page.identifier = 'java-at-speed.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
