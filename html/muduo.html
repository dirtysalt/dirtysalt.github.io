<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>muduo</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="dirtysalt" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content">
<h1 class="title">muduo</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga003e1b">1. base</a></li>
<li><a href="#orgb5c727a">2. Buffer</a></li>
<li><a href="#org08d0936">3. Channel</a></li>
<li><a href="#orgbc5e99d">4. Poller</a></li>
<li><a href="#orgf8e9e01">5. EventLoop</a>
<ul>
<li><a href="#org0280d05">5.1. 单线程单EventLoop</a></li>
<li><a href="#org2774a37">5.2. 跨线程激活</a></li>
<li><a href="#org8d76244">5.3. 跨线程任务</a></li>
<li><a href="#org048a1e8">5.4. 定时器任务</a></li>
<li><a href="#org8255d51">5.5. How it works</a></li>
</ul>
</li>
<li><a href="#org123ab11">6. TimerQueue</a></li>
<li><a href="#org3159e89">7. EventLoopThread</a></li>
<li><a href="#org3b1c6b0">8. Acceptor</a></li>
<li><a href="#org767d458">9. Connector</a></li>
<li><a href="#org69b5170">10. TcpConnection</a></li>
<li><a href="#org9cee65d">11. TcpClient</a></li>
<li><a href="#org6156a16">12. TcpServer</a></li>
</ul>
</div>
</div>
<p>
<a href="http://code.google.com/p/muduo/">http://code.google.com/p/muduo/</a>
</p>

<p>
在分析muduo之前必须了解一下作者的想法：<a href="http://www.cnblogs.com/Solstice/archive/2010/08/29/muduo_net_lib.html">http://www.cnblogs.com/Solstice/archive/2010/08/29/muduo_net_lib.html</a>
</p>
<ul class="org-ul">
<li>线程安全，支持多核多线程</li>
<li>不考虑可移植性，不跨平台，只支持 Linux，不支持 Windows。 // 支持Windows有时候代价太大了</li>
<li>在不增加复杂度的前提下可以支持 FreeBSD/Darwin，方便将来用 Mac 作为开发用机，但不为它做性能优化。也就是说 IO multiplexing 使用 poll 和 epoll。</li>
<li>主要支持 x86-64，兼顾 IA32</li>
<li>不支持 UDP，只支持 TCP</li>
<li>不支持 IPv6，只支持 IPv4</li>
<li>不考虑广域网应用，只考虑局域网 // 不会存在慢连接，所以即使是阻塞读也不会花去太长时间用在阻塞上面</li>
<li>只支持一种使用模式：non-blocking IO + one event loop per thread，不考虑阻塞 IO</li>
<li>API 简单易用，只暴露具体类和标准库里的类，不使用 non-trivial templates，也不使用虚函数 // GP而非OO</li>
<li>只满足常用需求的 90%，不面面俱到，必要的时候以 app 来适应 lib</li>
<li>只做 library，不做成 framework</li>
<li>争取全部代码在 5000 行以内（不含测试）</li>
<li>以上条件都满足时，可以考虑搭配 Google Protocol Buffers RPC // RPC可以简化很多东西</li>
</ul>
<p>
muduo使用了很多新的Linux内核特性，包括使用signalfd和timerfd来触发信号以及定时器，所以代码上相对于于hpserver好看很多了。但是里面使用了boost::bind以及boost一些东西，
因为个人对于这个部分不是很清楚，所以很多地方并不是非常理解。muduo和hpserver一样也引入了很多概念，了解这些概念也非常有帮助。muduo做了线程管理，但是仅仅做了event loop
的线程管理，没有做工作线程的管理。所以工作线程还是需要自己管理。异步队列在base目录下面也实现了。所以基本上可以认为muduo里面包含了很多网络编程框架需要的组件。
muduo将hpserver下面的event item和event handler以及handle都在一起，称之为Channel.而Reactor在这里称为EventLoop.所以可以认为相对于hpserver,类层次结构好理解多了。
</p>

<div id="outline-container-orga003e1b" class="outline-2">
<h2 id="orga003e1b"><span class="section-number-2">1</span> base</h2>
<div class="outline-text-2" id="text-1">
<p>
base下面都是一些关于多线程编程方面需要使用的组件
<a href="http://www.cnblogs.com/Solstice/archive/2010/08/21/muduo_thread_lib.html">http://www.cnblogs.com/Solstice/archive/2010/08/21/muduo_thread_lib.html</a>
包括下面这些文件：
</p>
<ul class="org-ul">
<li>Atomic.h // 原子操作，里面的CAS没有使用汇编而是使用__sync_val_compare_and_swap这个GCC内置函数</li>
<li>BlockingQueue.h // 异步队列，底层使用std::deque来实现，没有大小限制</li>
<li>BoundedBlockingQueue.h // 异步队列，但是使用循环数组来实现，有大小限制</li>
<li>Condition.h // pthread_cond封装</li>
<li>CountDownLatch.h // 可以用作类似于起跑线机制，值得学习一下</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">CountDownLatch</span>::<span class="org-function-name">wait</span>() <span class="org-comment-delimiter">// </span><span class="org-comment">latchdown&#20043;&#21518;&#28982;&#21518;&#35843;&#29992;wait.&#31561;&#24453;&#26368;&#21518;&#19968;&#20010;&#32447;&#31243;notifyAll,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#22810;&#20010;&#32447;&#31243;&#21516;&#26102;&#35299;&#38500;&#38145;&#23450;&#23601;&#21487;&#20197;&#21516;&#26102;&#24320;&#22987;&#25191;&#34892;&#20102;</span>
{
    <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
    <span class="org-keyword">while</span> (count_ &gt; 0) {
        condition_.wait();
    }
}

<span class="org-type">void</span> <span class="org-constant">CountDownLatch</span>::<span class="org-function-name">countDown</span>() <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32447;&#31243;&#22312;&#24320;&#22987;&#37117;latchdown,&#26368;&#21518;&#19968;&#20010;&#32447;&#31243;&#20250;notifyAll</span>
{
    <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
    --count_;
    <span class="org-keyword">if</span> (count_ == 0) {
        condition_.notifyAll();
    }
}
</pre>
</div>
<ul class="org-ul">
<li>Logging.h // 日志</li>
<li>Mutex.h // 互斥锁</li>
<li>ProcessInfo.h // 进程信息</li>
<li>Singleton.h // 单例模式，实现上比较有特色</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">T</span>&amp; <span class="org-function-name">instance</span>()
{
  pthread_once(&amp;ponce_, &amp;<span class="org-constant">Singleton</span>::init); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;pthread_once&#26469;&#36827;&#34892;&#26500;&#36896;</span>
  <span class="org-keyword">return</span> *value_;
}
</pre>
</div>
<ul class="org-ul">
<li>Thread.h // 线程封装,内部有一个static变量记录当前创建了多少个线程</li>
<li>ThreadLocal.h // 线程局部变量封装，不用在使用pthread_get/setspecific</li>
<li>ThreadLocalSignleton.h // 线程局部单例，不用考虑多个线程同时创建</li>
<li>ThreadPool.h // 线程池包装，内部维护了一个异步队列，多个线程的工作就是取出task来执行</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22806;&#37096;&#20002;&#20837;Task&#25918;&#21040;&#32447;&#31243;&#27744;&#20869;&#37096;</span>
<span class="org-type">void</span> <span class="org-constant">ThreadPool</span>::<span class="org-function-name">run</span>(<span class="org-keyword">const</span> <span class="org-type">Task</span>&amp; <span class="org-variable-name">task</span>)
{
  <span class="org-keyword">if</span> (threads_.empty()) <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#20219;&#20309;&#32447;&#31243;</span>
  {
    task();
  }
  <span class="org-keyword">else</span>
  {
    <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
    queue_.push_back(task);
    cond_.notify();
  }
}
<span class="org-constant">ThreadPool</span>::<span class="org-type">Task</span> <span class="org-constant">ThreadPool</span>::<span class="org-function-name">take</span>()
{
  <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
  <span class="org-keyword">while</span> (queue_.empty() &amp;&amp; running_)
  {
    cond_.wait();
  }
  <span class="org-type">Task</span> <span class="org-variable-name">task</span>;
  <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>queue_.empty())
  {
    task = queue_.front();
    queue_.pop_front();
  }
  <span class="org-keyword">return</span> task;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">&#32447;&#31243;&#22238;&#35843;&#20989;&#25968;</span>
<span class="org-type">void</span> <span class="org-constant">ThreadPool</span>::<span class="org-function-name">runInThread</span>()
{
  <span class="org-keyword">try</span>
  {
    <span class="org-keyword">while</span> (running_)
    {
      <span class="org-type">Task</span> <span class="org-variable-name">task</span>(take());
      <span class="org-keyword">if</span> (task)
      {
        task();
      }
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5c727a" class="outline-2">
<h2 id="orgb5c727a"><span class="section-number-2">2</span> Buffer</h2>
<div class="outline-text-2" id="text-2">
<p>
Buffer设计的非常精巧。Buffer内部是一个std::vector&lt;char*&gt;表示的，逻辑上结构是这样的
</p>
<pre class="example">
/// @code
/// +-------------------+------------------+------------------+
/// | prependable bytes |  readable bytes  |  writable bytes  |
/// |                   |     (CONTENT)    |                  |
/// +-------------------+------------------+------------------+
/// |                   |                  |                  |
/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size
/// @endcode
</pre>
<p>
头部有prependable bytes这个似乎可以不要，内部是占用8个字节，初始化的时候size占用了1024+8个字节。初始的时候readerIndex==writerIndex==8,
就好比现在没有任何数据写入。一旦开始要写入数据的话，那么writerIndex+=size(要写入的字节数)这个buffer会动态地增长。readerIndex标记的就是我们
可以读的下标，如果readerIndex==writerIndex就表示没有数据了。但是很明显这个Buffer并不是无限增长的，在makeSpace函数里面的话就可以看到，实际上
是会进行压缩的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">makeSpace</span>(<span class="org-type">size_t</span> <span class="org-variable-name">len</span>)
{
    <span class="org-keyword">if</span> (writableBytes() + prependableBytes() &lt; len + kCheapPrepend) <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24403;&#21069;&#19981;&#33021;&#22815;&#36890;&#36807;&#21387;&#32553;&#21512;&#24182;&#30340;&#35805;</span>
    {
        buffer_.resize(writerIndex_+len);
    }
    <span class="org-keyword">else</span>
    {
        <span class="org-comment-delimiter">// </span><span class="org-comment">move readable data to the front, make space inside buffer</span>
        assert(kCheapPrepend &lt; readerIndex_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21487;&#20197;&#21387;&#32553;&#30340;&#35805;&#37027;&#20040;&#23601;&#21387;&#32553;</span>
        <span class="org-type">size_t</span> <span class="org-variable-name">readable</span> = readableBytes();
        <span class="org-constant">std</span>::copy(begin()+readerIndex_,
                  begin()+writerIndex_,
                  begin()+kCheapPrepend);
        readerIndex_ = kCheapPrepend;
        writerIndex_ = readerIndex_ + readable;
        assert(readable == readableBytes());
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org08d0936" class="outline-2">
<h2 id="org08d0936"><span class="section-number-2">3</span> Channel</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Channel</span> : <span class="org-constant">boost</span>::<span class="org-type">noncopyable</span>
{
  <span class="org-keyword">public</span>:
    <span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-type">function</span>&lt;<span class="org-type">void</span>()&gt; <span class="org-type">EventCallback</span>;
    <span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-type">function</span>&lt;<span class="org-type">void</span>(<span class="org-variable-name">Timestamp</span>)&gt; <span class="org-type">ReadEventCallback</span>;
    <span class="org-type">void</span> <span class="org-function-name">handleEvent</span>(<span class="org-type">Timestamp</span> <span class="org-variable-name">receiveTime</span>);
  <span class="org-keyword">private</span>:
    <span class="org-type">EventLoop</span>* <span class="org-variable-name">loop_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23646;&#20110;&#21738;&#19968;&#20010;Reactor</span>
    <span class="org-keyword">const</span> <span class="org-type">int</span>  <span class="org-variable-name">fd_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#32852;fd</span>
    <span class="org-type">int</span>        <span class="org-variable-name">events_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#27880;&#20107;&#20214;</span>
    <span class="org-type">int</span>        <span class="org-variable-name">revents_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ready&#20107;&#20214;</span>
    <span class="org-type">int</span>        <span class="org-variable-name">index_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">used by Poller. &#22312;Poller&#20013;&#30340;&#32534;&#21495;&#65292;&#23454;&#38469;&#19978;&#27809;&#26377;&#29305;&#21035;&#24847;&#24605;</span>

    <span class="org-constant">boost</span>::<span class="org-type">weak_ptr</span>&lt;<span class="org-type">void</span>&gt; <span class="org-variable-name">tie_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32465;&#23450;&#30340;&#23545;&#35937;&#65292;&#36825;&#20010;&#23545;&#20110;boost::weak_ptr&#19981;&#26159;&#24456;&#20102;&#35299;&#65292;&#20294;&#26159;&#36825;&#20010;&#23545;&#20110;&#29702;&#35299;&#26694;&#26550;&#27809;&#26377;&#29992;&#36884;</span>
    <span class="org-type">bool</span> <span class="org-variable-name">tied_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#32465;&#23450;&#20102;&#23545;&#35937;&#19978;&#26469;</span>
    <span class="org-type">bool</span> <span class="org-variable-name">eventHandling_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#27491;&#22312;&#22788;&#29702;event</span>
    <span class="org-type">ReadEventCallback</span> <span class="org-variable-name">readCallback_</span>;
    <span class="org-type">EventCallback</span> <span class="org-variable-name">writeCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#22914;&#20309;&#20889;&#25968;&#25454;</span>
    <span class="org-type">EventCallback</span> <span class="org-variable-name">closeCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#22914;&#20309;&#20851;&#38381;&#36830;&#25509;</span>
    <span class="org-type">EventCallback</span> <span class="org-variable-name">errorCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#22914;&#26524;&#20986;&#38169;&#30340;&#35805;&#22914;&#20309;&#22788;&#29702;</span>
};
</pre>
</div>
<p>
一旦EventLoop通知Channel触发事件的话那么就会调用handleEvent这个函数。参数receiveTime本身只对ReadEventCallback有效并且作为参数使用，
代表接收超时时间，对于write而言的话没有超时时间。内部的话handleEvent会根据revents触发的事件来分别决定调用哪些回调
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Channel</span>::<span class="org-function-name">handleEventWithGuard</span>(<span class="org-type">Timestamp</span> <span class="org-variable-name">receiveTime</span>)
{
    eventHandling_ = <span class="org-constant">true</span>;
    <span class="org-keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; <span class="org-negation-char">!</span>(revents_ &amp; POLLIN))
    {
        LOG_WARN &lt;&lt; <span class="org-string">"Channel::handle_event() POLLHUP"</span>;
        <span class="org-keyword">if</span> (closeCallback_) closeCallback_();
    }
    <span class="org-keyword">if</span> (revents_ &amp; POLLNVAL)
    {
        LOG_WARN &lt;&lt; <span class="org-string">"Channel::handle_event() POLLNVAL"</span>;
    }
    <span class="org-keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL))
    {
        <span class="org-keyword">if</span> (errorCallback_) errorCallback_();
    }
    <span class="org-keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))
    {
        <span class="org-keyword">if</span> (readCallback_) readCallback_(receiveTime);
    }
    <span class="org-keyword">if</span> (revents_ &amp; POLLOUT)
    {
        <span class="org-keyword">if</span> (writeCallback_) writeCallback_();
    }
    eventHandling_ = <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc5e99d" class="outline-2">
<h2 id="orgbc5e99d"><span class="section-number-2">4</span> Poller</h2>
<div class="outline-text-2" id="text-4">
<p>
Poller本身也是一个抽象类，然后底层支持poll和epoll.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Poller</span> : <span class="org-constant">boost</span>::<span class="org-type">noncopyable</span>
{
  <span class="org-keyword">public</span>:
    <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">Channel</span>*&gt; <span class="org-type">ChannelList</span>;
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Polls the I/O events.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Must be called in the loop thread.</span>
    <span class="org-keyword">virtual</span> <span class="org-type">Timestamp</span> <span class="org-function-name">poll</span>(<span class="org-type">int</span> <span class="org-variable-name">timeoutMs</span>, <span class="org-type">ChannelList</span>* <span class="org-variable-name">activeChannels</span>) = 0;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36827;&#34892;poll&#25805;&#20316;&#65292;&#27963;&#36291;&#20107;&#20214;&#25918;&#22312;activeChannels&#37324;&#38754;</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Changes the interested I/O events.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Must be called in the loop thread.</span>
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">updateChannel</span>(<span class="org-type">Channel</span>* <span class="org-variable-name">channel</span>) = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;channel</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Remove the channel, when it destructs.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Must be called in the loop thread.</span>
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">removeChannel</span>(<span class="org-type">Channel</span>* <span class="org-variable-name">channel</span>) = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;channel</span>
  <span class="org-keyword">private</span>:
    <span class="org-type">EventLoop</span>* <span class="org-variable-name">ownerLoop_</span>;
};
</pre>
</div>
<p>
在poller目录下面有poll和epoll的对应实现，不过我们这里没有必要仔细阅读。需要注意的是这里的channel处理并没有引入优先级的概念。
poll操作的timeoutMs就是epoll_wait超时时间，而activeChannels就是活跃channel.返回值就是epoll_wait之后的时间戳。
</p>
</div>
</div>

<div id="outline-container-orgf8e9e01" class="outline-2">
<h2 id="orgf8e9e01"><span class="section-number-2">5</span> EventLoop</h2>
<div class="outline-text-2" id="text-5">
<p>
和之前一样，我们还是看看EventLoop有哪些结构。对于EventLoop结构比较复杂，我们列出主要的接口和成员。
首先我们看EventLoop有runInLoop和queueInLoop功能，虽然作者建议event loop和一个线程绑定，但是在其他线程的话依然可以调用runInLoop和
queueInLoop的功能，将一些task加入到这个event loop对应的线程中执行。这样就很地然地引入了pendingFunctors字段。因为需要跨线程激活，
那么就需要线程之间的通知机制，这个使用eventfd来完成，对应字段就是wakeFd并且内部绑定了一个wakeupChannel.如果没有eventfd的话，通常也可以使用
pipe来完成。然后我们还允许向EventLoop里面添加定时器任务，就是runAt,runAfter和runEvery三个函数，我们只需要关注其中一个即可。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">EventLoop</span> : <span class="org-constant">boost</span>::<span class="org-type">noncopyable</span>
{
  <span class="org-keyword">public</span>:
    <span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-type">function</span>&lt;<span class="org-type">void</span>()&gt; <span class="org-type">Functor</span>;
    <span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-type">function</span>&lt;<span class="org-type">void</span>()&gt; <span class="org-type">TimerCallback</span>;
    <span class="org-type">void</span> <span class="org-function-name">loop</span>();
    <span class="org-type">void</span> <span class="org-function-name">quit</span>();
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Runs callback immediately in the loop thread.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">It wakes up the loop, and run the cb.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">If in the same loop thread, cb is run within the function.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Safe to call from other threads.</span>
    <span class="org-type">void</span> <span class="org-function-name">runInLoop</span>(<span class="org-keyword">const</span> <span class="org-type">Functor</span>&amp; <span class="org-variable-name">cb</span>);
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Queues callback in the loop thread.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Runs after finish pooling.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Safe to call from other threads.</span>
    <span class="org-type">void</span> <span class="org-function-name">queueInLoop</span>(<span class="org-keyword">const</span> <span class="org-type">Functor</span>&amp; <span class="org-variable-name">cb</span>);

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Runs callback at 'time'.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Safe to call from other threads.</span>
    <span class="org-comment-delimiter">///</span>
    <span class="org-type">TimerId</span> <span class="org-function-name">runAt</span>(<span class="org-keyword">const</span> <span class="org-type">Timestamp</span>&amp; <span class="org-variable-name">time</span>, <span class="org-keyword">const</span> <span class="org-type">TimerCallback</span>&amp; <span class="org-variable-name">cb</span>);
    <span class="org-comment-delimiter">///</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Runs callback after @c delay seconds.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Safe to call from other threads.</span>
    <span class="org-comment-delimiter">///</span>
    <span class="org-type">TimerId</span> <span class="org-function-name">runAfter</span>(<span class="org-type">double</span> <span class="org-variable-name">delay</span>, <span class="org-keyword">const</span> <span class="org-type">TimerCallback</span>&amp; <span class="org-variable-name">cb</span>);
    <span class="org-comment-delimiter">///</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Runs callback every @c interval seconds.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Safe to call from other threads.</span>
    <span class="org-comment-delimiter">///</span>
    <span class="org-type">TimerId</span> <span class="org-function-name">runEvery</span>(<span class="org-type">double</span> <span class="org-variable-name">interval</span>, <span class="org-keyword">const</span> <span class="org-type">TimerCallback</span>&amp; <span class="org-variable-name">cb</span>);
    <span class="org-comment-delimiter">///</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Cancels the timer.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Safe to call from other threads.</span>
    <span class="org-comment-delimiter">///</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">void cancel(TimerId timerId);</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">internal usage</span>
    <span class="org-type">void</span> <span class="org-function-name">wakeup</span>();
    <span class="org-type">void</span> <span class="org-function-name">updateChannel</span>(<span class="org-type">Channel</span>* <span class="org-variable-name">channel</span>);
    <span class="org-type">void</span> <span class="org-function-name">removeChannel</span>(<span class="org-type">Channel</span>* <span class="org-variable-name">channel</span>);
    <span class="org-type">bool</span> <span class="org-function-name">isInLoopThread</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> threadId_ == <span class="org-constant">CurrentThread</span>::tid(); }
  <span class="org-keyword">private</span>:
    <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">Channel</span>*&gt; <span class="org-type">ChannelList</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">looping_</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">atomic */</span>
    <span class="org-type">bool</span> <span class="org-variable-name">quit_</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">atomic */</span>
    <span class="org-type">bool</span> <span class="org-variable-name">eventHandling_</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">atomic */</span>
    <span class="org-type">bool</span> <span class="org-variable-name">callingPendingFunctors_</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">atomic */</span>
    <span class="org-keyword">const</span> <span class="org-type">pid_t</span> <span class="org-variable-name">threadId_</span>;
    <span class="org-type">Timestamp</span> <span class="org-variable-name">pollReturnTime_</span>;
    <span class="org-constant">boost</span>::<span class="org-type">scoped_ptr</span>&lt;Poller&gt; <span class="org-variable-name">poller_</span>;
    <span class="org-constant">boost</span>::<span class="org-type">scoped_ptr</span>&lt;TimerQueue&gt; <span class="org-variable-name">timerQueue_</span>;
    <span class="org-type">int</span> <span class="org-variable-name">wakeupFd_</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">unlike in TimerQueue, which is an internal class,</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">we don't expose Channel to client.</span>
    <span class="org-constant">boost</span>::<span class="org-type">scoped_ptr</span>&lt;<span class="org-type">Channel</span>&gt; <span class="org-variable-name">wakeupChannel_</span>;
    <span class="org-type">ChannelList</span> <span class="org-variable-name">activeChannels_</span>;
    <span class="org-type">MutexLock</span> <span class="org-variable-name">mutex_</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">Functor</span>&gt; <span class="org-variable-name">pendingFunctors_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">@BuardedBy mutex_</span>
};
</pre>
</div>
</div>

<div id="outline-container-org0280d05" class="outline-3">
<h3 id="org0280d05"><span class="section-number-3">5.1</span> 单线程单EventLoop</h3>
<div class="outline-text-3" id="text-5-1">
<p>
作者建议一个线程绑定一个EventLoop,这个实现呢？其实还是使用线程局部变量。首先定义线程局部变量
</p>
<div class="org-src-container">
<pre class="src src-C++">__thread <span class="org-type">EventLoop</span>* <span class="org-variable-name">t_loopInThisThread</span> = 0;
</pre>
</div>
<p>
然后在EventLoop构造函数的时候判断这个是否==0,如果不为=0的话说明在这个线程已经构造过一个EventLoop了。
直接使用__thread这个关键字，值得学习一下。
</p>
</div>
</div>

<div id="outline-container-org2774a37" class="outline-3">
<h3 id="org2774a37"><span class="section-number-3">5.2</span> 跨线程激活</h3>
<div class="outline-text-3" id="text-5-2">
<p>
首先我们看看跨线程激活是怎么操作的。在EventLoop的初始化函数内部初始化了wakeupFd并且创建了channel.但是如果不仔细阅读，
很可能觉得的这个channel没有注册。而实际上这个channel在enableReading()就会注册的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">EventLoop</span>::<span class="org-function-name">EventLoop</span>()
  : wakeupFd_(createEventfd()),
    wakeupChannel_(<span class="org-keyword">new</span> <span class="org-type">Channel</span>(<span class="org-keyword">this</span>, wakeupFd_))
{
  wakeupChannel_-&gt;setReadCallback(
      <span class="org-constant">boost</span>::bind(&amp;<span class="org-constant">EventLoop</span>::handleRead, <span class="org-keyword">this</span>)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#32465;&#23450;&#21040;handleRead&#19978;&#38754;&#20102;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we are always reading the wakeupfd</span>
  wakeupChannel_-&gt;enableReading();
}
#+END_SRC C++
&#36328;&#32447;&#31243;&#28608;&#27963;&#30340;&#20989;&#25968;&#26159;wakeUp.&#25105;&#20204;&#30475;&#30475;&#24590;&#20040;&#23454;&#29616;
#+BEGIN_SRC C++
<span class="org-type">void</span> <span class="org-constant">EventLoop</span>::wakeup()
{
  <span class="org-type">uint64_t</span> <span class="org-variable-name">one</span> = 1;
  <span class="org-type">ssize_t</span> <span class="org-variable-name">n</span> = <span class="org-constant">sockets</span>::write(wakeupFd_, &amp;one, <span class="org-keyword">sizeof</span> one); <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#20284;&#20110;&#31649;&#36947;&#30452;&#25509;&#20889;</span>
}
</pre>
</div>
<p>
一旦wakeup完成之后那么wakeUpFd_就是可读的，这样EventLoop就会被通知到并且立刻跳出epoll_wait开始处理。当然我们需要将这个wakeupFd_
上面数据读出来，不然的话下一次又会被通知到，读取函数就是handleRead
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">EventLoop</span>::<span class="org-function-name">handleRead</span>()
{
  <span class="org-type">uint64_t</span> <span class="org-variable-name">one</span> = 1;
  <span class="org-type">ssize_t</span> <span class="org-variable-name">n</span> = <span class="org-constant">sockets</span>::read(wakeupFd_, &amp;one, <span class="org-keyword">sizeof</span> one);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d76244" class="outline-3">
<h3 id="org8d76244"><span class="section-number-3">5.3</span> 跨线程任务</h3>
<div class="outline-text-3" id="text-5-3">
<p>
runInLoop和queueInLoop就是跨线程任务。内容非常简单
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">EventLoop</span>::<span class="org-function-name">runInLoop</span>(<span class="org-keyword">const</span> <span class="org-type">Functor</span>&amp; <span class="org-variable-name">cb</span>){
  <span class="org-keyword">if</span> (isInLoopThread()){ <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36825;&#20010;&#20989;&#25968;&#22312;&#33258;&#24049;&#30340;&#32447;&#31243;&#35843;&#29992;&#65292;&#37027;&#20040;&#23601;&#21487;&#20197;&#31435;&#21363;&#25191;&#34892;</span>
    cb();
  }<span class="org-keyword">else</span>{
    queueInLoop(cb); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#20854;&#20182;&#32447;&#31243;&#35843;&#29992;&#65292;&#37027;&#20040;&#21152;&#20837;&#21040;pendingFunctors&#37324;&#38754;&#21435;</span>
    wakeup(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#36890;&#30693;&#36825;&#20010;&#32447;&#31243;&#65292;&#26377;&#20219;&#21153;&#21040;&#26469;</span>
  }
}

<span class="org-type">void</span> <span class="org-constant">EventLoop</span>::<span class="org-function-name">queueInLoop</span>(<span class="org-keyword">const</span> <span class="org-type">Functor</span>&amp; <span class="org-variable-name">cb</span>){
  {
  <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
  pendingFunctors_.push_back(cb);
  }
  <span class="org-keyword">if</span> (isInLoopThread() &amp;&amp; callingPendingFunctors_){
    wakeup(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#34987;&#25490;&#19978;&#38431;&#20043;&#21518;&#22914;&#26524;&#26159;&#22312;&#33258;&#24049;&#32447;&#31243;&#24182;&#19988;&#27491;&#22312;&#25191;&#34892;pendingFunctors&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#21487;&#20197;&#28608;&#27963;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#19979;&#19968;&#36718;&#23436;&#20840;&#21487;&#20197;&#34987;&#25490;&#19978;&#65292;&#25152;&#20197;&#27809;&#26377;&#24517;&#35201;&#28608;&#27963;</span>
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org048a1e8" class="outline-3">
<h3 id="org048a1e8"><span class="section-number-3">5.4</span> 定时器任务</h3>
<div class="outline-text-3" id="text-5-4">
<p>
定时器任务都是交给了TimerQueue来处理的，在TimerQueue这个部分我们会简要地分析一下
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">TimerId</span> <span class="org-constant">EventLoop</span>::<span class="org-function-name">runAt</span>(<span class="org-keyword">const</span> <span class="org-type">Timestamp</span>&amp; <span class="org-variable-name">time</span>, <span class="org-keyword">const</span> <span class="org-type">TimerCallback</span>&amp; <span class="org-variable-name">cb</span>)
{
  <span class="org-keyword">return</span> timerQueue_-&gt;addTimer(cb, time, 0.0); <span class="org-comment-delimiter">// </span><span class="org-comment">time&#26159;&#22312;&#20043;&#21518;&#20160;&#20040;&#26102;&#20505;&#24320;&#22987;&#65292;0.0&#34920;&#31034;&#20197;&#21518;&#27599;&#27425;&#36816;&#34892;&#26102;&#38388;(0.0&#34920;&#31034;&#19981;&#20250;repeat).</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8255d51" class="outline-3">
<h3 id="org8255d51"><span class="section-number-3">5.5</span> How it works</h3>
<div class="outline-text-3" id="text-5-5">
<p>
基本上和hpserver非常相似，不断地调用poller::poll方法，然后在外层不断地查看是否需要quit.poll之后会得到activeChannels.和hpserver不同的是，
muduo没有调用器(其实也不需要，本来就没有优先级概念)，仅仅遍历这个activeChannels，并且调用内部的handleEvent方法，然后在调用pengdingFunctors
一些跨线程任务。
</p>
</div>
</div>
</div>

<div id="outline-container-org123ab11" class="outline-2">
<h2 id="org123ab11"><span class="section-number-2">6</span> TimerQueue</h2>
<div class="outline-text-2" id="text-6">
<p>
TimerQueue里面最主要的方法就是addTimer.我们看看addTimer里面做了哪些事情，整个过程有点绕
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">TimerId</span> <span class="org-constant">TimerQueue</span>::<span class="org-function-name">addTimer</span>(<span class="org-keyword">const</span> <span class="org-type">TimerCallback</span>&amp; <span class="org-variable-name">cb</span>,
                             <span class="org-type">Timestamp</span> <span class="org-variable-name">when</span>,
                             <span class="org-type">double</span> <span class="org-variable-name">interval</span>)
{
  <span class="org-type">Timer</span>* <span class="org-variable-name">timer</span> = <span class="org-keyword">new</span> <span class="org-type">Timer</span>(cb, when, interval); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#21019;&#24314;&#19968;&#20010;Timer&#23545;&#35937;&#65292;&#28982;&#21518;&#23558;cb&#25918;&#22312;&#37324;&#38754;&#12290;&#20869;&#37096;&#26377;&#19968;&#20010;run&#20989;&#25968;&#65292;&#35843;&#29992;&#30340;&#23601;&#26159;cb</span>
  loop_-&gt;runInLoop(
      <span class="org-constant">boost</span>::bind(&amp;<span class="org-constant">TimerQueue</span>::scheduleInLoop, <span class="org-keyword">this</span>, timer)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;&#36825;&#20010;timer&#20002;&#21040;eventLoop&#37324;&#38754;&#21435;&#25191;&#34892;</span>
  <span class="org-keyword">return</span> TimerId(timer, timer-&gt;sequence());
}
<span class="org-type">void</span> <span class="org-constant">TimerQueue</span>::<span class="org-function-name">scheduleInLoop</span>(<span class="org-type">Timer</span>* <span class="org-variable-name">timer</span>)
{
  loop_-&gt;assertInLoopThread();
  <span class="org-type">bool</span> <span class="org-variable-name">earliestChanged</span> = insert(timer); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;timer&#25554;&#20837;&#21040;&#20869;&#37096;&#30340;&#38142;&#34920;&#37324;&#38754;&#21435;&#65292;&#25353;&#29031;&#36229;&#26102;&#26102;&#38388;&#39034;&#24207;&#25554;&#20837;&#65292;&#24182;&#19988;&#21028;&#26029;&#36825;&#20010;&#25554;&#20837;&#26159;&#21542;&#20250;&#24433;&#21709;&#26368;&#26089;&#26102;&#38388;</span>

  <span class="org-keyword">if</span> (earliestChanged)
  {
    resetTimerfd(timerfd_, timer-&gt;expiration()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24433;&#21709;&#30340;&#35805;&#65292;&#37027;&#20040;&#35201;&#20462;&#25913;&#36825;&#20010;timerfd&#36229;&#26102;&#26102;&#38388;&#12290;</span>
  }
}
</pre>
</div>
<p>
然后一旦timerfd可读的时候，就会调用下面这个函数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TimerQueue</span>::<span class="org-function-name">handleRead</span>()
{
  loop_-&gt;assertInLoopThread();
  <span class="org-type">Timestamp</span> <span class="org-variable-name">now</span>(<span class="org-constant">Timestamp</span>::now());
  readTimerfd(timerfd_, now);
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;Entry&gt; <span class="org-variable-name">expired</span> = getExpired(now); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#21487;&#20197;&#30693;&#36947;&#26377;&#21738;&#20123;&#35745;&#26102;&#22120;&#36229;&#26102;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">safe to callback outside critical section</span>
  <span class="org-keyword">for</span> (<span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;Entry&gt;::<span class="org-type">iterator</span> <span class="org-variable-name">it</span> = expired.begin();
      it != expired.end(); ++it)
  {
    it-&gt;second-&gt;run(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#36825;&#20123;&#36229;&#26102;&#30340;Timer,&#25191;&#34892;run()&#20989;&#25968;&#65292;&#23545;&#24212;&#20063;&#23601;&#26159;&#25105;&#20204;&#19968;&#24320;&#22987;&#27880;&#20876;&#30340;&#22238;&#35843;&#20989;&#25968;&#12290;</span>
  }
  reset(expired, now);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3159e89" class="outline-2">
<h2 id="org3159e89"><span class="section-number-2">7</span> EventLoopThread</h2>
<div class="outline-text-2" id="text-7">
<p>
EventLoopThread就是将一个EventLoop和Thread包装在一起的对象。这个内容到没有什么，不过觉得代码方面有点技巧。
我们在启动startLoop这个样就会执行线程threadFunc,但是我们必须等待threadFunc将栈上面的EventLoop绑定之后才可以返回，所以这里用到了条件变量。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">EventLoop</span>* <span class="org-constant">EventLoopThread</span>::<span class="org-function-name">startLoop</span>(){
    thread_.start();
    {
        <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
        <span class="org-keyword">while</span> (loop_ == <span class="org-constant">NULL</span>)
        {
            cond_.wait();
        }
    }
    <span class="org-keyword">return</span> loop_;
}

<span class="org-type">void</span> <span class="org-constant">EventLoopThread</span>::<span class="org-function-name">threadFunc</span>(){
    <span class="org-type">EventLoop</span> <span class="org-variable-name">loop</span>;
    {
        <span class="org-type">MutexLockGuard</span> <span class="org-variable-name">lock</span>(mutex_);
        loop_ = &amp;loop;
        cond_.notify();
    }
    loop.loop();
}
</pre>
</div>
<p>
而EventLoopThreadPool就是维持一个EventLoopThread线程池，所以没有什么特别好说的。我们只需要setThreadNum告诉开多少个线程，然后调用start即可。
</p>
</div>
</div>

<div id="outline-container-org3b1c6b0" class="outline-2">
<h2 id="org3b1c6b0"><span class="section-number-2">8</span> Acceptor</h2>
<div class="outline-text-2" id="text-8">
<p>
Acceptor帮助简化了搭建服务器accept这个部分的逻辑。通常这个逻辑是在单个线程里面完成的，所以抽取出来蛮有必要的。
代码不是很麻烦，用户要做的就是编写一个回调，这个回调在新建立连接时候出发，参数分别是链接fd和连接地址。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-type">function</span>&lt;<span class="org-type">void</span> (<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">const</span> <span class="org-type">InetAddress</span>&amp;)&gt; <span class="org-type">NewConnectionCallback</span>;
</pre>
</div>
<p>
原理很简单，初始化socket和对应的channel并且监听READ事件，然后开始进行listen.一旦触发read事件的话那么就证明我们无阻塞
地进行accept，然后在READ事件回调里面进行accept。一旦accept成功的话就调用这个回调函数即可。
</p>
</div>
</div>

<div id="outline-container-org767d458" class="outline-2">
<h2 id="org767d458"><span class="section-number-2">9</span> Connector</h2>
<div class="outline-text-2" id="text-9">
<p>
Connector也是为了简化客户端编写，用户只需要提供这个逻辑即可，这个回调函数在建立链接成功的时候使用
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-type">function</span>&lt;<span class="org-type">void</span> (<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>)&gt; <span class="org-type">NewConnectionCallback</span>;
</pre>
</div>
<p>
Connector初始化以EventLoop和服务器地址初始化，然后在start的时候的话开始尝试进行connect.如果返回非阻塞的错误码的话，那么
创建一个channel并且监视WRITE和ERROR事件，否则就会尝试重连(按照一定时间间隔).在Connector::handleWrite里面的话会将这个channel
移除，然后调用NewConnectionCallback来处理连接建立的事件。
</p>
</div>
</div>

<div id="outline-container-org69b5170" class="outline-2">
<h2 id="org69b5170"><span class="section-number-2">10</span> TcpConnection</h2>
<div class="outline-text-2" id="text-10">
<p>
TcpConnection完成的工作就是当TCP连接建立之后处理socket的读写以及关闭。同样我们看看TcpConnection的结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">TcpConnection</span> : <span class="org-constant">boost</span>::<span class="org-type">noncopyable</span>,
                      <span class="org-keyword">public</span> <span class="org-constant">boost</span>::<span class="org-type">enable_shared_from_this</span>&lt;<span class="org-type">TcpConnection</span>&gt;
{
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Constructs a TcpConnection with a connected sockfd</span>
    <span class="org-comment-delimiter">///</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">User should not create this object.</span>
    <span class="org-function-name">TcpConnection</span>(<span class="org-type">EventLoop</span>* <span class="org-variable-name">loop</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">&#24314;&#31435;&#36830;&#25509;&#38656;&#35201;&#19968;&#20010;Reactor</span>
                  <span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;&#21517;&#31216;</span>
                  <span class="org-type">int</span> <span class="org-variable-name">sockfd</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;fd.</span>
                  <span class="org-keyword">const</span> <span class="org-type">InetAddress</span>&amp; <span class="org-variable-name">localAddr</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;&#30340;address.</span>
                  <span class="org-keyword">const</span> <span class="org-type">InetAddress</span>&amp; <span class="org-variable-name">peerAddr</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">called when TcpServer accepts a new connection</span>
    <span class="org-type">void</span> <span class="org-function-name">connectEstablished</span>();   <span class="org-comment-delimiter">// </span><span class="org-comment">should be called only once</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">called when TcpServer has removed me from its map</span>
    <span class="org-type">void</span> <span class="org-function-name">connectDestroyed</span>();  <span class="org-comment-delimiter">// </span><span class="org-comment">should be called only once</span>
  <span class="org-keyword">private</span>:
    <span class="org-keyword">enum</span> <span class="org-type">StateE</span> { <span class="org-variable-name">kDisconnected</span>, <span class="org-variable-name">kConnecting</span>, <span class="org-variable-name">kConnected</span>, <span class="org-variable-name">kDisconnecting</span> };
    <span class="org-type">void</span> <span class="org-function-name">sendInLoop</span>(<span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">message</span>, <span class="org-type">size_t</span> <span class="org-variable-name">len</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21457;&#36865;&#28040;&#24687;</span>
    <span class="org-type">void</span> <span class="org-function-name">setState</span>(<span class="org-type">StateE</span> <span class="org-variable-name">s</span>) { state_ = s; }

    <span class="org-type">EventLoop</span>* <span class="org-variable-name">loop_</span>;
    <span class="org-type">string</span> <span class="org-variable-name">name_</span>;
    <span class="org-type">StateE</span> <span class="org-variable-name">state_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: use atomic variable</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">we don't expose those classes to client.</span>
    <span class="org-constant">boost</span>::<span class="org-type">scoped_ptr</span>&lt;Socket&gt; <span class="org-variable-name">socket_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">socket.</span>
    <span class="org-constant">boost</span>::<span class="org-type">scoped_ptr</span>&lt;Channel&gt; <span class="org-variable-name">channel_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;channel</span>
    <span class="org-type">InetAddress</span> <span class="org-variable-name">localAddr_</span>;
    <span class="org-type">InetAddress</span> <span class="org-variable-name">peerAddr_</span>;
    <span class="org-type">ConnectionCallback</span> <span class="org-variable-name">connectionCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;&#22238;&#35843;&#65292;&#36825;&#20010;&#35302;&#21457;&#21253;&#25324;&#22312;&#36830;&#25509;&#24314;&#31435;&#21644;&#26029;&#24320;&#37117;&#20250;&#35302;&#21457;</span>
    <span class="org-type">MessageCallback</span> <span class="org-variable-name">messageCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26377;&#25968;&#25454;&#21487;&#35835;&#30340;&#22238;&#35843;</span>
    <span class="org-type">WriteCompleteCallback</span> <span class="org-variable-name">writeCompleteCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#23436;&#27605;&#30340;&#22238;&#35843;</span>
    <span class="org-type">CloseCallback</span> <span class="org-variable-name">closeCallback_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;&#20851;&#38381;&#22238;&#35843;</span>
    <span class="org-type">Buffer</span> <span class="org-variable-name">inputBuffer_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#35835;&#21462;buffer.</span>
    <span class="org-type">Buffer</span> <span class="org-variable-name">outputBuffer_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: use list&lt;Buffer&gt; as output buffer.</span>
    <span class="org-constant">boost</span>::<span class="org-type">any</span> <span class="org-variable-name">context_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19978;&#19979;&#25991;&#29615;&#22659;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: creationTime_, lastReceiveTime_</span>
    <span class="org-comment-delimiter">//        </span><span class="org-comment">bytesReceived_, bytesSent_</span>
};
</pre>
</div>
<p>
首先TcpConnection在初始化的时候会建立好channel.然后一旦TcpClient或者是TcpServer建立连接之后的话，那么调用TcpConnection::connectEstablished.
这个函数内部的话就会将channel设置成为可读。一旦可读的话那么TcpConnection内部就会调用handleRead这个动作，内部托管了读取数据这个操作。
读取完毕之后然后交给MessageBack这个回调进行操作。如果需要写的话调用sendInLoop，那么会将message放在outputBuffer里面，并且设置可写。
后当可写的话TcpConnection内部就托管写，然后写完之后的话会发生writeCompleteCallback这个回调。托管的读写操作都是非阻塞的。如果希望断开的话调用
shutdown。解除这个连接的话那么可以调用TcpConnection::connectDestroyed,内部大致操作就是从reactor移除这个channel.
</p>

<p>
在TcpConnection这层并不知道一次需要读取多少个字节，这个是在上层进行消息拆分的，这点可以仔细阅读一下Httpserver这个example.
TcpConnection一次最多读取64K字节的内容，然后交给上层。上层决定这些内容是否足够，如果不够的话那么直接返回让Reactor继续等待读。
同样写的话内部也是会分多次写。这样就要求reactor内部必须使用水平触发而不是边缘触发。
</p>
</div>
</div>

<div id="outline-container-org9cee65d" class="outline-2">
<h2 id="org9cee65d"><span class="section-number-2">11</span> TcpClient</h2>
<div class="outline-text-2" id="text-11">
<p>
一旦我们了解了TcpConnection之后的话，这个托管了建立好连接之后所需要的处理的所有事情，那么我们对于client关心的重点就是如果触发连接的建立以及连接是如何断开的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">TcpClient</span>::<span class="org-function-name">TcpClient</span>(<span class="org-type">EventLoop</span>* <span class="org-variable-name">loop</span>,
                     <span class="org-keyword">const</span> <span class="org-type">InetAddress</span>&amp; <span class="org-variable-name">serverAddr</span>,
                     <span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>)
        : loop_(CHECK_NOTNULL(loop)),
          connector_(<span class="org-keyword">new</span> <span class="org-type">Connector</span>(loop, serverAddr)),
          name_(name),
          connectionCallback_(defaultConnectionCallback),
          messageCallback_(defaultMessageCallback),
          retry_(<span class="org-constant">false</span>),
          connect_(<span class="org-constant">true</span>),
          nextConnId_(1)
{
    connector_-&gt;setNewConnectionCallback(
        <span class="org-constant">boost</span>::bind(&amp;<span class="org-constant">TcpClient</span>::newConnection, <span class="org-keyword">this</span>, _1));
    <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME setConnectFailedCallback</span>
}
</pre>
</div>
<p>
可以看到初始化了connector这个对象并且设置了connector的连接建立的回调。我们需要设置一下TcpConnection所需要设置的回调之后，然后调用connect()这个方法。
内部会调用connector::start方法，一旦连接建立成功的话那么会调用TcpClient::newConnection这个函数。在这个函数内部会建立TcpConnection，并且调用
TcpConnection::connectEstablished,之后的所有操作都交给TcpConnection了。如果需要断开连接的话调用disconnect,内部会调用TcpConnection::shutdown.在析构
函数里面会调用TcpConneciton::connectDestroyed来移除连接。
</p>
</div>
</div>

<div id="outline-container-org6156a16" class="outline-2">
<h2 id="org6156a16"><span class="section-number-2">12</span> TcpServer</h2>
<div class="outline-text-2" id="text-12">
<p>
从分析上我们和TcpClient一样只是关心连接是如何建立这个过程。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">TcpServer</span>::<span class="org-function-name">TcpServer</span>(<span class="org-type">EventLoop</span>* <span class="org-variable-name">loop</span>,
                     <span class="org-keyword">const</span> <span class="org-type">InetAddress</span>&amp; <span class="org-variable-name">listenAddr</span>,
                     <span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">nameArg</span>)
  : loop_(CHECK_NOTNULL(loop)),
    hostport_(listenAddr.toHostPort()),
    name_(nameArg),
    acceptor_(<span class="org-keyword">new</span> <span class="org-type">Acceptor</span>(loop, listenAddr)),
    threadPool_(<span class="org-keyword">new</span> <span class="org-type">EventLoopThreadPool</span>(loop)),
    connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),
    started_(<span class="org-constant">false</span>),
    nextConnId_(1)
{
  acceptor_-&gt;setNewConnectionCallback(
      <span class="org-constant">boost</span>::bind(&amp;<span class="org-constant">TcpServer</span>::newConnection, <span class="org-keyword">this</span>, _1, _2));
}
</pre>
</div>
<p>
同样是建立好acceptor这个对象然后设置好回调为TcpServer::newConnection,同时在外部设置好TcpConnection的各个回调。然后调用start来启动服务器，start
会调用acceptor::listen这个方法，一旦有连接建立的话那么会调用newConnection.下面是newConnection代码
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TcpServer</span>::<span class="org-function-name">newConnection</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>, <span class="org-keyword">const</span> <span class="org-type">InetAddress</span>&amp; <span class="org-variable-name">peerAddr</span>)
{
    loop_-&gt;assertInLoopThread();
    <span class="org-type">EventLoop</span>* <span class="org-variable-name">ioLoop</span> = threadPool_-&gt;getNextLoop();
    <span class="org-type">char</span> <span class="org-variable-name">buf</span>[32];
    snprintf(buf, <span class="org-keyword">sizeof</span> buf, <span class="org-string">":%s#%d"</span>, hostport_.c_str(), nextConnId_);
    ++nextConnId_;
    <span class="org-type">string</span> <span class="org-variable-name">connName</span> = name_ + buf;
    <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME poll with zero timeout to double confirm the new connection</span>
    <span class="org-type">TcpConnectionPtr</span> <span class="org-variable-name">conn</span>(
        <span class="org-keyword">new</span> <span class="org-type">TcpConnection</span>(ioLoop, connName, sockfd, localAddr, peerAddr));
    connections_[connName] = conn;
    conn-&gt;setConnectionCallback(connectionCallback_);
    conn-&gt;setMessageCallback(messageCallback_);
    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);
    conn-&gt;setCloseCallback(
        <span class="org-constant">boost</span>::bind(&amp;<span class="org-constant">TcpServer</span>::removeConnection, <span class="org-keyword">this</span>, _1)); <span class="org-comment-delimiter">// </span><span class="org-comment">FIXME: unsafe</span>
    ioLoop-&gt;runInLoop(<span class="org-constant">boost</span>::bind(&amp;<span class="org-constant">TcpConnection</span>::connectEstablished, conn));
}
</pre>
</div>
<p>
对于服务端来说连接都被唯一化了然后映射称为字符串放在connections_这个容器内部。threadPool_-&gt;getNextLoop()可以轮询地将取出么一个线程然后将
TcpConnection::connectEstablished轮询地丢到每个线程里面去完成。存放在connections_是有原因了，每个TcpConnection有唯一一个名字，这样Server
就可以根据TcpConnection来从自己内部移除链接了。在析构函数里面可以遍历connections_内容得到所有建立的连接并且逐一释放。
</p>
</div>
</div>
</div>
</body>
</html>
