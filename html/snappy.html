<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>snappy</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="dirtysalt" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content">
<h1 class="title">snappy</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Overview</a></li>
<li><a href="#sec-2">2. Format</a>
<ul>
<li><a href="#sec-2-1">2.1. Literal</a></li>
<li><a href="#sec-2-2">2.2. Copy</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Source &amp; Sink</a></li>
<li><a href="#sec-4">4. Snippet</a>
<ul>
<li><a href="#sec-4-1">4.1. Bits</a></li>
<li><a href="#sec-4-2">4.2. Varint</a></li>
<li><a href="#sec-4-3">4.3. GetUint32AtOffset</a></li>
<li><a href="#sec-4-4">4.4. GetHashTable</a></li>
<li><a href="#sec-4-5">4.5. FindMatchLength</a></li>
<li><a href="#sec-4-6">4.6. MaxCompressedLength</a></li>
<li><a href="#sec-4-7">4.7. IncrementalCopy</a></li>
<li><a href="#sec-4-8">4.8. EmitLiteral</a></li>
<li><a href="#sec-4-9">4.9. EmitCopy</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Compress</a></li>
<li><a href="#sec-6">6. Uncompress</a>
<ul>
<li><a href="#sec-6-1">6.1. Writer</a></li>
<li><a href="#sec-6-2">6.2. SnappyDecompressor</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Example</a></li>
</ul>
</div>
</div>
<p>
<a href="http://code.google.com/p/snappy/">http://code.google.com/p/snappy/</a>
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
Snappy is a compression/decompression library. It does not aim for maximum
compression, or compatibility with any other compression library; instead,
it aims for very high speeds and reasonable compression. For instance,
compared to the fastest mode of zlib, Snappy is an order of magnitude faster
for most inputs, but the resulting compressed files are anywhere from 20% to
100% bigger. (For more information, see "Performance", below.)
</p>

<p>
Snappy is intended to be fast. On a single core of a Core i7 processor
in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at
about 500 MB/sec or more. (These numbers are for the slowest inputs in our
benchmark suite; others are much faster.) In our tests, Snappy usually
is faster than algorithms in the same class (e.g. LZO, LZF, FastLZ, QuickLZ,
etc.) while achieving comparable compression ratios.
</p>

<p>
Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x
for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and
other already-compressed data. Similar numbers for zlib in its fastest mode
are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are
capable of achieving yet higher compression rates, although usually at the
expense of speed. Of course, compression ratio will vary significantly with
the input.
</p>

<p>
Snappy里面大部分操作都是针对32/64位数据操作，然后假设不对齐的32/64位数据载入开销很少。
同时假设CPU字节序是little-endian.也有big-endian实现但是速度相对较慢。对于Intel处理器就非常适用。
</p>

<p>
Although Snappy should be fairly portable, it is primarily optimized
for 64-bit x86-compatible processors, and may run slower in other environments.
In particular:
</p>
<ul class="org-ul">
<li>Snappy uses 64-bit operations in several places to process more data at
once than would otherwise be possible.
</li>
<li>Snappy assumes unaligned 32- and 64-bit loads and stores are cheap.
On some platforms, these must be emulated with single-byte loads
and stores, which is much slower.
</li>
<li>Snappy assumes little-endian throughout, and needs to byte-swap data in
several places if running on a big-endian platform.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Format</h2>
<div class="outline-text-2" id="text-2">
<p>
Snappy is a LZ77-type compressor with a fixed, byte-oriented encoding.
</p>

<p>
压缩的头部是一个原始串长度，然后使用变长整数方式来编码(google::protobuf也使用)
</p>

<p>
The stream starts with the uncompressed length (up to a maximum of 2^32 - 1),
stored as a little-endian varint. Varints consist of a series of bytes,
where the lower 7 bits are data and the upper bit is set iff there are
more bytes to be read. In other words, an uncompressed length of 64 would
be stored as 0x40, and an uncompressed length of 2097151 (0x1FFFFF)
would be stored as 0xFF 0xFF 0x7F.
</p>

<p>
对于LZ77类型的压缩算法说里面包含两个部分
</p>
<ul class="org-ul">
<li>literal(字表).这个表示原始内容
</li>
<li>copy(拷贝).这个表示针对原始内容的copy.
</li>
</ul>
<p>
对于LZ77类型压缩类型，所谓的copy无非就是(offset,length).然后通过精巧的编码方式将(offset,length)写入。
通常来说编码方式会比原始内容小，这样达到压缩目的。而literal和copy本身也通过编码方式来进行区分，第一个字节
低两位00表示literal,而01,10,11分别表示不同类型的copy.
</p>

<p>
Snappy实现上来说非常简单，首先针对字节流进行分块(比如32KB,现在实现就是这样的，当然可以小于32KB).针对每个32KB都压缩称为
(literal+ copy+)* literal+这样的模式。解压起来也非常简单，首先将Literal解压缩copy到output字节流里面去，然后根据后面的copy
配合之前输出的output解压出来。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Literal</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于literal来说的话编码方式是这样的，假设literal的长度为len(len&gt;=1).
</p>
<ul class="org-ul">
<li>如果len&lt;=60.那么literal使用一个字节表示(len-1) &lt;&lt; 2 | 0x0 (1个字节)
</li>
<li>如果len可以用1个字节表示的话，那么literal表示[60 &lt;&lt; 2 | 0x0, len](2个字节)
</li>
<li>如果len可以用2个字节表示的话，那么literal表示[61 &lt;&lt; 2 | 0x0, len](3个字节).
</li>
<li>如果len可以用3个字节表示的话，那么literal表示[62 &lt;&lt; 2 | 0x0, len](4个字节).
</li>
<li>如果len可以用4个字节表示的话，那么literal表示[63 &lt;&lt; 2 | 0x0, len](5个字节).
</li>
</ul>
<p>
注意这里len都是按照小端序写入的。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Copy</h3>
<div class="outline-text-3" id="text-2-2">
<p>
对于copy来说的话我们假设内容是(offset,length).(offset&gt;=1,length&gt;=1).
</p>
<ul class="org-ul">
<li>如果length在[4,11],而offset在[0,2047].那么表示[(offset &gt;&gt; 8) &lt;&lt; 5 | (length-4) &lt;&lt;2 | 0x01 , offset &amp; 0xff](2个字节)
</li>
<li>如果length在[1,64],而offset在[0,65535],那么表示[(length-1) &lt;&lt; 2 | 0x02 , offset](3个字节)
</li>
<li>如果length在[1,64],而offset在[0,2^32-1],那么表示[(length-1) &lt;&lt; 2 | 0x03, offset](5个字节)
</li>
</ul>
<p>
我们这里注意到length都在[1,64]之间，如果length&gt;64的话。那么我们可以将copy切分。这个在代码里面可以看到。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Source &amp; Sink</h2>
<div class="outline-text-2" id="text-3">
<p>
这里Source表示输入源，而Sink表示输出源。不过设计上比较遗憾的是在Compress上面使用了这两个结构，
而在Uncompress上面的话只是使用了Source这个结构，而输出源的话使用了另外一个内部类Writer.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">size_t</span> <span class="org-function-name">Compress</span>(<span class="org-type">Source</span>* <span class="org-variable-name">source</span>, <span class="org-type">Sink</span>* <span class="org-variable-name">sink</span>);
<span class="org-type">bool</span> <span class="org-function-name">RawUncompress</span>(<span class="org-type">Source</span>* <span class="org-variable-name">compressed</span>, <span class="org-type">char</span>* <span class="org-variable-name">uncompressed</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20869;&#37096;&#26377;&#19968;&#20010;Writer&#23553;&#35013;&#20102;uncompressed&#25805;&#20316;</span>
</pre>
</div>

<p>
我们首先看看Sink定义的接口。能够理解这个接口全依赖这个清晰的注释。其中
</p>
<ul class="org-ul">
<li>Append接口的话是将bytes[0,n-1]这个字节流写入。
</li>
<li>GetAppendBuffer的话是交出一块length的buffer。这块length的buffer的话必须一致有效直到Append被调用。当然我们也可以直接返回scratch(外围框架分配的内存).
</li>
</ul>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Sink is an interface that consumes a sequence of bytes.</span>
<span class="org-keyword">class</span> <span class="org-type">Sink</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Sink</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Sink</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Append "bytes[0,n-1]" to this.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">bytes</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns a writable buffer of the specified length for appending.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">May return a pointer to the caller-owned scratch buffer which</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">must have at least the indicated length.  The returned buffer is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">only valid until the next operation on this Sink.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">After writing at most "length" bytes, call Append() with the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">pointer returned from this function and the number of bytes</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">written.  Many Append() implementations will avoid copying</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bytes if this function returned an internal buffer.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If a non-scratch buffer is returned, the caller may only pass a</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">prefix of it to Append().  That is, it is not correct to pass an</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">interior pointer of the returned array to Append().</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The default implementation always returns the scratch buffer.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">char</span>* <span class="org-function-name">GetAppendBuffer</span>(<span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>);

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying</span>
  <span class="org-function-name">Sink</span>(<span class="org-keyword">const</span> <span class="org-type">Sink</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Sink</span>&amp;);
};
</pre>
</div>

<p>
然后看看snappy默认实现Sink接口。这里GetAppendBuffer并没有使用scratch而是直接返回dest_,这样的话可以减少1次copy.因为如果返回scratch的话，那么外部框架首先copy到scratch,然后从scratch在copy回dest_.所以这里为什么Append需要判断(data!=dest_).
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Sink implementation that writes to a flat array without any bound checks.</span>
<span class="org-keyword">class</span> <span class="org-type">UncheckedByteArraySink</span> : <span class="org-keyword">public</span> <span class="org-type">Sink</span> {
 <span class="org-keyword">public</span>:
  <span class="org-keyword">explicit</span> <span class="org-function-name">UncheckedByteArraySink</span>(<span class="org-type">char</span>* <span class="org-variable-name">dest</span>) : dest_(dest) { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">UncheckedByteArraySink</span>();
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>);
  <span class="org-keyword">virtual</span> <span class="org-type">char</span>* <span class="org-function-name">GetAppendBuffer</span>(<span class="org-type">size_t</span> <span class="org-variable-name">len</span>, <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the current output pointer so that a caller can see how</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">many bytes were produced.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: this is not a Sink method.</span>
  <span class="org-type">char</span>* <span class="org-function-name">CurrentDestination</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> dest_; }
 <span class="org-keyword">private</span>:
  <span class="org-type">char</span>* <span class="org-variable-name">dest_</span>;
};

<span class="org-type">void</span> <span class="org-constant">UncheckedByteArraySink</span>::<span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Do no copying if the caller filled in the result of GetAppendBuffer()</span>
  <span class="org-keyword">if</span> (data != dest_) {
    memcpy(dest_, data, n);
  }
  dest_ += n;
}

<span class="org-type">char</span>* <span class="org-constant">UncheckedByteArraySink</span>::<span class="org-function-name">GetAppendBuffer</span>(<span class="org-type">size_t</span> <span class="org-variable-name">len</span>, <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>) {
  <span class="org-keyword">return</span> dest_;
}
</pre>
</div>
<p>
其实这个Sink接口非常简单地重定向到其他部分比如文件，这个在Example里面会给出例子。
</p>

<p>
接着我们看看Source定义的接口。同样能够理解这个接口全依赖清晰的注释。其中
</p>
<ul class="org-ul">
<li>Available表示还有多少个字节剩余。
</li>
<li>Peek是返回前面可以窥探到的字节流，并且返回长度。返回的buffer必须持续有效直到Skip.
</li>
<li>Skip相当于告诉Source某个部分的字节流已经不需要被使用了。
</li>
</ul>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Source is an interface that yields a sequence of bytes</span>
<span class="org-keyword">class</span> <span class="org-type">Source</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Source</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Source</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the number of bytes left to read from the source</span>
  <span class="org-keyword">virtual</span> <span class="org-type">size_t</span> <span class="org-function-name">Available</span>() <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Peek at the next flat region of the source.  Does not reposition</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the source.  The returned region is empty iff Available()==0.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns a pointer to the beginning of the region and store its</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">length in *len.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The returned region is valid until the next call to Skip() or</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">until this object is destroyed, whichever occurs first.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The returned region may be larger than Available() (for example</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">if this ByteSource is a view on a substring of a larger source).</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The caller is responsible for ensuring that it only reads the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Available() bytes.</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">Peek</span>(<span class="org-type">size_t</span>* <span class="org-variable-name">len</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Skip the next n bytes.  Invalidates any buffer returned by</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a previous call to Peek().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Available() &gt;= n</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Skip</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>) = 0;

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying</span>
  <span class="org-function-name">Source</span>(<span class="org-keyword">const</span> <span class="org-type">Source</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Source</span>&amp;);
};
</pre>
</div>
<p>
然后snappy的默认实现非常简单
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Source implementation that yields the contents of a flat array</span>
<span class="org-keyword">class</span> <span class="org-type">ByteArraySource</span> : <span class="org-keyword">public</span> <span class="org-type">Source</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">ByteArraySource</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">p</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>) : ptr_(p), left_(n) { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">ByteArraySource</span>();
  <span class="org-keyword">virtual</span> <span class="org-type">size_t</span> <span class="org-function-name">Available</span>() <span class="org-keyword">const</span>;
  <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">Peek</span>(<span class="org-type">size_t</span>* <span class="org-variable-name">len</span>);
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Skip</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>);
 <span class="org-keyword">private</span>:
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr_</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">left_</span>;
};

<span class="org-type">size_t</span> <span class="org-constant">ByteArraySource</span>::<span class="org-function-name">Available</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> left_; }

<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-constant">ByteArraySource</span>::<span class="org-function-name">Peek</span>(<span class="org-type">size_t</span>* <span class="org-variable-name">len</span>) {
  *len = left_;
  <span class="org-keyword">return</span> ptr_;
}

<span class="org-type">void</span> <span class="org-constant">ByteArraySource</span>::<span class="org-function-name">Skip</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>) {
  left_ -= n;
  ptr_ += n;
}
</pre>
</div>
<p>
从Source接口上来看到的话并不是非常好扩展。因为一开始必须知道串有多大并且从代码上看Snappy并不是一个可以增量压缩的东西。
所以个人感觉来说Source只能够做内存buffer的封装而不能够包装磁盘或者是网络流。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Snippet</h2>
<div class="outline-text-2" id="text-4">
<p>
Snappy里面有相当多的代码片段非常精巧(一定程度上难懂)，所以有必要首先看看这些函数实现。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Bits</h3>
<div class="outline-text-3" id="text-4-1">
<p>
定义了一些位操作，都使用了gcc内置函数
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Some bit-manipulation functions.</span>
<span class="org-keyword">class</span> <span class="org-type">Bits</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Return floor(log2(n)) for positive integer n.  Returns -1 iff n == 0.</span>
  <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">Log2Floor</span>(<span class="org-type">uint32</span> <span class="org-variable-name">n</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the first set least / most significant bit, 0-indexed.  Returns an</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">undefined value if n == 0.  FindLSBSetNonZero() is similar to ffs() except</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">that it's 0-indexed.</span>
  <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">FindLSBSetNonZero</span>(<span class="org-type">uint32</span> <span class="org-variable-name">n</span>);
  <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">FindLSBSetNonZero64</span>(<span class="org-type">uint64</span> <span class="org-variable-name">n</span>);

 <span class="org-keyword">private</span>:
  DISALLOW_COPY_AND_ASSIGN(<span class="org-type">Bits</span>);
};

<span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-constant">Bits</span>::<span class="org-function-name">Log2Floor</span>(<span class="org-type">uint32</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">return</span> n == 0 ? -1 : 31 ^ __builtin_clz(n); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#26159;&#21462;&#20302;5&#20301;&#21363;&#21487;</span>
}

<span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-constant">Bits</span>::<span class="org-function-name">FindLSBSetNonZero</span>(<span class="org-type">uint32</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">return</span> __builtin_ctz(n);
}

<span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-constant">Bits</span>::<span class="org-function-name">FindLSBSetNonZero64</span>(<span class="org-type">uint64</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">return</span> __builtin_ctzll(n);
}
</pre>
</div>

<p>
为了方便这里给出三个内置函数解释
</p>
<ul class="org-ul">
<li>int __builtin_clz (unsigned int x) // Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.
</li>
<li>int __builtin_ctz (unsigned int x) // Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.
</li>
<li>int __builtin_clzll (unsigned long long) // Similar to __builtin_clz, except the argument type is unsigned long long.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Varint</h3>
<div class="outline-text-3" id="text-4-2">
<p>
定义了如何将32位整数进行编码和解码。关于这种编码方式可以参考protobuf的链接
<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/encoding.html#varints">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/encoding.html#varints</a>
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Variable-length integer encoding.</span>
<span class="org-keyword">class</span> <span class="org-type">Varint</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Maximum lengths of varint encoding of uint32.</span>
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kMax32</span> = 5;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Attempts to parse a varint32 from a prefix of the bytes in [ptr,limit-1].</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Never reads a character at or beyond limit.  If a valid/terminated varint32</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">was found in the range, stores it in *OUTPUT and returns a pointer just</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">past the last byte of the varint32. Else returns NULL.  On success,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"result &lt;= limit".</span>
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">Parse32WithLimit</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">limit</span>,
                                      <span class="org-type">uint32</span>* <span class="org-variable-name">OUTPUT</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES   "ptr" points to a buffer of length sufficient to hold "v".</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">EFFECTS    Encodes "v" into "ptr" and returns a pointer to the</span>
  <span class="org-comment-delimiter">//            </span><span class="org-comment">byte just past the last encoded byte.</span>
  <span class="org-keyword">static</span> <span class="org-type">char</span>* <span class="org-function-name">Encode32</span>(<span class="org-type">char</span>* <span class="org-variable-name">ptr</span>, <span class="org-type">uint32</span> <span class="org-variable-name">v</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">EFFECTS    Appends the varint representation of "value" to "*s".</span>
  <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">Append32</span>(<span class="org-type">string</span>* <span class="org-variable-name">s</span>, <span class="org-type">uint32</span> <span class="org-variable-name">value</span>);
};

<span class="org-keyword">inline</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-constant">Varint</span>::<span class="org-function-name">Parse32WithLimit</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">p</span>,
                                            <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">l</span>,
                                            <span class="org-type">uint32</span>* <span class="org-variable-name">OUTPUT</span>) {
  <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr</span> = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(p);
  <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>* <span class="org-variable-name">limit</span> = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(l);
  <span class="org-type">uint32</span> <span class="org-variable-name">b</span>, <span class="org-variable-name">result</span>;
  <span class="org-keyword">if</span> (ptr &gt;= limit) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  b = *(ptr++); result = b &amp; 127;          <span class="org-keyword">if</span> (b &lt; 128) <span class="org-keyword">goto</span> <span class="org-constant">done</span>;
  <span class="org-keyword">if</span> (ptr &gt;= limit) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  b = *(ptr++); result |= (<span class="org-type">b</span> &amp; 127) &lt;&lt;  7; <span class="org-keyword">if</span> (b &lt; 128) <span class="org-keyword">goto</span> <span class="org-constant">done</span>;
  <span class="org-keyword">if</span> (ptr &gt;= limit) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  b = *(ptr++); result |= (<span class="org-type">b</span> &amp; 127) &lt;&lt; 14; <span class="org-keyword">if</span> (b &lt; 128) <span class="org-keyword">goto</span> <span class="org-constant">done</span>;
  <span class="org-keyword">if</span> (ptr &gt;= limit) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  b = *(ptr++); result |= (<span class="org-type">b</span> &amp; 127) &lt;&lt; 21; <span class="org-keyword">if</span> (b &lt; 128) <span class="org-keyword">goto</span> <span class="org-constant">done</span>;
  <span class="org-keyword">if</span> (ptr &gt;= limit) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  b = *(ptr++); result |= (<span class="org-type">b</span> &amp; 127) &lt;&lt; 28; <span class="org-keyword">if</span> (b &lt; 16) <span class="org-keyword">goto</span> <span class="org-constant">done</span>;
  <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">Value is too long to be a varint32</span>
 <span class="org-constant">done</span>:
  *OUTPUT = result;
  <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">char</span>*&gt;(ptr);
}

<span class="org-keyword">inline</span> <span class="org-type">char</span>* <span class="org-constant">Varint</span>::<span class="org-function-name">Encode32</span>(<span class="org-type">char</span>* <span class="org-variable-name">sptr</span>, <span class="org-type">uint32</span> <span class="org-variable-name">v</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Operate on characters as unsigneds</span>
  <span class="org-type">unsigned</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr</span> = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(sptr);
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">B</span> = 128;
  <span class="org-keyword">if</span> (v &lt; (1&lt;&lt;7)) {
    *(ptr++) = v;
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (v &lt; (1&lt;&lt;14)) {
    *(ptr++) = v | B;
    *(ptr++) = v&gt;&gt;7;
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (v &lt; (1&lt;&lt;21)) {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = v&gt;&gt;14;
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (v &lt; (1&lt;&lt;28)) {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = (v&gt;&gt;14) | B;
    *(ptr++) = v&gt;&gt;21;
  } <span class="org-keyword">else</span> {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = (v&gt;&gt;14) | B;
    *(ptr++) = (v&gt;&gt;21) | B;
    *(ptr++) = v&gt;&gt;28;
  }
  <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-type">char</span>*&gt;(ptr);
}

<span class="org-type">void</span> <span class="org-constant">Varint</span>::<span class="org-function-name">Append32</span>(<span class="org-type">string</span>* <span class="org-variable-name">s</span>, <span class="org-type">uint32</span> <span class="org-variable-name">value</span>) {
  <span class="org-type">char</span> <span class="org-variable-name">buf</span>[<span class="org-constant">Varint</span>::kMax32];
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">p</span> = <span class="org-constant">Varint</span>::Encode32(buf, value);
  s-&gt;append(buf, p - buf);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> GetUint32AtOffset</h3>
<div class="outline-text-3" id="text-4-3">
<p>
能够从一个uint64里面取出任意偏移的uint32。通常我们一次载入一个uint64的话那么知道可以得到5个uint32,效率会很高。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">For 0 &lt;= offset &lt;= 4, GetUint32AtOffset(UNALIGNED_LOAD64(p), offset) will</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">equal UNALIGNED_LOAD32(p + offset).  Motivation: On x86-64 hardware we have</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">empirically found that overlapping loads such as</span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">UNALIGNED_LOAD32(p) ... UNALIGNED_LOAD32(p+1) ... UNALIGNED_LOAD32(p+2)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">are slower than UNALIGNED_LOAD64(p) followed by shifts and casts to uint32.</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">uint32</span> <span class="org-function-name">GetUint32AtOffset</span>(<span class="org-type">uint64</span> <span class="org-variable-name">v</span>, <span class="org-type">int</span> <span class="org-variable-name">offset</span>) {
  DCHECK(0 &lt;= offset &amp;&amp; offset &lt;= 4) &lt;&lt; offset;
  <span class="org-keyword">return</span> v &gt;&gt; (<span class="org-constant">LittleEndian</span>::IsLittleEndian() ? 8 * offset : 32 - 8 * offset);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> GetHashTable</h3>
<div class="outline-text-3" id="text-4-4">
<p>
在Compress的时候需要得到HashTable来判断哪些地方可以得到copy.不过实话说GetHashTable其实没有太多可以值得学习的地方，但是我们还是看看吧。
至于hashtable每一个entry都是uint16表示什么东西，这个在Compress函数里面会讲到
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;Compress&#26159;&#25353;&#29031;1&#20010;&#20010;chunk&#26469;&#36827;&#34892;&#21387;&#32553;&#30340;&#65292;input_size&#34920;&#31034;&#36825;&#20010;chunk&#22823;&#23567;&#22810;&#23569;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312;&#26469;&#30475;&#30340;&#35805;chunk&#26368;&#22823;32KB&#12290;&#28982;&#21518;table_size&#34920;&#31034;hashtable&#26742;&#22823;&#23567;&#12290;</span>

<span class="org-type">uint16</span>* <span class="org-constant">WorkingMemory</span>::<span class="org-function-name">GetHashTable</span>(<span class="org-type">size_t</span> <span class="org-variable-name">input_size</span>, <span class="org-type">int</span>* <span class="org-variable-name">table_size</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Use smaller hash table when input.size() is smaller, since we</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">fill the table, incurring O(hash table size) overhead for</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">compression, and if the input is short, we won't need that</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">many hash table entries anyway.</span>
  assert(kMaxHashTableSize &gt;= 256);
  <span class="org-type">int</span> <span class="org-variable-name">htsize</span> = 256; <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#20174;&#26742;&#22823;&#23567;256&#24320;&#22987;&#36827;&#34892;&#35843;&#33410;,*2&#30452;&#21040;&gt;=input_size&#25110;&#32773;&#26159;kMaxHashTableSize</span>
  <span class="org-keyword">while</span> (htsize &lt; kMaxHashTableSize &amp;&amp; htsize &lt; input_size) {
    htsize &lt;&lt;= 1;
  }
  CHECK_EQ(0, htsize &amp; (htsize - 1)) &lt;&lt; <span class="org-string">": must be power of two"</span>;
  CHECK_LE(htsize, kMaxHashTableSize) &lt;&lt; <span class="org-string">": hash table too large"</span>;

  <span class="org-type">uint16</span>* <span class="org-variable-name">table</span>;
  <span class="org-keyword">if</span> (htsize &lt;= ARRAYSIZE(small_table_)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;WorkingMemory&#20869;&#37096;&#26377;&#19968;&#20010;small_table_[1&lt;&lt;10],&#36825;&#26679;&#21487;&#20197;&#20943;&#23569;&#20998;&#37197;&#20195;&#20215;</span>
    table = small_table_;
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">if</span> (large_table_ == <span class="org-constant">NULL</span>) {
      large_table_ = <span class="org-keyword">new</span> <span class="org-type">uint16</span>[kMaxHashTableSize]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#22823;&#26742;&#30340;&#35805;&#37027;&#20040;&#25105;&#20204;&#38656;&#35201;new&#20986;&#26469;</span>
    }
    table = large_table_;
  }

  *table_size = htsize;
  memset(table, 0, <span class="org-type">htsize</span> * <span class="org-keyword">sizeof</span>(*table)); <span class="org-comment-delimiter">// </span><span class="org-comment">memset(0)&#26159;&#38656;&#35201;&#30340;&#65292;&#22312;Compress&#37096;&#20998;&#21487;&#20197;&#30475;&#21040;&#20026;&#20160;&#20040;&#38656;&#35201;&#28165;0.</span>
  <span class="org-keyword">return</span> table;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> FindMatchLength</h3>
<div class="outline-text-3" id="text-4-5">
<p>
为了快速找到两个串(s1,s2)最大匹配长度多少，其中s2_limit表示s2的结尾返回匹配长度。引用场景下面s1和s2是同一个串，不过(s1&lt;s2)因为我们不需要判断s1溢出。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return the largest n such that</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">//   </span><span class="org-comment">s1[0,n-1] == s2[0,n-1]</span>
<span class="org-comment-delimiter">//   </span><span class="org-comment">and n &lt;= (s2_limit - s2).</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Does not read *s2_limit or beyond.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Does not read *(s1 + (s2_limit - s2)) or beyond.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Requires that s2_limit &gt;= s2.</span>

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">FindMatchLength</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s1</span>,
                                  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s2</span>,
                                  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s2_limit</span>) {
  DCHECK_GE(s2_limit, s2);
  <span class="org-type">int</span> <span class="org-variable-name">matched</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Find out how long the match is. We loop over the data 64 bits at a</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">time until we find a 64-bit block that doesn't match; then we find</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the first non-matching bit and use that to calculate the total</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">length of the match.</span>
  <span class="org-keyword">while</span> (PREDICT_TRUE(s2 &lt;= s2_limit - 8)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;s2&#36824;&#26377;8&#20010;&#20197;&#19978;&#23383;&#33410;&#30340;&#35805;</span>
    <span class="org-keyword">if</span> (PREDICT_FALSE(UNALIGNED_LOAD64(s2) == UNALIGNED_LOAD64(s1 + matched))) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#25105;&#20204;&#39318;&#20808;8&#20010;&#23383;&#33410;&#36827;&#34892;&#27604;&#36739;&#65292;&#21305;&#37197;&#19978;&#30340;&#35805;+8</span>
      s2 += 8;
      matched += 8;
    } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#21305;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;xor&#26469;&#21028;&#26029;&#12290;&#22914;&#26524;&#30456;&#21516;&#30340;&#35805;&#20026;0,&#28982;&#21518;&#20174;LSB&#21028;&#26029;&#26377;&#22810;&#23569;&#20010;0&#65292;&#28982;&#21518;count &gt;&gt; 3&#23601;&#34920;&#31034;&#21305;&#37197;&#23383;&#33410;&#12290;&#38750;&#24120;&#24039;&#22937;&#12290;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">On current (mid-2008) Opteron models there is a 3% more</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">efficient code sequence to find the first non-matching byte.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">However, what follows is ~10% better on Intel Core 2 and newer,</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">and we expect AMD's bsf instruction to improve.</span>
      <span class="org-type">uint64</span> <span class="org-variable-name">x</span> = UNALIGNED_LOAD64(s2) ^ UNALIGNED_LOAD64(s1 + matched);
      <span class="org-type">int</span> <span class="org-variable-name">matching_bits</span> = <span class="org-constant">Bits</span>::FindLSBSetNonZero64(x);
      matched += matching_bits &gt;&gt; 3;
      <span class="org-keyword">return</span> matched;
    }
  }
  <span class="org-keyword">while</span> (PREDICT_TRUE(s2 &lt; s2_limit)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;8&#20010;&#23383;&#33410;&#30340;&#35805;&#37027;&#20040;&#20043;&#21518;&#33021;&#22815;1&#20010;&#23383;&#33410;&#36880;&#20010;&#21305;&#37197;&#12290;</span>
    <span class="org-keyword">if</span> (PREDICT_TRUE(s1[matched] == *s2)) {
      ++s2;
      ++matched;
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">return</span> matched;
    }
  }
  <span class="org-keyword">return</span> matched;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> MaxCompressedLength</h3>
<div class="outline-text-3" id="text-4-6">
<p>
snappy接口简单很大程度上是因为对于一个input串的话，可以根据input串估计出compress之后的串长度上限。
然后进行压缩之前可以进行预分配，然后snappy内部的话在进行压缩时候就不进行字符越界检查了。
至于这个长度是如何计算出来的，可以接合此处注释以及后续对copy以及literal带来的膨胀代价分析。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">size_t</span> <span class="org-function-name">MaxCompressedLength</span>(<span class="org-type">size_t</span> <span class="org-variable-name">source_len</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Compressed data can be defined as:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">compressed := item* literal*</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">item       := literal* copy</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The trailing literal sequence has a space blowup of at most 62/60</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">since a literal of length 60 needs one tag byte + one extra byte</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">for length information.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Item blowup is trickier to measure.  Suppose the "copy" op copies</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">4 bytes of data.  Because of a special check in the encoding code,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we produce a 4-byte copy only if the offset is &lt; 65536.  Therefore</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the copy op takes 3 bytes to encode, and this type of item leads</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to at most the 62/60 blowup for representing literals.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Suppose the "copy" op copies 5 bytes of data.  If the offset is big</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">enough, it will take 5 bytes to encode the copy op.  Therefore the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">worst case here is a one-byte literal followed by a five-byte copy.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">I.e., 6 bytes of input turn into 7 bytes of "compressed" data.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">This last factor dominates the blowup, so the final estimate is:</span>
  <span class="org-keyword">return</span> 32 + source_len + source_len/6;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> IncrementalCopy</h3>
<div class="outline-text-3" id="text-4-7">
<p>
首先看看IncrementalCopy的原型和语义是什么
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Copy "len" bytes from "src" to "op", one byte at a time.  Used for</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">handling COPY operations where the input and output regions may</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">overlap.  For example, suppose:</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">src    == "ab"</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">op     == src + 2</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">len    == 20</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">After IncrementalCopy(src, op, len), the result will have</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">eleven copies of "ab"</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">ababababababababababab</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note that this does not match the semantics of either memcpy()</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">or memmove();</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">IncrementalCopy</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">src</span>, <span class="org-type">char</span>* <span class="org-variable-name">op</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>) {
  DCHECK_GT(len, 0);
  <span class="org-keyword">do</span> {
    *op++ = *src++;
  } <span class="org-keyword">while</span> (--len &gt; 0);
}
</pre>
</div>
<p>
将src内容逐个copy到op上面去。但是注意这里必须是逐个copy到op上面去。因为src和op非常有可能重叠。
可能op后面的部分字节依赖于op前面部分的字节。这个语义必须清晰，和memcpy和memmove都是不同的。
简单的实现和上面一样逐个字节进行copy.这个在解压缩的时候非常有用，因为我们的literal已经解出来放在outputle，
而copy很可能和literal重叠，需要这种IncrementalCopy的实现。
</p>

<p>
但是是否有办法更快呢？下面就是一个更快的实现。首先我们是的op和src的差距拉到&gt;=8,一旦这样之后的话
就可以开始使用8个字节进行copy了。为了将差距拉到8，不断地做8个字节copy并且调整dest.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kMaxIncrementCopyOverflow</span> = 10;

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">IncrementalCopyFastPath</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">src</span>, <span class="org-type">char</span>* <span class="org-variable-name">op</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>) {
  <span class="org-keyword">while</span> (op - src &lt; 8) {
    UNALIGNED_STORE64(op, UNALIGNED_LOAD64(src));
    len -= op - src;
    op += op - src;
  }
  <span class="org-keyword">while</span> (len &gt; 0) {
    UNALIGNED_STORE64(op, UNALIGNED_LOAD64(src));
    src += 8;
    op += 8;
    len -= 8;
  }
}
</pre>
</div>
<p>
可能阅读这个代码比较难理解，作者良好的注释又有帮助了。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to IncrementalCopy except that it can write up to ten extra</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">bytes after the end of the copy, and that it is faster.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The main part of this loop is a simple copy of eight bytes at a time until</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">we've copied (at least) the requested amount of bytes.  However, if op and</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">src are less than eight bytes apart (indicating a repeating pattern of</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">length &lt; 8), we first need to expand the pattern in order to get the correct</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">results. For instance, if the buffer looks like this, with the eight-byte</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&lt;src&gt; and &lt;op&gt; patterns marked as intervals:</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">abxxxxxxxxxxxx</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">[------]           src</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">[------]         op</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">a single eight-byte copy from &lt;src&gt; to &lt;op&gt; will repeat the pattern once,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">after which we can move &lt;op&gt; two bytes without moving &lt;src&gt;:</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">ababxxxxxxxxxx</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">[------]           src</span>
<span class="org-comment-delimiter">//        </span><span class="org-comment">[------]       op</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and repeat the exercise until the two no longer overlap.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">This allows us to do very well in the special case of one single byte</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">repeated many times, without taking a big hit for more general cases.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The worst case of extra writing past the end of the match occurs when</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">op - src == 1 and len == 1; the last copy will read from byte positions</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">[0..7] and write to [4..11], whereas it was only supposed to write to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">position 1. Thus, ten excess bytes.</span>
</pre>
</div>
<p>
不看上面注释我们也可以知道，使用这种方式是可能存在内存重叠copy的，并且很可能会多访问最后那么几个字节。
上面注释的分析就是，如果op+length之后后面还有10个空余字节的话那么就是安全的，所以kMaxIncrementCopyOverflow==10.
在使用上的话只有发现后面空余字节超过10字节之后的话，上面的算法才是安全的。
</p>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> EmitLiteral</h3>
<div class="outline-text-3" id="text-4-8">
<p>
EmitLiteral就是输出literal.虽然从Format很直观地看出literal应该怎么输出，但是还是有技巧的。最技巧的方便就是allow_fast_path.
allow_fast_path场景是如果op后面有15个空余字节的话，那么就可以使用2个8字节copy完成。这个在CompressFragment代码里面可以看到，
应用层面上只有在确保了op后面15个空余字节才会让allow_fast_path==true.而其他逻辑的话因为就是正常的copy都走了memcpy这个分支。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">char</span>* <span class="org-function-name">EmitLiteral</span>(<span class="org-type">char</span>* <span class="org-variable-name">op</span>,
                                <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">literal</span>,
                                <span class="org-type">int</span> <span class="org-variable-name">len</span>,
                                <span class="org-type">bool</span> <span class="org-variable-name">allow_fast_path</span>) {
  <span class="org-type">int</span> <span class="org-variable-name">n</span> = len - 1;      <span class="org-comment-delimiter">// </span><span class="org-comment">Zero-length literals are disallowed</span>
  <span class="org-keyword">if</span> (n &lt; 60) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Fits in tag byte</span>
    *op++ = LITERAL | (n &lt;&lt; 2);

    <span class="org-comment-delimiter">// </span><span class="org-comment">The vast majority of copies are below 16 bytes, for which a</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">call to memcpy is overkill. This fast path can sometimes</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">copy up to 15 bytes too much, but that is okay in the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">main loop, since we have a bit to go on for both sides:</span>
    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">- The input will always have kInputMarginBytes = 15 extra</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">available bytes, as long as we're in the main loop, and</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">if not, allow_fast_path = false.</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">- The output will always have 32 spare bytes (see</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">MaxCompressedLength).</span>
    <span class="org-keyword">if</span> (allow_fast_path &amp;&amp; len &lt;= 16) {
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(literal));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(literal + 8));
      <span class="org-keyword">return</span> op + len;
    }
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Encode in upcoming bytes</span>
    <span class="org-type">char</span>* <span class="org-variable-name">base</span> = op;
    <span class="org-type">int</span> <span class="org-variable-name">count</span> = 0;
    op++;
    <span class="org-keyword">while</span> (n &gt; 0) {
      *op++ = n &amp; 0xff;
      n &gt;&gt;= 8;
      count++;
    }
    assert(count &gt;= 1);
    assert(count &lt;= 4);
    *base = LITERAL | ((59+count) &lt;&lt; 2);
  }
  memcpy(op, literal, len);
  <span class="org-keyword">return</span> op + len;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9"><span class="section-number-3">4.9</span> EmitCopy</h3>
<div class="outline-text-3" id="text-4-9">
<p>
EmitCopy非常简单也不牵扯到数据的memcpy,只是写入(offset,length)这两个分量。但是之前说了如果length&gt;=64的话，那么是需要进行copy的切分的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">char</span>* <span class="org-function-name">EmitCopyLessThan64</span>(<span class="org-type">char</span>* <span class="org-variable-name">op</span>, <span class="org-type">int</span> <span class="org-variable-name">offset</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>) {
  DCHECK_LE(len, 64);
  DCHECK_GE(len, 4);
  DCHECK_LT(offset, 65536);

  <span class="org-keyword">if</span> ((len &lt; 12) &amp;&amp; (offset &lt; 2048)) {
    <span class="org-type">int</span> <span class="org-variable-name">len_minus_4</span> = len - 4;
    assert(len_minus_4 &lt; 8);            <span class="org-comment-delimiter">// </span><span class="org-comment">Must fit in 3 bits</span>
    *op++ = COPY_1_BYTE_OFFSET | ((len_minus_4) &lt;&lt; 2) | ((offset &gt;&gt; 8) &lt;&lt; 5);
    *op++ = offset &amp; 0xff;
  } <span class="org-keyword">else</span> {
    *op++ = COPY_2_BYTE_OFFSET | ((len-1) &lt;&lt; 2);
    <span class="org-constant">LittleEndian</span>::Store16(op, offset);
    op += 2;
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#27809;&#26377;&#22788;&#29702;offset&gt;=65536&#30340;&#26684;&#24335;&#65292;&#22240;&#20026;&#23601;&#29616;&#22312;&#23454;&#29616;&#26469;&#35828;chunk&#30340;&#22823;&#23567;&#26159;32K&#19981;&#20250;&#36896;&#25104;offset&gt;=64K&#30340;&#24773;&#20917;&#12290;</span>
  <span class="org-keyword">return</span> op;
}

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">char</span>* <span class="org-function-name">EmitCopy</span>(<span class="org-type">char</span>* <span class="org-variable-name">op</span>, <span class="org-type">int</span> <span class="org-variable-name">offset</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Emit 64 byte copies but make sure to keep at least four bytes reserved</span>
  <span class="org-keyword">while</span> (len &gt;= 68) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#24517;&#39035;&#21028;&#26029;68&#65292;&#19981;&#28982;&#22914;&#26524;len&lt;4&#32780;offset&lt;208&#30340;&#35805;&#37027;&#20040;&#27809;&#26377;&#23545;&#24212;&#30340;copy&#32534;&#30721;&#24418;&#24335;</span>
    op = EmitCopyLessThan64(op, offset, 64);
    len -= 64;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Emit an extra 60 byte copy if have too much data to fit in one copy</span>
  <span class="org-keyword">if</span> (len &gt; 64) {
    op = EmitCopyLessThan64(op, offset, 60);
    len -= 60;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Emit remainder</span>
  op = EmitCopyLessThan64(op, offset, len);
  <span class="org-keyword">return</span> op;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Compress</h2>
<div class="outline-text-2" id="text-5">
<p>
终于进行Compress正题了，看看大体框架吧。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">size_t</span> <span class="org-function-name">Compress</span>(<span class="org-type">Source</span>* <span class="org-variable-name">reader</span>, <span class="org-type">Sink</span>* <span class="org-variable-name">writer</span>) {

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#21462;&#24471;reader&#30340;&#38271;&#24230;&#36827;&#34892;&#32534;&#30721;&#25918;&#22312;&#26368;&#24320;&#22836;</span>

    <span class="org-type">size_t</span> <span class="org-variable-name">written</span> = 0;
    <span class="org-type">int</span> <span class="org-variable-name">N</span> = reader-&gt;Available();
    <span class="org-type">char</span> <span class="org-variable-name">ulength</span>[<span class="org-constant">Varint</span>::kMax32];
    <span class="org-type">char</span>* <span class="org-variable-name">dest</span>= writer-&gt;GetAppendBuffer(<span class="org-constant">Varint</span>::kMax32,ulength);
    <span class="org-type">char</span>* <span class="org-variable-name">p</span> = <span class="org-constant">Varint</span>::Encode32(dest,N);
    writer-&gt;Append(dest,p-dest);
    written += (p - dest);

    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">size_t written = 0;</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">int N = reader-&gt;Available();</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">char ulength[Varint::kMax32];</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">char* p = Varint::Encode32(ulength, N);</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">writer-&gt;Append(ulength, p-ulength);</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">written += (p - ulength);</span>

  <span class="org-constant">internal</span>::<span class="org-type">WorkingMemory</span> <span class="org-variable-name">wmem</span>;
  <span class="org-type">char</span>* <span class="org-variable-name">scratch</span> = <span class="org-constant">NULL</span>;
  <span class="org-type">char</span>* <span class="org-variable-name">scratch_output</span> = <span class="org-constant">NULL</span>;

  <span class="org-keyword">while</span> (N &gt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;num_to_read&#34920;&#31034;&#26412;&#27425;&#21387;&#32553;chunk&#30340;&#22823;&#23567;</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get next block to compress (without copying if possible)</span>
    <span class="org-type">size_t</span> <span class="org-variable-name">fragment_size</span>;
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">fragment</span> = reader-&gt;Peek(&amp;fragment_size);
    DCHECK_NE(fragment_size, 0) &lt;&lt; <span class="org-string">": premature end of input"</span>;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">num_to_read</span> = min(N, kBlockSize);
    <span class="org-type">size_t</span> <span class="org-variable-name">bytes_read</span> = fragment_size;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#22320;&#26041;&#20250;&#23581;&#35797;&#21457;&#36215;&#22810;&#27425;&#35835;&#65292;&#20294;&#26159;&#23601;&#29616;&#22312;Snappy&#40664;&#35748;&#23454;&#29616;&#26469;&#35828;&#65292;&#20854;&#23454;&#23601;&#26159;&#19968;&#27493;&#21040;&#20301;&#65292;&#19981;&#20250;&#36827;&#20837;else&#36923;&#36753;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#21363;&#20351;&#36827;&#20837;&#19979;&#38754;&#36923;&#36753;&#20063;&#38750;&#24120;&#31616;&#21333;&#65292;&#26080;&#38750;&#23601;&#26159;&#22810;&#27425;&#21457;&#36215;&#35835;&#28982;&#21518;&#25918;&#22312;scratch&#20869;&#23384;&#37324;&#38754;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#36825;&#20010;&#21028;&#26029;&#20043;&#21518;&#65292;&#22320;&#22336;&#21644;&#22823;&#23567;&#25918;&#22312;&#20102;fragment,fragment_size&#37324;&#38754;&#12290;</span>

    <span class="org-type">int</span> <span class="org-variable-name">pending_advance</span> = 0;
    <span class="org-keyword">if</span> (bytes_read &gt;= num_to_read) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Buffer returned by reader is large enough</span>
      pending_advance = num_to_read;
      fragment_size = num_to_read;
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Read into scratch buffer</span>
      <span class="org-keyword">if</span> (scratch == <span class="org-constant">NULL</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">If this is the last iteration, we want to allocate N bytes</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">of space, otherwise the max possible kBlockSize space.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">num_to_read contains exactly the correct value</span>
        scratch = <span class="org-keyword">new</span> <span class="org-type">char</span>[num_to_read];
      }
      memcpy(scratch, fragment, bytes_read);
      reader-&gt;Skip(bytes_read);

      <span class="org-keyword">while</span> (bytes_read &lt; num_to_read) {
        fragment = reader-&gt;Peek(&amp;fragment_size);
        <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = min&lt;<span class="org-type">size_t</span>&gt;(fragment_size, num_to_read - bytes_read);
        memcpy(scratch + bytes_read, fragment, n);
        bytes_read += n;
        reader-&gt;Skip(n);
      }
      DCHECK_EQ(bytes_read, num_to_read);
      fragment = scratch;
      fragment_size = num_to_read;
    }
    DCHECK_EQ(fragment_size, num_to_read);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20934;&#22791;&#38024;&#23545;fragment&#26469;&#36827;&#34892;&#21387;&#32553;&#65292;&#39318;&#20808;&#25105;&#20204;&#21019;&#24314;&#19968;&#20010;hashtable</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Get encoding table for compression</span>
    <span class="org-type">int</span> <span class="org-variable-name">table_size</span>;
    <span class="org-type">uint16</span>* <span class="org-variable-name">table</span> = wmem.GetHashTable(num_to_read, &amp;table_size);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#36825;&#27425;&#21387;&#32553;&#30340;&#35805;&#65292;&#20020;&#26102;&#31354;&#38388;&#21040;&#24213;&#24212;&#35813;&#24320;&#36767;&#22810;&#22823;&#12290;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Compress input_fragment and append to dest</span>
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">max_output</span> = MaxCompressedLength(num_to_read);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Need a scratch buffer for the output, in case the byte sink doesn't</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">have room for us directly.</span>
    <span class="org-keyword">if</span> (scratch_output == <span class="org-constant">NULL</span>) {
      scratch_output = <span class="org-keyword">new</span> <span class="org-type">char</span>[max_output];
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Since we encode kBlockSize regions followed by a region</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">which is &lt;= kBlockSize in length, a previously allocated</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">scratch_output[] region is big enough for this iteration.</span>
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;CompressFragment&#26469;&#21387;&#32553;&#36825;&#20010;fragment</span>
    <span class="org-type">char</span>* <span class="org-variable-name">dest</span> = writer-&gt;GetAppendBuffer(max_output, scratch_output);
    <span class="org-type">char</span>* <span class="org-variable-name">end</span> = <span class="org-constant">internal</span>::CompressFragment(fragment, fragment_size,
                                           dest, table, table_size);
    writer-&gt;Append(dest, end - dest);
    written += (end - dest);

    N -= num_to_read;
    reader-&gt;Skip(pending_advance);
  }

  <span class="org-keyword">delete</span>[] scratch;
  <span class="org-keyword">delete</span>[] scratch_output;

  <span class="org-keyword">return</span> written;
}
</pre>
</div>

<p>
整个过程并不是很麻烦，无非就是切出chunk出来并且初始化hashtable然后交给CompressFragment来处理。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">char</span>* <span class="org-function-name">CompressFragment</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-keyword">const</span> <span class="org-variable-name">input</span>,
                       <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">input_size</span>,
                       <span class="org-type">char</span>* <span class="org-variable-name">op</span>,
                       <span class="org-type">uint16</span>* <span class="org-variable-name">table</span>,
                       <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">table_size</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">"ip" is the input pointer, and "op" is the output pointer.</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ip</span> = input;
  CHECK_LE(input_size, kBlockSize);
  CHECK_EQ(table_size &amp; (table_size - 1), 0) &lt;&lt; <span class="org-string">": table must be power of two"</span>;
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">shift</span> = 32 - <span class="org-constant">Bits</span>::Log2Floor(table_size);
  DCHECK_EQ(kuint32max &gt;&gt; shift, table_size - 1);
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ip_end</span> = input + input_size;
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">base_ip</span> = ip;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Bytes in [next_emit, ip) will be emitted as literal bytes.  Or</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">[next_emit, ip_end) after the main loop.</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">next_emit</span> = ip;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#24819;&#19968;&#19979;&#25105;&#20204;&#20043;&#21069;EmitLiteral&#24517;&#39035;&#30830;&#20445;15&#20010;&#23383;&#33410;&#25165;&#26377;allow_fast_path</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25105;&#20204;&#30830;&#20445;&#26368;&#21518;15&#20010;&#23383;&#33410;&#36827;&#34892;literal&#30340;&#35805;&#65292;&#37027;&#20040;op&#21518;&#38754;&#24517;&#39035;&#23384;&#22312;&gt;=15&#23383;&#33410;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#21069;&#38754;&#36827;&#34892;EmitLiteral&#37117;&#21487;&#20197;&#36827;&#34892;allow_fast_path&#20102;&#12290;</span>

  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kInputMarginBytes</span> = 15;
  <span class="org-keyword">if</span> (PREDICT_TRUE(input_size &gt;= kInputMarginBytes)) {
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ip_limit</span> = input + input_size - kInputMarginBytes;

    <span class="org-keyword">for</span> (<span class="org-type">uint32</span> <span class="org-variable-name">next_hash</span> = Hash(++ip, shift); ; ) {
      DCHECK_LT(next_emit, ip);
      <span class="org-comment-delimiter">// </span><span class="org-comment">The body of this loop calls EmitLiteral once and then EmitCopy one or</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">more times.  (The exception is that when we're close to exhausting</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">the input we goto emit_remainder.)</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">In the first iteration of this loop we're just starting, so</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">there's nothing to copy, so calling EmitLiteral once is</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">necessary.  And we only start a new iteration when the</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">current iteration has determined that a call to EmitLiteral will</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">precede the next call to EmitCopy (if any).</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Step 1: Scan forward in the input looking for a 4-byte-long match.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">If we get close to exhausting the input then goto emit_remainder.</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Heuristic match skipping: If 32 bytes are scanned with no matches</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">found, start looking only at every other byte. If 32 more bytes are</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">scanned, look at every third byte, etc.. When a match is found,</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">immediately go back to looking at every byte. This is a small loss</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">(~5% performance, ~0.1% density) for compressible data due to more</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">bookkeeping, but for non-compressible data (such as JPEG) it's a huge</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">win since the compressor quickly "realizes" the data is incompressible</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">and doesn't bother looking for matches everywhere.</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">The "skip" variable keeps track of how many bytes there are since the</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">last match; dividing it by 32 (ie. right-shifting by five) gives the</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">number of bytes to move ahead for each iteration.</span>
      <span class="org-type">uint32</span> <span class="org-variable-name">skip</span> = 32;

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#39318;&#20808;&#26597;&#25214;4bytes&#30340;match</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;hash==Hash(Load32(ip)),&#28982;&#21518;table[hash]=ip-base_ip.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#26742;&#37324;&#38754;&#30340;&#20869;&#23481;&#23601;&#26159;&#30456;&#23545;&#20110;base_ip&#20063;&#23601;&#26159;&#36215;&#22987;&#36755;&#20837;&#30340;&#20559;&#31227;</span>

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#38656;&#35201;&#29992;&#34920;&#36798;&#26159;&#34920;&#26126;&#30340;&#35805;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">table[Hash(Load32(ip))]=ip-base_ip</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;&#39318;&#20808;&#21305;&#37197;hash&#65292;&#19968;&#26086;hash&#21305;&#37197;&#19978;&#28982;&#21518;&#26816;&#26597;&#20869;&#23481;&#26159;&#21542;&#30456;&#21516;&#26469;&#21457;&#29616;match</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#22914;&#26524;&#20986;&#29616;hash&#20914;&#31361;&#30340;&#35805;&#37027;&#20040;table&#26159;&#19981;&#26029;update&#30340;</span>

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21478;&#22806;&#19968;&#20010;&#26377;&#36259;&#30340;&#20107;&#24773;&#23601;&#26159;&#36825;&#20010;skip</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#30475;&#21040;&#21069;&#38754;32&#27425;&#37117;&#26159;&#25353;&#29031;1&#20010;&#23383;&#33410;&#36339;&#36291;&#65292;&#30452;&#21040;skip==64</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#25353;&#29031;2&#20010;&#23383;&#33410;&#36339;&#36291;&#65292;&#30452;&#21040;skip==128</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26159;&#19968;&#31181;&#21551;&#21457;&#26159;&#30340;&#21305;&#37197;&#31639;&#27861;</span>
      <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">next_ip</span> = ip;
      <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">candidate</span>;
      <span class="org-keyword">do</span> {
        ip = next_ip;
        <span class="org-type">uint32</span> <span class="org-variable-name">hash</span> = next_hash;
        DCHECK_EQ(hash, Hash(ip, shift));
        <span class="org-type">uint32</span> <span class="org-variable-name">bytes_between_hash_lookups</span> = skip++ &gt;&gt; 5;
        next_ip = ip + bytes_between_hash_lookups;
        <span class="org-keyword">if</span> (PREDICT_FALSE(next_ip &gt; ip_limit)) {
          <span class="org-keyword">goto</span> <span class="org-constant">emit_remainder</span>;
        }
        next_hash = Hash(next_ip, shift);

        candidate = base_ip + table[hash];
        DCHECK_GE(candidate, base_ip);
        DCHECK_LT(candidate, ip);

        table[hash] = ip - base_ip;
      } <span class="org-keyword">while</span> (PREDICT_TRUE(UNALIGNED_LOAD32(ip) !=
                            UNALIGNED_LOAD32(candidate)));


      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21040;&#36825;&#20010;&#27493;&#39588;&#20043;&#21518;&#30340;&#35805;&#65292;&#37027;&#20040;ip&#21644;candidate&#23601;&#23436;&#20840;&#21305;&#37197;&#19978;&#20102;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#21487;&#20197;&#23558;[next_emit,ip-1]&#20316;&#20026;literal&#36755;&#20986;</span>

      <span class="org-comment-delimiter">// </span><span class="org-comment">Step 2: A 4-byte match has been found.  We'll later see if more</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">than 4 bytes match.  But, prior to the match, input</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">bytes [next_emit, ip) are unmatched.  Emit them as "literal bytes."</span>
      DCHECK_LE(next_emit + 16, ip_end); <span class="org-comment-delimiter">// </span><span class="org-comment">including margin bytes.</span>
      op = EmitLiteral(op, next_emit, ip - next_emit, <span class="org-constant">true</span>);

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#25105;&#20204;&#36827;&#34892;copy&#36755;&#20986;</span>

      <span class="org-comment-delimiter">// </span><span class="org-comment">Step 3: Call EmitCopy, and then see if another EmitCopy could</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">be our next move.  Repeat until we find no match for the</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">input immediately after what was consumed by the last EmitCopy call.</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">If we exit this loop normally then we need to call EmitLiteral next,</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">though we don't yet know how big the literal will be.  We handle that</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">by proceeding to the next iteration of the main loop.  We also can exit</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">this loop via goto if we get close to exhausting the input.</span>
      <span class="org-type">uint64</span> <span class="org-variable-name">input_bytes</span> = 0;
      <span class="org-type">uint32</span> <span class="org-variable-name">candidate_bytes</span> = 0;

      <span class="org-keyword">do</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">We have a 4-byte match at ip, and no need to emit any</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">"literal bytes" prior to ip.</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">base</span> = ip;

        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;ip&#21644;candidate&#21305;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#23581;&#35797;&#21462;&#21457;&#29616;&#26356;&#38271;&#30340;copy</span>

        <span class="org-type">int</span> <span class="org-variable-name">matched</span> = 4 + FindMatchLength(candidate + 4, ip + 4, ip_end);
        ip += matched;
        <span class="org-type">int</span> <span class="org-variable-name">offset</span> = base - candidate;
        DCHECK_EQ(0, memcmp(base, candidate, matched));
        op = EmitCopy(op, offset, matched);

        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#38754;&#26159;&#31639;&#27861;&#30340;&#20248;&#21270;&#65292;&#26356;&#26032;&#19968;&#19979;Hash(ip-1),&#28982;&#21518;&#30475;&#30475;&#21518;&#38754;ip&#26159;&#21542;&#31435;&#21051;&#26377;candidate&#21305;&#37197;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">We could immediately start working at ip now, but to improve</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">compression we first update table[Hash(ip - 1, ...)].</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">insert_tail</span> = ip - 1;
        next_emit = ip;
        <span class="org-keyword">if</span> (PREDICT_FALSE(ip &gt;= ip_limit)) {
          <span class="org-keyword">goto</span> <span class="org-constant">emit_remainder</span>;
        }
        input_bytes = UNALIGNED_LOAD64(insert_tail);
        <span class="org-type">uint32</span> <span class="org-variable-name">prev_hash</span> = HashBytes(GetUint32AtOffset(input_bytes, 0), shift);
        table[prev_hash] = ip - base_ip - 1;
        <span class="org-type">uint32</span> <span class="org-variable-name">cur_hash</span> = HashBytes(GetUint32AtOffset(input_bytes, 1), shift);
        candidate = base_ip + table[cur_hash];
        candidate_bytes = UNALIGNED_LOAD32(candidate);
        table[cur_hash] = ip - base_ip;
      } <span class="org-keyword">while</span> (GetUint32AtOffset(input_bytes, 1) == candidate_bytes);

      next_hash = HashBytes(GetUint32AtOffset(input_bytes, 2), shift);
      ++ip;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26368;&#21518;&#37096;&#20998;&#27809;&#26377;&gt;=15&#20010;&#23383;&#33410;&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#30452;&#25509;&#20316;&#20026;literal&#36755;&#20986;&#65292;&#20294;&#26159;&#32943;&#23450;&#19981;&#33021;&#22815;allow_fast_path</span>
 <span class="org-constant">emit_remainder</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Emit the remaining bytes as a literal</span>
  <span class="org-keyword">if</span> (next_emit &lt; ip_end) {
    op = EmitLiteral(op, next_emit, ip_end - next_emit, <span class="org-constant">false</span>);
  }

  <span class="org-keyword">return</span> op;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Uncompress</h2>
<div class="outline-text-2" id="text-6">
<p>
Uncompress最终走到的逻辑是下面这个代码。比较重要的就是SnappyDecompressor以及Write这个接口。不过从代码逻辑上看非常简单，
首先ReadUncompressedLength，然后writer设置最终解码之后应该多大。然后decompressor开始分析各个tag了。最后decompressor判断是否读完以及
writer判断自己解码之后长度和uncompressed_len是否相同。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Writer</span>&gt;
<span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">InternalUncompress</span>(<span class="org-type">Source</span>* <span class="org-variable-name">r</span>,
                               <span class="org-type">Writer</span>* <span class="org-variable-name">writer</span>,
                               <span class="org-type">uint32</span> <span class="org-variable-name">max_len</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Read the uncompressed length from the front of the compressed input</span>
  <span class="org-type">SnappyDecompressor</span> <span class="org-function-name">decompressor</span>(r);
  <span class="org-type">uint32</span> <span class="org-variable-name">uncompressed_len</span> = 0;
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>decompressor.ReadUncompressedLength(&amp;uncompressed_len)) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Protect against possible DoS attack</span>
  <span class="org-keyword">if</span> (<span class="org-keyword">static_cast</span>&lt;uint64&gt;(uncompressed_len) &gt; max_len) {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }

  writer-&gt;SetExpectedLength(uncompressed_len);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Process the entire input</span>
  decompressor.DecompressAllTags(writer);
  <span class="org-keyword">return</span> (decompressor.eof() &amp;&amp; writer-&gt;CheckLength());
}
</pre>
</div>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Writer</h3>
<div class="outline-text-3" id="text-6-1">
<p>
我们首先看看一个实现SnappyArrayWriter.最关键的两个函数就是Append(copy literal)以及AppendFromSelf(copy copy).
然后对于SnappyDecompressor分析出literal以及copy之后就可以调用这两个函数来进行解压缩了。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">SnappyArrayWriter</span> {
 <span class="org-keyword">private</span>:
  <span class="org-type">char</span>* <span class="org-variable-name">base_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36215;&#22987;&#22320;&#22336;</span>
  <span class="org-type">char</span>* <span class="org-variable-name">op_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#25805;&#20316;&#22320;&#22336;</span>
  <span class="org-type">char</span>* <span class="org-variable-name">op_limit_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#25805;&#20316;&#38408;&#20540;</span>

 <span class="org-keyword">public</span>:
  <span class="org-keyword">inline</span> <span class="org-keyword">explicit</span> <span class="org-function-name">SnappyArrayWriter</span>(<span class="org-type">char</span>* <span class="org-variable-name">dst</span>)
      : base_(dst),
        <span class="org-type">op_</span>(<span class="org-variable-name">dst</span>) {
  }

  <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">SetExpectedLength</span>(<span class="org-type">size_t</span> <span class="org-variable-name">len</span>) {
    op_limit_ = op_ + len; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#38408;&#20540;</span>
  }

  <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">CheckLength</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> op_ == op_limit_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38271;&#24230;&#26159;&#21542;&#21305;&#37197;</span>
  }

  <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ip</span>, <span class="org-type">uint32</span> <span class="org-variable-name">len</span>, <span class="org-type">bool</span> <span class="org-variable-name">allow_fast_path</span>) {
    <span class="org-type">char</span>* <span class="org-variable-name">op</span> = op_;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">space_left</span> = op_limit_ - op;
    <span class="org-keyword">if</span> (allow_fast_path &amp;&amp; len &lt;= 16 &amp;&amp; space_left &gt;= 16) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Fast path, used for the majority (about 90%) of dynamic invocations.</span>
      UNALIGNED_STORE64(op, <span class="org-type">UNALIGNED_LOAD64</span>(<span class="org-variable-name">ip</span>));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(ip + 8));
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (space_left &lt; len) {
        <span class="org-keyword">return</span> <span class="org-constant">false</span>;
      }
      memcpy(op, ip, <span class="org-type">len</span>);
    }
    op_ = op + len;
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }

  <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">AppendFromSelf</span>(<span class="org-type">uint32</span> <span class="org-variable-name">offset</span>, <span class="org-type">uint32</span> <span class="org-variable-name">len</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#33258;&#36523;&#22797;&#21046;&#65292;&#21521;&#21069;&#36208;offset&#28982;&#21518;copy len&#20010;&#23383;&#33410;&#25968;&#25454;</span>
    <span class="org-type">char</span>* <span class="org-variable-name">op</span> = op_;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">space_left</span> = op_limit_ - op;

    <span class="org-keyword">if</span> (op - base_ &lt;= offset - 1u) {  <span class="org-comment-delimiter">// </span><span class="org-comment">-1u catches offset==0</span>
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
    <span class="org-keyword">if</span> (len &lt;= 16 &amp;&amp; offset &gt;= 8 &amp;&amp; space_left &gt;= 16) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#26377;offset&gt;=8&#25165;&#21487;&#20197;&#30452;&#25509;&#25805;&#20316;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Fast path, used for the majority (70-80%) of dynamic invocations.</span>
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(op - offset));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(op - offset + 8));
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (space_left &gt;= len + kMaxIncrementCopyOverflow) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20801;&#35768;FastPath&#30340;&#35805;</span>
        IncrementalCopyFastPath(op - offset, op, <span class="org-type">len</span>);
      } <span class="org-keyword">else</span> {
        <span class="org-keyword">if</span> (space_left &lt; len) {
          <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
        IncrementalCopy(op - offset, op, <span class="org-type">len</span>);
      }
    }

    op_ = op + len;
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }
};
</pre>
</div>

<p>
不难想到如果修改一下这个实现的话那么可以做检查器，我们只是验证压缩包是否正确。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Writer that drops everything on the floor and just does validation</span>
<span class="org-keyword">class</span> <span class="org-type">SnappyDecompressionValidator</span> {
 <span class="org-keyword">private</span>:
  <span class="org-type">size_t</span> <span class="org-variable-name">expected_</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">produced_</span>;

 <span class="org-keyword">public</span>:
  <span class="org-keyword">inline</span> <span class="org-function-name">SnappyDecompressionValidator</span>() : produced_(0) { }
  <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">SetExpectedLength</span>(<span class="org-type">size_t</span> <span class="org-variable-name">len</span>) {
    expected_ = len;
  }
  <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">CheckLength</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> expected_ == produced_;
  }
  <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ip</span>, <span class="org-type">uint32</span> <span class="org-variable-name">len</span>, <span class="org-type">bool</span> <span class="org-variable-name">allow_fast_path</span>) {
    produced_ += len;
    <span class="org-keyword">return</span> produced_ &lt;= expected_;
  }
  <span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">AppendFromSelf</span>(<span class="org-type">uint32</span> <span class="org-variable-name">offset</span>, <span class="org-type">uint32</span> <span class="org-variable-name">len</span>) {
    <span class="org-keyword">if</span> (produced_ &lt;= offset - 1u) <span class="org-keyword">return</span> <span class="org-constant">false</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">-1u catches offset==0</span>
    produced_ += len;
    <span class="org-keyword">return</span> produced_ &lt;= expected_;
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> SnappyDecompressor</h3>
<div class="outline-text-3" id="text-6-2">
<p>
SnappyDecompressor有几个比较重要的方法：
</p>
<ul class="org-ul">
<li>ReadUncompressedLength.这个就是解压缩开头的Varint.这个没有太大的问题。
</li>
<li>DecompressAllTags.这个是解压缩所有的tag，源是RefillTag填充的scratch[].
</li>
<li>RefillTag.填充tag所需要的字节到scratch[]内部。这个也没有太大问题。
</li>
</ul>
<p>
在看这个代码之前，我们想想如果我们得到scratch之后应该如何从中提取tag信息呢？最好的方式就是打表。
因为tag的头一个字节反应了这个tag所有信息，所以在snappy里面有char_table这个表以头一个字节内容作为索引
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Data stored per entry in lookup table:</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">Range   Bits-used       Description</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">------------------------------------</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">1..64   0..7            Literal/copy length encoded in opcode byte</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">0..7    8..10           Copy offset encoded in opcode byte / 256</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">0..4    11..13          Extra bytes after opcode</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">We use eight bits for the length even though 7 would have sufficed</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">because of efficiency reasons:</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">(1) Extracting a byte is faster than a bit-field</span>
<span class="org-comment-delimiter">//      </span><span class="org-comment">(2) It properly aligns copy offset so we do not need a &lt;&lt;8</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">uint16</span> <span class="org-variable-name">char_table</span>[256] = {
  0x0001, 0x0804, 0x1001, 0x2001, 0x0002, 0x0805, 0x1002, 0x2002,
  0x0003, 0x0806, 0x1003, 0x2003, 0x0004, 0x0807, 0x1004, 0x2004,
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
};
</pre>
</div>
<p>
这个表是可以计算出来的
</p>
<ul class="org-ul">
<li>[0..7]表示literal/copy长度,因为不管是literal/copy长度。对于copy是足够的，但是对于literal来说的话能够根据高extra byte判断后面剩余长度字节。
</li>
<li>[8..10]表示copy的offset / 256,对于offset剩余内容通过extra表示
</li>
<li>[11..13]表示后面剩余多少个字节。通过wordmask来提取。
</li>
</ul>
<p>
这里workmask
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">uint32</span> <span class="org-variable-name">wordmask</span>[] = {
  0u, 0xffu, 0xffffu, 0xffffffu, 0xffffffffu
};
</pre>
</div>
<p>
这样如果extra bytes==1的话，通过&amp; 0xffu可以取到1个字节。这个在代码里面就会有体现。非常精巧。
</p>

<p>
我们看看DecompressAllTags这个函数实现
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Process the next item found in the input.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if successful, false on error or end of input.</span>
<span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Writer</span>&gt;
<span class="org-type">void</span> <span class="org-function-name">DecompressAllTags</span>(<span class="org-type">Writer</span>* <span class="org-variable-name">writer</span>) {
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ip</span> = ip_;
  <span class="org-keyword">for</span> ( ;; ) {
    <span class="org-keyword">if</span> (ip_limit_ - ip &lt; 5) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#22815;5&#20010;&#23383;&#33410;&#30340;&#35805;&#37027;&#20040;&#23601;&#22635;&#20805;&#65292;&#20294;&#26159;&#22635;&#20805;&#32467;&#26524;&#19981;&#19968;&#23450;&#36798;&#21040;5&#20010;&#23383;&#33410;&#12290;</span>
      ip_ = ip;
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>RefillTag()) <span class="org-keyword">return</span>;
      ip = ip_;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;tag&#31532;&#19968;&#20010;&#23383;&#33410;&#21040;c,&#24471;&#21040;entry</span>
    <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">c</span> = *(<span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(ip++));
    <span class="org-keyword">const</span> <span class="org-type">uint32</span> <span class="org-variable-name">entry</span> = char_table[c];
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#23558;extra bytes&#25353;&#29031;uint32&#36733;&#20837;&#65292;&#28982;&#21518;&#26681;&#25454;wordmask&#30693;&#36947;&#65292;&#38500;&#20102;&#30041;&#22312;c&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;&#20043;&#22806;&#65292;&#23384;&#25918;&#22312;extra bytes&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;&#65292;&#21483;&#20570;trailer.</span>
    <span class="org-keyword">const</span> <span class="org-type">uint32</span> <span class="org-variable-name">trailer</span> = <span class="org-constant">LittleEndian</span>::Load32(ip) &amp; wordmask[entry &gt;&gt; 11];
    <span class="org-comment-delimiter">// </span><span class="org-comment">ip&#21518;&#38754;extra bytes&#36339;&#36807;</span>
    ip += entry &gt;&gt; 11;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24471;&#21040;&#25918;&#22312;c&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;</span>
    <span class="org-keyword">const</span> <span class="org-type">uint32</span> <span class="org-variable-name">length</span> = entry &amp; 0xff;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36825;&#20010;tag&#26159;LITERAL&#30340;&#35805;</span>
    <span class="org-keyword">if</span> ((<span class="org-type">c</span> &amp; 0x3) == LITERAL) {
      <span class="org-type">uint32</span> <span class="org-variable-name">literal_length</span> = length + trailer; <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;trailer&#34920;&#31034;literal_length&#37096;&#20998;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#38754;&#25805;&#20316;&#23601;&#26159;&#20889;&#20837;LITERAL</span>
      <span class="org-type">uint32</span> <span class="org-variable-name">avail</span> = ip_limit_ - ip;
      <span class="org-keyword">while</span> (avail &lt; literal_length) {
        <span class="org-type">bool</span> <span class="org-variable-name">allow_fast_path</span> = (avail &gt;= 16);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>writer-&gt;Append(ip, avail, allow_fast_path)) <span class="org-keyword">return</span>;
        literal_length -= avail;
        reader_-&gt;Skip(peeked_);
        <span class="org-type">size_t</span> <span class="org-variable-name">n</span>;
        ip = reader_-&gt;Peek(&amp;n);
        avail = n;
        peeked_ = avail;
        <span class="org-keyword">if</span> (avail == 0) <span class="org-keyword">return</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Premature end of input</span>
        ip_limit_ = ip + avail;
      }
      <span class="org-type">bool</span> <span class="org-variable-name">allow_fast_path</span> = (avail &gt;= 16);
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>writer-&gt;Append(ip, literal_length, allow_fast_path)) {
        <span class="org-keyword">return</span>;
      }
      ip += literal_length;
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;COPY&#30340;&#35805;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">copy_offset/256 is encoded in bits 8..10.  By just fetching</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">those bits, we get copy_offset (since the bit-field starts at</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">bit 8).</span>
        <span class="org-keyword">const</span> <span class="org-type">uint32</span> <span class="org-variable-name">copy_offset</span> = (<span class="org-type">entry</span> &amp; 0x700) ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#20010;&#22320;&#26041;&#24050;&#32463; * 256&#20102;&#65292;&#25105;&#20204;&#19981;&#38656;&#35201;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#24518;COPY(01)&#30340;(offset &gt;&gt; 8) &lt;&lt; 5.&#25152;&#20197;&#36825;&#20010;&#22320;&#26041;&#30452;&#25509;&#23601;&#26159;&#36825;&#20010;&#32467;&#26524;</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;copy&#30340;&#35805;&#65292;&#37027;&#20040;trailer&#20449;&#24687;&#26159;offset&#32780;&#19981;&#26159;length</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;COPY&#20889;&#20837;.</span>
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>writer-&gt;AppendFromSelf(copy_offset + trailer, length)) {
        <span class="org-keyword">return</span>;
      }
    }
  }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Example</h2>
<div class="outline-text-2" id="text-7">
<p>
工作很简单，首先从main.cc里面读取内容然后压缩到main.cc.compress文件里面，然后读取出来解压缩对比是否正确。这里我们演示了Sink如何封装。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/stat.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;fcntl.h&gt;</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;snappy.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;snappy-sinksource.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">IN_NAME</span>=<span class="org-string">"./main.cc"</span>;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">OUT_NAME</span>=<span class="org-string">"./main.cc.compress"</span>;

<span class="org-keyword">class</span> <span class="org-type">FileSink</span>:<span class="org-keyword">public</span> <span class="org-constant">snappy</span>::<span class="org-type">Sink</span>{
  <span class="org-keyword">public</span>:
    <span class="org-function-name">FileSink</span>(<span class="org-type">int</span> <span class="org-variable-name">fd</span>):<span class="org-function-name">fd_</span>(fd){
    }
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">FileSink</span>(){}
    <span class="org-keyword">virtual</span> <span class="org-type">char</span>* <span class="org-function-name">GetAppendBuffer</span>(<span class="org-type">size_t</span> <span class="org-variable-name">length</span>,<span class="org-type">char</span>* <span class="org-variable-name">scratch</span>){
        <span class="org-keyword">return</span> scratch;
    }
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">bytes</span>,<span class="org-type">size_t</span> <span class="org-variable-name">n</span>){
        write(fd_,bytes,n);
    }
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">fd_</span>;
};

<span class="org-type">int</span> <span class="org-function-name">main</span>(){
    <span class="org-keyword">struct</span> <span class="org-type">stat</span> <span class="org-variable-name">stbuf</span>;
    <span class="org-variable-name">stat</span>(IN_NAME,&amp;stbuf);
    <span class="org-type">size_t</span> <span class="org-variable-name">in_fsize</span>=stbuf.st_size;
    <span class="org-type">size_t</span> <span class="org-variable-name">compress_fsize</span>=0;

    <span class="org-comment-delimiter">// </span><span class="org-comment">do comress</span>
    <span class="org-type">char</span>* <span class="org-variable-name">in_buf</span>=<span class="org-keyword">new</span> <span class="org-type">char</span>[in_fsize];
    {
        <span class="org-type">FILE</span>* <span class="org-variable-name">fin</span>=fopen(IN_NAME,<span class="org-string">"rb"</span>);
        fread(in_buf,1,in_fsize,fin);
        fclose(fin);
        <span class="org-constant">snappy</span>::<span class="org-type">ByteArraySource</span> <span class="org-function-name">source</span>(in_buf,in_fsize);

        <span class="org-type">int</span> <span class="org-variable-name">fd</span>=open(OUT_NAME,O_CREAT | O_WRONLY,0666);
        <span class="org-type">FileSink</span> <span class="org-function-name">sink</span>(fd);
        compress_fsize=<span class="org-constant">snappy</span>::Compress(&amp;source,&amp;sink);
        close(fd);
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">do decompress</span>
    <span class="org-variable-name">stat</span>(OUT_NAME,&amp;stbuf);
    <span class="org-type">size_t</span> <span class="org-variable-name">out_fsize</span>=stbuf.st_size;
    assert(out_fsize==compress_fsize);
    <span class="org-type">char</span>* <span class="org-variable-name">out_buf</span>=<span class="org-keyword">new</span> <span class="org-type">char</span>[out_fsize];
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">out</span>;
    {
        <span class="org-type">FILE</span>* <span class="org-variable-name">fin</span>=fopen(OUT_NAME,<span class="org-string">"rb"</span>);
        fread(out_buf,1,out_fsize,fin);
        fclose(fin);
        assert(<span class="org-constant">snappy</span>::Uncompress(out_buf,out_fsize,&amp;out)==<span class="org-constant">true</span>);
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">do validate</span>
    assert(out.size()==in_fsize);
    assert(memcmp(out.data(),in_buf,in_fsize)==0);
    <span class="org-keyword">delete</span> [] in_buf;
    <span class="org-keyword">delete</span> [] out_buf;
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
