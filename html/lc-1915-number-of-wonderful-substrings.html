<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LC 1915. 最美子字符串的数目</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">LC 1915. 最美子字符串的数目</h1>
<p>
<a href="https://leetcode-cn.com/contest/weekly-contest-247/problems/number-of-wonderful-substrings/">https://leetcode-cn.com/contest/weekly-contest-247/problems/number-of-wonderful-substrings/</a>
</p>

<p>
最开始使用动态规划的思路，但是超时了。从计算规模上看，也可能看出是要超时的（10^7）。
</p>

<p>
关于这个动态规划的状态可以看注释，几个问题：
</p>
<ol class="org-ol">
<li>大量不必要的data movement. 比如 `for s in range(1024)` 这个循环估计里面有不少是0</li>
<li>最主要的问题是，其实我们不关心字符串结尾是在具体哪个位置上。而为了维护这个具体位置，我们需要额外的工作来维护这个结构</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env python</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">coding:utf-8</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Copyright (C) dirlt</span>

<span class="org-py-import-from">from</span> typing <span class="org-py-import-from">import</span> List
<span class="org-py-import-from">from</span> collections <span class="org-py-import-from">import</span> Counter, defaultdict, deque
<span class="org-py-import-from">from</span> functools <span class="org-py-import-from">import</span> lru_cache
<span class="org-py-import-from">import</span> heapq


<span class="org-py-def-class">class</span> <span class="org-py-class-name">Solution</span>:
    <span class="org-py-def-class">def</span> <span class="org-function-name">wonderfulSubstrings</span>(<span class="org-py-object-reference">self</span>, word: <span class="org-py-builtins">str</span>) -&gt; <span class="org-py-builtins">int</span>:
        <span class="org-py-variable-name">dp</span> = [[<span class="org-py-number">0</span>] * <span class="org-py-number">1024</span> <span class="org-keyword">for</span> <span class="org-py-builtins">_</span> <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">2</span>)]
        <span class="org-py-variable-name">now</span> = <span class="org-py-number">0</span>
        <span class="org-py-variable-name">ans</span> = <span class="org-py-number">0</span>
        <span class="org-comment"># dp[i][st] &#25130;&#27490;&#21040;ith&#36825;&#20010;&#23383;&#31526;&#20018;&#19978;&#65292;&#20197;ith&#20026;&#32467;&#23614;&#65292;&#21508;&#20010;state&#30340;&#20998;&#24067;&#24773;&#20917;</span>
        <span class="org-keyword">for</span> i, w <span class="org-keyword">in</span> <span class="org-py-builtins">enumerate</span>(word):
            <span class="org-py-variable-name">t</span> = <span class="org-py-builtins">ord</span>(w) - <span class="org-py-builtins">ord</span>(<span class="org-string">'a'</span>)
            <span class="org-keyword">for</span> s <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">1024</span>):
                dp[<span class="org-py-number">1</span> - now][s ^ (<span class="org-py-number">1</span> &lt;&lt; t)] = dp[now][s]
            dp[<span class="org-py-number">1</span> - now][<span class="org-py-number">1</span> &lt;&lt; t] += <span class="org-py-number">1</span>
            <span class="org-py-variable-name">now</span> = <span class="org-py-number">1</span> - now
            <span class="org-py-variable-name">ans</span> += dp[now][<span class="org-py-number">0</span>]
            <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">10</span>):
                <span class="org-py-variable-name">ans</span> += dp[now][<span class="org-py-number">1</span> &lt;&lt; j]
        <span class="org-keyword">return</span> ans
</pre>
</div>

<p>
下面这个实现是通过的实现，每次处理一个字符的时候，只关心之前有多少种符合条件的状态，而不关心这些状态的结束位置。
这个状态维护还比较难写对，我总结一下这个模式：
</p>
<ol class="org-ol">
<li>首先假设 `w` 已经进来了，所以acc更新为了 `acc ^ (1 &lt;&lt; t)`. 但是实际没有更新到表里面</li>
<li>然后按照 `acc` 这个状态去查找，所以肯定不会找到空串。</li>
<li>整个过程结束之后，最后更新表结构中 `cnt[acc]+=1`.</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span class="org-py-def-class">class</span> <span class="org-py-class-name">Solution</span>:
    <span class="org-py-def-class">def</span> <span class="org-function-name">wonderfulSubstrings</span>(<span class="org-py-object-reference">self</span>, word: <span class="org-py-builtins">str</span>) -&gt; <span class="org-py-builtins">int</span>:
        <span class="org-py-import-from">from</span> collections <span class="org-py-import-from">import</span> Counter
        <span class="org-py-variable-name">cnt</span> = Counter()
        <span class="org-py-variable-name">acc</span> = <span class="org-py-number">0</span>
        <span class="org-py-variable-name">ans</span> = <span class="org-py-number">0</span>

        <span class="org-py-variable-name">cnt</span>[<span class="org-py-number">0</span>] = <span class="org-py-number">1</span>
        <span class="org-keyword">for</span> i, w <span class="org-keyword">in</span> <span class="org-py-builtins">enumerate</span>(word):
            <span class="org-py-variable-name">t</span> = <span class="org-py-builtins">ord</span>(w) - <span class="org-py-builtins">ord</span>(<span class="org-string">'a'</span>)
            <span class="org-py-variable-name">acc</span> = acc ^ (<span class="org-py-number">1</span> &lt;&lt; t)
            <span class="org-comment"># xor([...i]) = acc</span>
            <span class="org-comment"># xor([..j]) = acc</span>
            <span class="org-comment"># then xor(j+1..i) = 0</span>
            <span class="org-py-variable-name">ans</span> += cnt[acc]

            <span class="org-comment"># xor([..i]) =acc</span>
            <span class="org-comment"># xor(..j]) = acc ^(1 &lt;&lt; x)</span>
            <span class="org-comment"># then xor(j+1..) = (1&lt;&lt;x)</span>
            <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">10</span>):
                <span class="org-py-variable-name">exp</span> = acc ^ (<span class="org-py-number">1</span> &lt;&lt; j)
                <span class="org-py-variable-name">ans</span> += cnt[exp]

            <span class="org-py-variable-name">cnt</span>[acc] += <span class="org-py-number">1</span>
        <span class="org-keyword">return</span> ans
</pre>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/lc-1915-number-of-wonderful-substrings.html';this.page.identifier = 'lc-1915-number-of-wonderful-substrings.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
