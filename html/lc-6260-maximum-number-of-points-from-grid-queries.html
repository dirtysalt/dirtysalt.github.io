<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LC 6260. 矩阵查询可获得的最大分数</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">LC 6260. 矩阵查询可获得的最大分数</h1>
<p>
<a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/">https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/</a>
</p>

<p>
这题从数据规模上看就需要进行离线处理。
</p>

<p>
批量计算的目的是求解：如果满足X值的话，最多可以访问多少个点。整个过程类似于BFS/Dijkstra算法，只不过每次扩展的时候，如果下一个点的值小于当前点的话，需要使用当前点的值进行扩展。
</p>

<p>
我们将可以访问到的值，记录在 `points` 这个字典里面。不过需要注意的是，这个`points`里面存储并不是累加的结果，也就是假设X&lt;Y, points[Y]里面并没有包含points[X]里面的值，这个最后需要累加起来。
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-py-def-class">class</span> <span class="org-py-class-name">Solution</span>:
    <span class="org-py-def-class">def</span> <span class="org-function-name">maxPoints</span>(<span class="org-py-object-reference">self</span>, grid: List[List[<span class="org-py-builtins">int</span>]], queries: List[<span class="org-py-builtins">int</span>]) -&gt; List[<span class="org-py-builtins">int</span>]:
        <span class="org-py-import-from">from</span> collections <span class="org-py-import-from">import</span> Counter
        <span class="org-py-import-from">import</span> heapq
        <span class="org-py-variable-name">points</span> = Counter()

        <span class="org-py-variable-name">n</span>, <span class="org-py-variable-name">m</span> = <span class="org-py-builtins">len</span>(grid), <span class="org-py-builtins">len</span>(grid[<span class="org-py-number">0</span>])
        <span class="org-py-variable-name">dq</span> = []
        dq.append((grid[<span class="org-py-number">0</span>][<span class="org-py-number">0</span>], <span class="org-py-number">0</span>, <span class="org-py-number">0</span>))
        <span class="org-py-variable-name">visited</span> = <span class="org-py-builtins">set</span>()
        visited.add((<span class="org-py-number">0</span>, <span class="org-py-number">0</span>))
        <span class="org-keyword">while</span> dq:
            (v, x, y) = heapq.heappop(dq)
            <span class="org-py-variable-name">points</span>[v] += <span class="org-py-number">1</span>
            <span class="org-keyword">for</span> dx, dy <span class="org-keyword">in</span> ((<span class="org-py-number">0</span>, <span class="org-py-number">1</span>), (<span class="org-py-number">0</span>, -<span class="org-py-number">1</span>), (<span class="org-py-number">1</span>, <span class="org-py-number">0</span>), (-<span class="org-py-number">1</span>, <span class="org-py-number">0</span>)):
                <span class="org-py-variable-name">x2</span>, <span class="org-py-variable-name">y2</span> = x + dx, y + dy
                <span class="org-keyword">if</span> <span class="org-py-number">0</span> &lt;= x2 &lt; n <span class="org-keyword">and</span> <span class="org-py-number">0</span> &lt;= y2 &lt; m:
                    <span class="org-keyword">if</span> (x2, y2) <span class="org-keyword">not</span> <span class="org-keyword">in</span> visited:
                        visited.add((x2, y2))
                        <span class="org-py-variable-name">value</span> = <span class="org-py-builtins">max</span>(grid[x2][y2], v)
                        heapq.heappush(dq, (value, x2, y2))

</pre>
</div>

<p>
得到 points 这个数组之后，我们可以将Query合并进行，使用Marzullo算法，就可以得到每个query对应的结果。
</p>

<p>
我们这里设置 query对应的 event_type=0, 而points对应的 event_type=1, 因为query查询的是严格大于当前单元格的结果。
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-py-variable-name">events</span> = [(k, <span class="org-py-number">1</span>, v) <span class="org-keyword">for</span> k, v <span class="org-keyword">in</span> points.items()]
<span class="org-py-variable-name">events</span> += [(q, <span class="org-py-number">0</span>, i) <span class="org-keyword">for</span> (i, q) <span class="org-keyword">in</span> <span class="org-py-builtins">enumerate</span>(queries)]
events.sort()
<span class="org-py-variable-name">ans</span> = [<span class="org-py-number">0</span>] * <span class="org-py-builtins">len</span>(queries)

<span class="org-py-variable-name">res</span> = <span class="org-py-number">0</span>
<span class="org-keyword">for</span> k, ev, v <span class="org-keyword">in</span> events:
    <span class="org-keyword">if</span> <span class="org-py-variable-name">ev</span> == <span class="org-py-number">0</span>:
        <span class="org-py-variable-name">ans</span>[v] = res
    <span class="org-keyword">else</span>:
        <span class="org-py-variable-name">res</span> += v
<span class="org-keyword">return</span> ans
</pre>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/lc-6260-maximum-number-of-points-from-grid-queries.html';this.page.identifier = 'lc-6260-maximum-number-of-points-from-grid-queries.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
