<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>生成迷宫图</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">生成迷宫图</h1>
<p>
<a href="http://code.activestate.com/recipes/578356-random-maze-generator/">http://code.activestate.com/recipes/578356-random-maze-generator/</a>
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">https://en.wikipedia.org/wiki/Maze_generation_algorithm</a>
</p>

<p>
想实现A*算法和BFS比较验证正确性，所以想构造数据来跑测试，迷宫图是比较好的例子。
Wikipedia上给出了很多种生成迷宫图的算法。
</p>

<p>
下面是一份生成迷宫图的代码，大致思路是使用DFS进行探路，所有检查过的地方都标记”可以访问“。
这份代码只能指定初始点，没有办法指定结束点，结束点可以在所有到达过的”可以访问“点上任意选择。
因为每次只需要扩展一个节点，所以使用显式的栈也非常简单。
</p>

<p>
为了不产生回路这样的情况，在扩展下一个节点的时候，会看这个节点是否只有1个可以访问的节点。
代码最后还利用PIL生成了图像，我觉得为了好看，应该白色的地方是”可以访问节点“，而黑色地方是障碍物。
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Random Maze Generator using Depth-first Search</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">http://en.wikipedia.org/wiki/Maze_generation_algorithm</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">FB - 20121214</span>
<span class="org-py-import-from">import</span> random
<span class="org-py-import-from">from</span> PIL <span class="org-py-import-from">import</span> Image
<span class="org-py-variable-name">imgx</span> = <span class="org-py-number">500</span>; <span class="org-py-variable-name">imgy</span> = <span class="org-py-number">500</span>
<span class="org-py-variable-name">image</span> = Image.new(<span class="org-string">"RGB"</span>, (imgx, imgy))
<span class="org-py-variable-name">pixels</span> = image.load()
<span class="org-py-variable-name">mx</span> = <span class="org-py-number">100</span>; <span class="org-py-variable-name">my</span> = <span class="org-py-number">100</span> <span class="org-comment"># width and height of the maze</span>
<span class="org-py-variable-name">maze</span> = [[<span class="org-py-number">0</span> <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(mx)] <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(my)]
<span class="org-py-variable-name">dx</span> = [<span class="org-py-number">0</span>, <span class="org-py-number">1</span>, <span class="org-py-number">0</span>, -<span class="org-py-number">1</span>]; <span class="org-py-variable-name">dy</span> = [-<span class="org-py-number">1</span>, <span class="org-py-number">0</span>, <span class="org-py-number">1</span>, <span class="org-py-number">0</span>] <span class="org-comment"># 4 directions to move in the maze</span>
<span class="org-py-variable-name">color</span> = [(<span class="org-py-number">0</span>,<span class="org-py-number">0</span>, <span class="org-py-number">0</span>), (<span class="org-py-number">255</span>, <span class="org-py-number">255</span>, <span class="org-py-number">255</span>)] <span class="org-comment"># RGB colors of the maze</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">start the maze from a random cell</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">stack = [(random.randint(0, mx - 1), random.randint(0, my - 1))]</span>
<span class="org-py-variable-name">stack</span> = [(<span class="org-py-number">0</span>, <span class="org-py-number">0</span>)]

<span class="org-keyword">while</span> <span class="org-py-builtins">len</span>(stack) &gt; <span class="org-py-number">0</span>:
    (cx, cy) = stack[-<span class="org-py-number">1</span>]
    maze[cy][cx] = <span class="org-py-number">1</span>
    <span class="org-comment"># find a new cell to add</span>
    <span class="org-py-variable-name">nlst</span> = [] <span class="org-comment"># list of available neighbors</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">4</span>):
        <span class="org-py-variable-name">nx</span> = cx + dx[i]; <span class="org-py-variable-name">ny</span> = cy + dy[i]
        <span class="org-keyword">if</span> nx &gt;= <span class="org-py-number">0</span> <span class="org-keyword">and</span> nx &lt; mx <span class="org-keyword">and</span> ny &gt;= <span class="org-py-number">0</span> <span class="org-keyword">and</span> ny &lt; my:
            <span class="org-keyword">if</span> maze[ny][nx] == <span class="org-py-number">0</span>:
                <span class="org-comment"># of occupied neighbors must be 1</span>
                <span class="org-py-variable-name">ctr</span> = <span class="org-py-number">0</span>
                <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-number">4</span>):
                    <span class="org-py-variable-name">ex</span> = nx + dx[j]; <span class="org-py-variable-name">ey</span> = ny + dy[j]
                    <span class="org-keyword">if</span> ex &gt;= <span class="org-py-number">0</span> <span class="org-keyword">and</span> ex &lt; mx <span class="org-keyword">and</span> ey &gt;= <span class="org-py-number">0</span> <span class="org-keyword">and</span> ey &lt; my:
                        <span class="org-keyword">if</span> maze[ey][ex] == <span class="org-py-number">1</span>: <span class="org-py-variable-name">ctr</span> += <span class="org-py-number">1</span>
                <span class="org-keyword">if</span> <span class="org-py-variable-name">ctr</span> == <span class="org-py-number">1</span>: nlst.append(i)
    <span class="org-comment"># if 1 or more neighbors available then randomly select one and move</span>
    <span class="org-keyword">if</span> <span class="org-py-builtins">len</span>(nlst) &gt; <span class="org-py-number">0</span>:
        <span class="org-py-variable-name">ir</span> = nlst[random.randint(<span class="org-py-number">0</span>, <span class="org-py-builtins">len</span>(nlst) - <span class="org-py-number">1</span>)]
        <span class="org-py-variable-name">cx</span> += dx[ir]; <span class="org-py-variable-name">cy</span> += dy[ir]
        stack.append((cx, cy))
    <span class="org-keyword">else</span>: stack.pop()

<span class="org-comment-delimiter"># </span><span class="org-comment">&#32763;&#36716;&#39068;&#33394;&#65292;&#30333;&#33394;&#26159;&#21487;&#20197;&#35775;&#38382;&#33410;&#28857;&#65292;&#40657;&#33394;&#26159;&#19981;&#21487;&#20197;&#35775;&#38382;&#33410;&#28857;&#12290;</span>
<span class="org-keyword">for</span> x <span class="org-keyword">in</span> maze:
    <span class="org-py-variable-name">x</span> = [(<span class="org-py-number">1</span>-v) <span class="org-keyword">for</span> v <span class="org-keyword">in</span> x]

<span class="org-comment-delimiter"># </span><span class="org-comment">paint the maze</span>
<span class="org-keyword">for</span> ky <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(imgy):
    <span class="org-keyword">for</span> kx <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(imgx):
        <span class="org-py-variable-name">pixels</span>[kx, ky] = color[maze[my * ky // imgy][mx * kx // imgx]]
image.save(<span class="org-string">"Maze_"</span> + <span class="org-py-builtins">str</span>(mx) + <span class="org-string">"x"</span> + <span class="org-py-builtins">str</span>(my) + <span class="org-string">".png"</span>, <span class="org-string">"PNG"</span>)

</pre>
</div>


<div id="org669f8a5" class="figure">
<p><img src="../images/GenMaze100x100.png" alt="GenMaze100x100.png" />
</p>
</div>

<hr />

<p>
UPDATE@202301 上面打印出来的图片有点不太友好，我重新找了另外一个版本 <a href="https://scipython.com/blog/making-a-maze/">https://scipython.com/blog/making-a-maze/</a> 可以打印出SVG, 但是好像输出难度不是特别高
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">make_maze.py</span>
<span class="org-py-import-from">import</span> random


<span class="org-comment-delimiter"># </span><span class="org-comment">Create a maze using the depth-first algorithm described at</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">https://scipython.com/blog/making-a-maze/</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Christian Hill, April 2017.</span>

<span class="org-py-def-class">class</span> <span class="org-py-class-name">Cell</span>:
    <span class="org-string">"""A cell in the maze.</span>

<span class="org-string">    A maze "Cell" is a point in the grid which may be surrounded by walls to</span>
<span class="org-string">    the north, east, south or west.</span>

<span class="org-string">    """</span>

    <span class="org-comment"># A wall separates a pair of cells in the N-S or W-E directions.</span>
    <span class="org-py-variable-name">wall_pairs</span> = {<span class="org-string">'N'</span>: <span class="org-string">'S'</span>, <span class="org-string">'S'</span>: <span class="org-string">'N'</span>, <span class="org-string">'E'</span>: <span class="org-string">'W'</span>, <span class="org-string">'W'</span>: <span class="org-string">'E'</span>}

    <span class="org-py-def-class">def</span> <span class="org-function-name">__init__</span>(<span class="org-py-object-reference">self</span>, x, y):
        <span class="org-string">"""Initialize the cell at (x,y). At first it is surrounded by walls."""</span>

        <span class="org-py-object-reference">self</span>.x, <span class="org-py-object-reference">self</span>.y = x, y
        <span class="org-py-object-reference">self</span>.walls = {<span class="org-string">'N'</span>: <span class="org-py-pseudo-keyword">True</span>, <span class="org-string">'S'</span>: <span class="org-py-pseudo-keyword">True</span>, <span class="org-string">'E'</span>: <span class="org-py-pseudo-keyword">True</span>, <span class="org-string">'W'</span>: <span class="org-py-pseudo-keyword">True</span>}

    <span class="org-py-def-class">def</span> <span class="org-function-name">has_all_walls</span>(<span class="org-py-object-reference">self</span>):
        <span class="org-string">"""Does this cell still have all its walls?"""</span>

        <span class="org-keyword">return</span> <span class="org-py-builtins">all</span>(<span class="org-py-object-reference">self</span>.walls.values())

    <span class="org-py-def-class">def</span> <span class="org-function-name">knock_down_wall</span>(<span class="org-py-object-reference">self</span>, other, wall):
        <span class="org-string">"""Knock down the wall between cells self and other."""</span>

        <span class="org-py-object-reference">self</span>.walls[wall] = <span class="org-py-pseudo-keyword">False</span>
        other.walls[Cell.wall_pairs[wall]] = <span class="org-py-pseudo-keyword">False</span>


<span class="org-py-def-class">class</span> <span class="org-py-class-name">Maze</span>:
    <span class="org-string">"""A Maze, represented as a grid of cells."""</span>

    <span class="org-py-def-class">def</span> <span class="org-function-name">__init__</span>(<span class="org-py-object-reference">self</span>, nx, ny, <span class="org-py-variable-name">ix</span>=<span class="org-py-number">0</span>, <span class="org-py-variable-name">iy</span>=<span class="org-py-number">0</span>):
        <span class="org-string">"""Initialize the maze grid.</span>
<span class="org-string">        The maze consists of nx x ny cells and will be constructed starting</span>
<span class="org-string">        at the cell indexed at (ix, iy).</span>

<span class="org-string">        """</span>

        <span class="org-py-object-reference">self</span>.nx, <span class="org-py-object-reference">self</span>.ny = nx, ny
        <span class="org-py-object-reference">self</span>.ix, <span class="org-py-object-reference">self</span>.iy = ix, iy
        <span class="org-py-object-reference">self</span>.maze_map = [[Cell(x, y) <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(ny)] <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(nx)]

    <span class="org-py-def-class">def</span> <span class="org-function-name">cell_at</span>(<span class="org-py-object-reference">self</span>, x, y):
        <span class="org-string">"""Return the Cell object at (x,y)."""</span>

        <span class="org-keyword">return</span> <span class="org-py-object-reference">self</span>.maze_map[x][y]

    <span class="org-py-def-class">def</span> <span class="org-function-name">__str__</span>(<span class="org-py-object-reference">self</span>):
        <span class="org-string">"""Return a (crude) string representation of the maze."""</span>

        <span class="org-py-variable-name">maze_rows</span> = [<span class="org-string">'-'</span> * <span class="org-py-object-reference">self</span>.nx * <span class="org-py-number">2</span>]
        <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-object-reference">self</span>.ny):
            <span class="org-py-variable-name">maze_row</span> = [<span class="org-string">'|'</span>]
            <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-object-reference">self</span>.nx):
                <span class="org-keyword">if</span> <span class="org-py-object-reference">self</span>.maze_map[x][y].walls[<span class="org-string">'E'</span>]:
                    maze_row.append(<span class="org-string">' |'</span>)
                <span class="org-keyword">else</span>:
                    maze_row.append(<span class="org-string">'  '</span>)
            maze_rows.append(<span class="org-string">''</span>.join(maze_row))
            <span class="org-py-variable-name">maze_row</span> = [<span class="org-string">'|'</span>]
            <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-object-reference">self</span>.nx):
                <span class="org-keyword">if</span> <span class="org-py-object-reference">self</span>.maze_map[x][y].walls[<span class="org-string">'S'</span>]:
                    maze_row.append(<span class="org-string">'-+'</span>)
                <span class="org-keyword">else</span>:
                    maze_row.append(<span class="org-string">' +'</span>)
            maze_rows.append(<span class="org-string">''</span>.join(maze_row))
        <span class="org-keyword">return</span> <span class="org-string">'\n'</span>.join(maze_rows)

    <span class="org-py-def-class">def</span> <span class="org-function-name">write_svg</span>(<span class="org-py-object-reference">self</span>, filename, <span class="org-py-variable-name">height</span>=<span class="org-py-number">500</span>):
        <span class="org-string">"""Write an SVG image of the maze to filename."""</span>

        <span class="org-py-variable-name">aspect_ratio</span> = <span class="org-py-object-reference">self</span>.nx / <span class="org-py-object-reference">self</span>.ny
        <span class="org-comment"># Pad the maze all around by this amount.</span>
        <span class="org-py-variable-name">padding</span> = <span class="org-py-number">10</span>
        <span class="org-comment"># Height and width of the maze image (excluding padding), in pixels</span>
        <span class="org-py-variable-name">width</span> = <span class="org-py-builtins">int</span>(height * aspect_ratio)
        <span class="org-comment"># Scaling factors mapping maze coordinates to image coordinates</span>
        <span class="org-py-variable-name">scy</span>, <span class="org-py-variable-name">scx</span> = height / <span class="org-py-object-reference">self</span>.ny, width / <span class="org-py-object-reference">self</span>.nx

        <span class="org-py-def-class">def</span> <span class="org-function-name">write_wall</span>(ww_f, ww_x1, ww_y1, ww_x2, ww_y2):
            <span class="org-string">"""Write a single wall to the SVG image file handle f."""</span>

            <span class="org-keyword">print</span>(<span class="org-string">'&lt;line x1="{}" y1="{}" x2="{}" y2="{}"/&gt;'</span>
                  .format(ww_x1, ww_y1, ww_x2, ww_y2), <span class="org-py-builtins">file</span>=ww_f)

        <span class="org-comment"># Write the SVG image file for maze</span>
        <span class="org-keyword">with</span> <span class="org-py-builtins">open</span>(filename, <span class="org-string">'w'</span>) <span class="org-keyword">as</span> f:
            <span class="org-comment"># SVG preamble and styles.</span>
            <span class="org-keyword">print</span>(<span class="org-string">'&lt;?xml version="1.0" encoding="utf-8"?&gt;'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'&lt;svg xmlns="http://www.w3.org/2000/svg"'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'    xmlns:xlink="http://www.w3.org/1999/xlink"'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'    width="{:d}" height="{:d}" viewBox="{} {} {} {}"&gt;'</span>
                  .format(width + <span class="org-py-number">2</span> * padding, height + <span class="org-py-number">2</span> * padding,
                          -padding, -padding, width + <span class="org-py-number">2</span> * padding, height + <span class="org-py-number">2</span> * padding),
                  <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'&lt;defs&gt;\n&lt;style type="text/css"&gt;&lt;![CDATA['</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'line {'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'    stroke: #000000;\n    stroke-linecap: square;'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'    stroke-width: 5;\n}'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">']]&gt;&lt;/style&gt;\n&lt;/defs&gt;'</span>, <span class="org-py-builtins">file</span>=f)
            <span class="org-comment"># Draw the "South" and "East" walls of each cell, if present (these</span>
            <span class="org-comment"># are the "North" and "West" walls of a neighbouring cell in</span>
            <span class="org-comment"># general, of course).</span>
            <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-object-reference">self</span>.nx):
                <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-py-builtins">range</span>(<span class="org-py-object-reference">self</span>.ny):
                    <span class="org-keyword">if</span> <span class="org-py-object-reference">self</span>.cell_at(x, y).walls[<span class="org-string">'S'</span>]:
                        <span class="org-py-variable-name">x1</span>, <span class="org-py-variable-name">y1</span>, <span class="org-py-variable-name">x2</span>, <span class="org-py-variable-name">y2</span> = x * scx, (y + <span class="org-py-number">1</span>) * scy, (x + <span class="org-py-number">1</span>) * scx, (y + <span class="org-py-number">1</span>) * scy
                        write_wall(f, x1, y1, x2, y2)
                    <span class="org-keyword">if</span> <span class="org-py-object-reference">self</span>.cell_at(x, y).walls[<span class="org-string">'E'</span>]:
                        <span class="org-py-variable-name">x1</span>, <span class="org-py-variable-name">y1</span>, <span class="org-py-variable-name">x2</span>, <span class="org-py-variable-name">y2</span> = (x + <span class="org-py-number">1</span>) * scx, y * scy, (x + <span class="org-py-number">1</span>) * scx, (y + <span class="org-py-number">1</span>) * scy
                        write_wall(f, x1, y1, x2, y2)
            <span class="org-comment"># Draw the North and West maze border, which won't have been drawn</span>
            <span class="org-comment"># by the procedure above.</span>
            <span class="org-keyword">print</span>(<span class="org-string">'&lt;line x1="0" y1="0" x2="{}" y2="0"/&gt;'</span>.format(width), <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'&lt;line x1="0" y1="0" x2="0" y2="{}"/&gt;'</span>.format(height), <span class="org-py-builtins">file</span>=f)
            <span class="org-keyword">print</span>(<span class="org-string">'&lt;/svg&gt;'</span>, <span class="org-py-builtins">file</span>=f)

    <span class="org-py-def-class">def</span> <span class="org-function-name">find_valid_neighbours</span>(<span class="org-py-object-reference">self</span>, cell):
        <span class="org-string">"""Return a list of unvisited neighbours to cell."""</span>

        <span class="org-py-variable-name">delta</span> = [(<span class="org-string">'W'</span>, (-<span class="org-py-number">1</span>, <span class="org-py-number">0</span>)),
                 (<span class="org-string">'E'</span>, (<span class="org-py-number">1</span>, <span class="org-py-number">0</span>)),
                 (<span class="org-string">'S'</span>, (<span class="org-py-number">0</span>, <span class="org-py-number">1</span>)),
                 (<span class="org-string">'N'</span>, (<span class="org-py-number">0</span>, -<span class="org-py-number">1</span>))]
        <span class="org-py-variable-name">neighbours</span> = []
        <span class="org-keyword">for</span> direction, (dx, dy) <span class="org-keyword">in</span> delta:
            <span class="org-py-variable-name">x2</span>, <span class="org-py-variable-name">y2</span> = cell.x + dx, cell.y + dy
            <span class="org-keyword">if</span> (<span class="org-py-number">0</span> &lt;= x2 &lt; <span class="org-py-object-reference">self</span>.nx) <span class="org-keyword">and</span> (<span class="org-py-number">0</span> &lt;= y2 &lt; <span class="org-py-object-reference">self</span>.ny):
                <span class="org-py-variable-name">neighbour</span> = <span class="org-py-object-reference">self</span>.cell_at(x2, y2)
                <span class="org-keyword">if</span> neighbour.has_all_walls():
                    neighbours.append((direction, neighbour))
        <span class="org-keyword">return</span> neighbours

    <span class="org-py-def-class">def</span> <span class="org-function-name">make_maze</span>(<span class="org-py-object-reference">self</span>):
        <span class="org-comment"># Total number of cells.</span>
        <span class="org-py-variable-name">n</span> = <span class="org-py-object-reference">self</span>.nx * <span class="org-py-object-reference">self</span>.ny
        <span class="org-py-variable-name">cell_stack</span> = []
        <span class="org-py-variable-name">current_cell</span> = <span class="org-py-object-reference">self</span>.cell_at(<span class="org-py-object-reference">self</span>.ix, <span class="org-py-object-reference">self</span>.iy)
        <span class="org-comment"># Total number of visited cells during maze construction.</span>
        <span class="org-py-variable-name">nv</span> = <span class="org-py-number">1</span>

        <span class="org-keyword">while</span> nv &lt; n:
            <span class="org-py-variable-name">neighbours</span> = <span class="org-py-object-reference">self</span>.find_valid_neighbours(current_cell)

            <span class="org-keyword">if</span> <span class="org-keyword">not</span> neighbours:
                <span class="org-comment"># We've reached a dead end: backtrack.</span>
                <span class="org-py-variable-name">current_cell</span> = cell_stack.pop()
                <span class="org-keyword">continue</span>

            <span class="org-comment"># Choose a random neighbouring cell and move to it.</span>
            <span class="org-py-variable-name">direction</span>, <span class="org-py-variable-name">next_cell</span> = random.choice(neighbours)
            current_cell.knock_down_wall(next_cell, direction)
            cell_stack.append(current_cell)
            <span class="org-py-variable-name">current_cell</span> = next_cell
            <span class="org-py-variable-name">nv</span> += <span class="org-py-number">1</span>


<span class="org-py-def-class">def</span> <span class="org-function-name">make_maze</span>(output, nx, ny, ix, iy, height):
    <span class="org-py-variable-name">maze</span> = Maze(nx, ny, ix, iy)
    maze.make_maze()
    maze.write_svg(output, <span class="org-py-variable-name">height</span>=height)


<span class="org-comment-delimiter"># </span><span class="org-comment">Maze dimensions (ncols, nrows)</span>
<span class="org-py-variable-name">nx</span>, <span class="org-py-variable-name">ny</span> = <span class="org-py-number">30</span>, <span class="org-py-number">30</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Maze entry position</span>
<span class="org-py-variable-name">ix</span>, <span class="org-py-variable-name">iy</span> = <span class="org-py-number">0</span>, <span class="org-py-number">0</span>
<span class="org-py-variable-name">height</span> = <span class="org-py-number">600</span>
make_maze(<span class="org-string">'maze.svg'</span>, nx, ny, ix, iy, height)
</pre>
</div>


<div id="orgec430f5" class="figure">
<p><img src="../images/GenMaze30x30.svg" alt="GenMaze30x30.svg" class="org-svg" />
</p>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/generate-maze.html';this.page.identifier = 'generate-maze.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
