<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hadoop权威指南(笔记)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="dirtysalt" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content">
<h1 class="title">Hadoop权威指南(笔记)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org212f6d4">1. 初识Hadoop</a></li>
<li><a href="#org9d16fed">2. 关于MapReduce</a></li>
<li><a href="#org0102359">3. Hadoop分布式文件系统</a></li>
<li><a href="#orgf6fce58">4. Hadoop IO</a></li>
<li><a href="#orged7cdd6">5. MapReduce应用开发</a></li>
<li><a href="#orgd244905">6. MapReduce的工作机制</a></li>
<li><a href="#org155486d">7. MapReduce的类型与格式</a></li>
<li><a href="#orgb3beb21">8. MapReduce的特性</a></li>
<li><a href="#org3fb52e2">9. 构建Hadoop集群</a></li>
<li><a href="#org8a65061">10. 管理Hadoop</a></li>
</ul>
</div>
</div>
<div id="outline-container-org212f6d4" class="outline-2">
<h2 id="org212f6d4"><span class="section-number-2">1</span> 初识Hadoop</h2>
<div class="outline-text-2" id="text-1">
<p>
古代，人们用牛来拉中午，当一头牛拉不动一根圆木的时候，他们不曾想过培育更大更壮的牛。同样，我们也不需要尝试开发超级计算机，而应试着结合使用更多计算机系统。
</p>
</div>
</div>

<div id="outline-container-org9d16fed" class="outline-2">
<h2 id="org9d16fed"><span class="section-number-2">2</span> 关于MapReduce</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>设置HADOOP_CLASSPATH就可以直接使用hadoop CLASSNAME来在本地运行mapreduce程序。</li>
<li>hadoop jar $HADOOP_HOME/contrib/streaming/hadoop-streaming-0.20.2-cdh3u3.jar 可以用来启动streaming任务
<ul class="org-ul">
<li>使用stdin/stdout来作为输入和输出
<ul class="org-ul">
<li>Input/Output Format</li>
<li>外围环境的访问比如访问hdfs以及hbase</li>
<li>程序打包。比如使用很多第三方库的话在其他机器上面没有部署。</li>
</ul></li>
</ul></li>
<li>hadoop pipes 可以用来启动pipes任务
<ul class="org-ul">
<li>Hadoop的Pipes是Hadoop MapReduce的C++接口代称</li>
<li>使用Unix Domain Socket来作为输入和输出</li>
<li>#note: 可能使用上面还是没有native mr或者是streaming方式方便</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org0102359" class="outline-2">
<h2 id="org0102359"><span class="section-number-2">3</span> Hadoop分布式文件系统</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>使用hadoop archive能够将大量小文档打包，存档文件之能够只读访问
<ul class="org-ul">
<li>使用hadoop archive -archiveName &lt;file&gt;.har -p &lt;parent-path&gt; src dst</li>
<li>存档过程使用mapreduce完成，输出结果为目录
<ul class="org-ul">
<li>part-0 表示存档内容文件，应该是使用一个reduce做聚合。</li>
<li>_index,_masterindex 是对存档内容文件的索引文件。</li>
</ul></li>
<li>har(hadoop archive)文件系统是建立在其他文件系统上面的，比如hdfs或者是local fs.
<ul class="org-ul">
<li>hadoop fs -ls har:///file.har 那么访问的是默认的文件系统上面的file.har</li>
<li>如果想显示地访问hdfs文件系统的话，那么可以hadoop fs -ls har://hdfs-localhost:9000/file.har</li>
<li>如果想显示地访问本地文件系统的话，那么可以使用hadoop fs -ls har://file-localhost/file.har</li>
<li>hadoop fs -ls har://schema-&lt;host&gt;/&lt;path&gt; 是通用的访问方式</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf6fce58" class="outline-2">
<h2 id="orgf6fce58"><span class="section-number-2">4</span> Hadoop IO</h2>
<div class="outline-text-2" id="text-4">
<hr />
<ul class="org-ul">
<li>文件系统
<ul class="org-ul">
<li>ChecksumFileSystem
<ul class="org-ul">
<li>使用decorator设计模式，底层filesystem称为RawFileSystem</li>
<li>对于每个文件filename都会创建.filename.crc文件存储校验和</li>
<li>计算crc的单位大小通过io.bytes.per.checksum来进行控制</li>
<li>读取文件如果出现错误的话，那么会抛出ChecksumException</li>
<li>考虑到存在多副本的情况，如果读取某个副本出错的话，期间那么会调用reportChecksumFailure方法</li>
<li>#note: 这个部分的代码不太好读，非常绕</li>
</ul></li>
<li>RawLocalFileSystem
<ul class="org-ul">
<li>本地文件系统</li>
</ul></li>
<li>LocalFileSystem
<ul class="org-ul">
<li>RawLocalFileSystem + ChecksumFileSystem</li>
<li>reportChecksumFailure实现为将校验和存在问题的文件移动到bad_files边际文件夹（side directory）</li>
</ul></li>
<li>DistributedFileSystem
<ul class="org-ul">
<li>分布式文件系统</li>
</ul></li>
<li>ChecksumDistributedFileSystem
<ul class="org-ul">
<li>DistributedFileSystem + ChecksumFileSystem</li>
</ul></li>
</ul></li>
</ul>

<hr />
<ul class="org-ul">
<li>压缩解压
<ul class="org-ul">
<li>DEFLATE org.apache.hadoop.io.compress.DefaultCodec 扩展名.defalte</li>
<li>Gzip org.apache.hadoop.io.compress.GzipCodec 扩展名.gz 使用DEFLATE算法但是增加了额外的文件头。</li>
<li>bzip2 org.apache.hadoop.io.compress.BZip2Codec 扩展名.bz2 自身支持文件切分，内置同步点。</li>
<li>LZO com.hadoop.compression.lzo.LzopCodec 扩展名.lzo 和lzop工具兼容，LZO算法增加了额外的文件头。
<ul class="org-ul">
<li>LzopCodec则是纯lzo格式的codec,使用.lzo_deflate作为文件扩展名</li>
<li>因为LZO代码库拥有GPL许可，因此没有办法包含在Apache的发行版本里面。</li>
</ul></li>
<li>运行MapReduce时候可能需要针对不同压缩文件解压读取，就需要构造CompressionCodec对象，我们可以通过CompressionCodecFactory来构造这个对象
<ul class="org-ul">
<li>CompressionCodecFactory读取变量io.compression.codecs</li>
<li>然后根据输入文件的扩展名来选择使用何种codec.</li>
<li>getDefaultExtension</li>
</ul></li>
<li>压缩和解压算法可能同时存在Java实现和原生实现
<ul class="org-ul">
<li>如果是原生实现的话通常是.so，那么需要设置java.library.path或者是在环境变量里面设置LD_LIBRARY_PATH</li>
<li>如果同时有原生实现和Java实现，我们想只是使用原生实现的话，那么可以设置hadoop.native.lib = false来禁用原生实现。</li>
</ul></li>
<li>压缩算法涉及到对应的InputFormat,也就涉及到是否支持切分
<ul class="org-ul">
<li>对于一些不支持切分的文件，可能存在一些外部工具来建立索引，从而支持切分。</li>
</ul></li>
<li>下面这些选项可以针对map结果以及mapreduce结果进行压缩
<ul class="org-ul">
<li>mapred.output.compress = true 将mapreduce结果做压缩</li>
<li>mapred.output.compression.codec mapreduce压缩格式</li>
<li>mapred.output.compress.type = BLOCK/RECORD 如果输出格式为SequenceFile的话，那么这个参数可以控制是块压缩还是记录压缩</li>
<li>#note: 感觉MR的中间结果存储格式为SequenceFile</li>
<li>#note: 应该是IFile，但是是否共享了这个配置呢</li>
<li>mapred.compress.map.output = true 将map结果做压缩</li>
<li>mapred.map.output.compression.codec map压缩格式</li>
</ul></li>
</ul></li>
</ul>

<hr />
<ul class="org-ul">
<li>序列化
<ul class="org-ul">
<li>Hadoop的序列化都是基于Writable实现的，WritableComparable则是同时继承Writable,Comparable&lt;T&gt;.</li>
<li>序列化对象需要实现RawComparator，接口为public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)进行二进制比较。
<ul class="org-ul">
<li>WritableComparator简化了这个实现，继承WritableComparator就实现了这个接口</li>
<li>但是这个接口实现起来非常naive，就是将两个byte stream反序列化然后调用对象的compareTo实现</li>
<li>如果想要提高效率的话，可以考虑通过直接比较两个byte stream来做优化。</li>
</ul></li>
<li>基于文件的数据结构
<ul class="org-ul">
<li>SequenceFile 主要用来存储KV数据结构，多条记录之间会穿插一些同步标记，因此允许进行切分。</li>
</ul></li>
</ul></li>
</ul>
<ul class="org-ul">
<li>使用SequenceFileInputFormat和SequenceFileOutputFormat来读取和输出SequenceFile
<ul class="org-ul">
<li>hadoop fs -text 可以用来读取文件</li>
</ul></li>
<li><p>
mapred.output.compress.type = BLOCK/RECORD 可以用来控制压缩方式
</p>
<ul class="org-ul">
<li>如果没有使用压缩的话，那么格式为 recordLength(4byte) + keyLength(4byte) + key + value</li>
<li>如果使用记录压缩的话，那么格式为 recordLnegth(4byte) + keyLength(4byte) + key + compressedValue</li>
<li>如果使用块压缩的话，那么格式为 numberRecord(1-5byte) + keyLength(4byte) + compressedKeys + valueLength(4byte) + compressedValues.每个block之间会插入sync标记</li>
</ul>
<ul class="org-ul">
<li>块压缩大小可以使用io.seqfile.compress.blocksize来控制，默认1MB
<ul class="org-ul">
<li>MapFile 也是用来存储KV数据结构，但是可以认为已经按照了Key进行排序 #note: 要求添加顺序就按照Key排序</li>
</ul></li>
</ul></li>
<li>存储格式实际上也是SequenceFile，data，index都是。</li>
<li>底层会建立index，index在搜索的时候会加载到内存里面，这样可以减少data上的随机查询次数。
<ul class="org-ul">
<li>使用io.map.index.interval可以控制多少个item在index里面创建一个条目</li>
</ul></li>
<li><p>
使用io.map.index.skip = 0/1/2/n 可以控制skip几个index的item，如果为1的话那么表示只是使用1/2的索引。
</p>
<ul class="org-ul">
<li>从SequenceFile创建MapFile非常简单</li>
</ul>
<ul class="org-ul">
<li>首先使用sort将SequenceFile进行排序(可以使用hadoop example的sort）
<ul class="org-ul">
<li>然后调用hadoop MapFileFixer来建立索引</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orged7cdd6" class="outline-2">
<h2 id="orged7cdd6"><span class="section-number-2">5</span> MapReduce应用开发</h2>
<div class="outline-text-2" id="text-5">
<hr />
<ul class="org-ul">
<li>Configuration用来读取配置文件，功能还是比较强大的，有变量替换的功能
<ul class="org-ul">
<li>&lt;property&gt;&lt;name&gt;&#x2026;&lt;/name&gt;&lt;value&gt;&#x2026;&lt;/value&gt;&lt;/property&gt;</li>
<li>如果使用&lt;final&gt;true&lt;/final&gt;标记的话那么这个变量不允许被重置</li>
<li>变量替换可以使用${variable}</li>
<li>通过addResource来添加读取的配置文件</li>
</ul></li>
</ul>

<hr />
<ul class="org-ul">
<li>Hadoop集群有三种工作方式，分别为
<ul class="org-ul">
<li>standalone 使用单个JVM进程来模拟
<ul class="org-ul">
<li>如果不进行任何配置的话默认使用这个模式</li>
<li>fs.default.name = file 本地文件系统</li>
<li>mapred.job.tracker = local</li>
</ul></li>
<li>pseudo-distributed 本地启动单节点集群
<ul class="org-ul">
<li>fs.default.name = hdfs://localhost</li>
<li>mapred.job.tracker = localhost:8021</li>
</ul></li>
<li>fully-distributed 完全分布式环境
<ul class="org-ul">
<li>fs.default.name = hdfs://&lt;namenode&gt;</li>
<li>mapred.job.tracer = &lt;jobtracker&gt;:8021</li>
</ul></li>
</ul></li>
</ul>

<hr />
<ul class="org-ul">
<li>使用hadoop启动MapReduce任务的常用参数
<ol class="org-ol">
<li>-D property=value 覆盖默认配置属性</li>
<li>-conf filename 添加配置文件</li>
<li>-fs uri 设置默认文件系统</li>
<li>-jt host:port 设置jobtracker</li>
<li>-files file,file2 这些文件可以在tasktracker工作目录下面访问</li>
<li>-archives archive,archive2 和files类似，但是是存档文件</li>
</ol></li>
</ul>
<ul class="org-ul">
<li>突然觉得这个差别在files只能是平级结构，而archive可以是层级结构。
<ol class="org-ol">
<li>-libjars jar1,jar2 和files类似，通常这些JAR文件是MapReduce所需要的。</li>
</ol></li>
</ul>

<hr />
<p>
如果希望运行时候动态创建集群的话，可以通过这几个类来创建
</p>
<ul class="org-ul">
<li>MiniDFSCluster</li>
<li>MiniMRCluster</li>
<li>MiniHBaseCluster</li>
<li>MiniZooKeeperClutser</li>
</ul>
<p>
另外还有自带的ClusterMapReduceTestCase以及HBaseTestingUtility来帮助进行mapreduce的testcase. 这些类散布在hadoop,hbase,hadoop-test以及hbase-test里面。
</p>

<p>
#note: 个人觉得可能还是没有本地测试方便
</p>

<hr />
<p>
job，task and attempt
</p>
<ul class="org-ul">
<li>jobID常见格式为 job_200904110811_0002
<ul class="org-ul">
<li>其中200904110811表示jobtracker从2009.04.11的08:11启动的</li>
<li>0002 表示第三个job,从0000开始计数。超过10000的话就不能够很好地排序</li>
</ul></li>
<li>taskID常见格式为 task_200904110811_0002_m_000003
<ul class="org-ul">
<li>前面一串数字和jobID匹配，表示从属于这个job</li>
<li>m表示map任务，r表示reduce任务</li>
<li>000003表示这是第4个map任务。顺序是在初始化时候指定的，并不反应具体的执行顺序。</li>
</ul></li>
<li>attemptID常见格式为 attempt_200904110811_0002_m_000003_0
<ul class="org-ul">
<li>前面一串数字和taskID匹配，表示从属与这个task</li>
<li>attempt出现的原因是因为一个task可能会因为失败重启或者是预测执行而执行多次</li>
<li>如果jobtracker重启而导致作业重启的话，那么做后面id从1000开始避免和原来的attempt冲突。</li>
</ul></li>
</ul>

<hr />
<p>
作业调试
</p>

<ul class="org-ul">
<li>相关配置
<ul class="org-ul">
<li>mapred.jobtracker.completeuserjobs.maximum 表示web页面下面展示completed jobs的个数，默认是100，超过的部分放到历史信息页。</li>
<li>mapred.jobtracker.restart.recover = true jobtracker重启之后自动恢复作业</li>
<li>hadoop.job.history.location 历史作业信息存放位置，超过30天删除，默认在_logs/history</li>
<li>hadoop.job.history.user.location 如果不为none那么历史作业信息在这里也会存在一份，不会删除。</li>
</ul></li>
<li>相关命令
<ul class="org-ul">
<li>hadoop fs -getmerge &lt;src&gt; &lt;dst&gt; 能够将hdfs的src下面所有的文件merge合并成为一份文件并且copy到本地</li>
<li>hadoop job -history 察看作业历史</li>
<li>hadoop job -counter 察看作业计数器</li>
</ul></li>
<li>相关日志
<ul class="org-ul">
<li>系统守护进程日志 写入HADOOP_LOG_DIR里面，可以用来监控namenode以及datanode的运行情况</li>
<li>MapReduce作业历史日志 _logs/history</li>
<li>MapReduce任务日志 写入HADOOP_LOG_DIR/userlogs里面，可以用来监控每个job的运行情况</li>
</ul></li>
<li>分析任务
<ul class="org-ul">
<li>JobConf允许设置profile参数
<ul class="org-ul">
<li>#note: 新的接口里面JobConf-&gt;JobContext-&gt;Job，Job没有这些接口，但是可以通过Configuration来设置</li>
<li>setProfileEnabled 打开profile功能，默认false，属性 mapred.task.profile</li>
<li>setProfileParams 设置profile参数</li>
</ul></li>
</ul></li>
</ul>
<ul class="org-ul">
<li>属性 mapred.task.profile.params
<ul class="org-ul">
<li>默认使用hprof -agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s"</li>
</ul></li>
<li><p>
其中%s会替换成为profile输出文件
</p>
<ul class="org-ul">
<li>#note: 其实这里似乎也可以设置成为jmxremote来通过jvisualvm来调试</li>
</ul>
<ul class="org-ul">
<li>setProfileTaskRange(boolean,String)</li>
</ul></li>
<li>参数1表示针对map还是reduce task做profile, true表示map, false表示reduce</li>
<li>参数2表示针对哪些tasks做优化，"0-2"表示针对0，1，2三个任务，默认也是"0-2"</li>
<li>map task对应属性mapred.task.profile.maps，reduce task对应属性mapred.task.profile.reduces
<ul class="org-ul">
<li>任务重现
<ul class="org-ul">
<li>首先将keep.failed.task.files设置为true,这样如果任务失败的话，那么这个任务的输入和输出都会保留下来
<ul class="org-ul">
<li>如果是map任务的话，那么输入分别会在本地保留</li>
<li>如果是reduce任务的话，那么对应的map任务输出会在本地保留</li>
<li>然后我们使用hadoop IsolationRunner job.xml来重新运行这个任务</li>
<li>可以修改HADOOP_OPTS添加远程调试选项来启动这个任务。</li>
</ul></li>
<li>如果希望任务都保留而不仅仅是失败任务保留的话，那么可以设置 keep.task.files.pattern 为正则表达式（与保留的任务ID匹配）</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd244905" class="outline-2">
<h2 id="orgd244905"><span class="section-number-2">6</span> MapReduce的工作机制</h2>
<div class="outline-text-2" id="text-6">
<hr />
<p>
Hadoop运行MapReduce作业的工作原理
</p>


<div class="figure">
<p><img src="images/mapreduce-workflow-architecture.png" alt="mapreduce-workflow-architecture.png" />
</p>
</div>


<p>
其中有几点需要注意的：
</p>
<ul class="org-ul">
<li>计算分片信息是在本地完成的，分片信息和其他resouce(包括jars,files,archives等）一起copy到HDFS上面，然后jobtracker直接读取分片信息。</li>
<li>提交的资源可以设置replication数目，高副本数目可以缓解tasktracker获取resource的压力。参数是mapred.submit.replication.</li>
<li>对于streaming以及pipes的实现，无非就是task并不直接执行任务，而是开辟另外一个子进程来运行streaming或者是pipes的程序。</li>
</ul>


<div class="figure">
<p><img src="images/mapreduce-streamming-pipes.jpg" alt="mapreduce-streamming-pipes.jpg" />
</p>
</div>

<hr />
<p>
进度和状态的更新
</p>
<ul class="org-ul">
<li>map任务进度是已经处理输入的比例</li>
<li>reduce任务进度分为三个部分
<ul class="org-ul">
<li>shuffle 1/3</li>
<li>sort 1/3</li>
<li>reduce 1/3</li>
<li>也就是说如果刚运行完成sort的话，那么进度是2/3</li>
</ul></li>
<li>状态的更新
<ul class="org-ul">
<li>触发事件
<ul class="org-ul">
<li>读取记录</li>
<li>输出记录</li>
<li>修改状态 reporter的setStatus</li>
<li>计数器修改</li>
<li>reporter的progress</li>
</ul></li>
<li>子进程有单独线程每隔3秒检查progress位是否设置，如果设置的话那么和tasktracker发起心跳
<ul class="org-ul">
<li>通过mapred.task.timeout控制</li>
</ul></li>
<li>tasktracker每隔5秒和jobtracker做心跳
<ul class="org-ul">
<li>心跳时间通过 mapred.tasktracker.expircy.interval 设置</li>
</ul></li>
<li>jobClient定期会去jobtracker询问job是否完成
<ul class="org-ul">
<li>jobClient也可以设置属性job.end.notification.url,任务完成jobtracker会调用这个url</li>
<li>可以认为就是推拉方式的结合。</li>
</ul></li>
</ul></li>
</ul>

<hr />
<p>
失败检测和处理
</p>
<ul class="org-ul">
<li>任务失败
<ul class="org-ul">
<li>子进程抛出异常的话，tasktracker将异常信息记录到日志文件然后标记失败</li>
<li>对于streaming任务的话非0退出表示出现问题，也可以使用stream.non.zero.exit.is.failure = false来规避（ <b>这样是否就没有办法判断是否正常退出了？</b> ）</li>
<li>如果长时间没有响应的话，没有和tasktracker有交互，那么也会认为失败。这个时间使用mapred.task.timeout控制，默认10min</li>
<li>如果任务失败的话，jobtracker会尝试进行多次重试
<ul class="org-ul">
<li>map重试次数通过 mapred.map.max.attempts 配置</li>
<li>reduce重试次数通过 mapre.reduce.max.attempts 配置</li>
<li><b>任何任务重试超过4次的话那么会认为整个job失败</b></li>
</ul></li>
<li>另外需要区分KILLED状态和FAILED状态，对于KILLED状态可能是因为推测执行造成的，不会记录到failed attempts里面</li>
<li>如果我们希望允许少量任务失败的话，那么可以配置
<ul class="org-ul">
<li>mapred.max.map.failures.percent 允许map失败的最大比率</li>
<li>mapred.max.reduce.failures.percent 允许reduce失败的最大比率</li>
</ul></li>
<li>如果一个job超过一定的task在某个tt上面运行失败的话，那么就会将这个tt加入到这个job的blacklist. mapred.max.tracker.failures = 4</li>
<li>如果job成功的话，检查运行task失败的tt并且标记，如果超过一定阈值的话，那么会将tt加入到全局的blacklist. mapred.max.tracker.blacklists = 4</li>
</ul></li>
</ul>

<hr />
<p>
作业的调度
</p>
<ul class="org-ul">
<li>fifo scheduler
<ul class="org-ul">
<li>可以通过mapred.job.priority或者是setJobPriority设置</li>
<li>当队列中有空闲的槽位需要执行任务时，从等待队列中选择优先级最高的作业</li>
</ul></li>
<li>fair scheduler</li>
<li>capacity scheduler</li>
</ul>

<hr />
<p>
shuffle和排序
</p>


<div class="figure">
<p><img src="images/mapreduce-shuffle-sort.jpg" alt="mapreduce-shuffle-sort.jpg" />
</p>
</div>


<div class="figure">
<p><img src="images/mapreduce-shuffle-sort-2.png" alt="mapreduce-shuffle-sort-2.png" />
</p>
</div>

<p>
有下面这些参数控制shuffle和sort的过程 #note: 书上倒是有很多参数，但是好多还是不太理解
</p>
<ul class="org-ul">
<li>io.sort.mb map输出缓存空间大小，默认是100MB. 建议设置10* io.sort.factor.</li>
<li>io.sort.spill.percent 如果map输出超过了缓存空间大小的这个阈值的话，那么就会spill,默认是0.8
<ul class="org-ul">
<li>每次spill之前先会对这个文件进行排序，如果有combiner的话那么会在上面调用combiner</li>
<li>写磁盘是按照轮询的方式写到mapred.local.dir属性指定的目录下面</li>
<li>如果spill速度太慢的话，那么往缓存空间写入进程就会阻塞，直到spill腾出空间。</li>
</ul></li>
<li>io.sort.factor 多路归并的数量，默认是10. 建议设置在25-32.
<ul class="org-ul">
<li>在map阶段，因为最终会存在多个spill文件，所以需要做多路归并。#note: 如果归并数量少的话需要多次merge.</li>
<li>在reduce阶段的话，因为可能存在多路map输出的结果，所以需要做多路归并。</li>
</ul></li>
<li>min.num.spill.for.combine 如果指定combiner并且spill次数超过这个值的话就会调用combine,默认为3</li>
<li>tasktracker.http.threads reduce通过HTTP接口来发起数据请求，这个就是HTTP接口相应线程数目，默认为40。 <b>mapper as server</b></li>
<li>mapred.reduce.parallel.copies reduce启动多少个线程去请求map输出，默认为5。 <b>reducer as client</b>
<ul class="org-ul">
<li>#note: 如果reduce和每个map都使用一个线程去请求输出结果的话，只要shuffle阶段没有出现network congestion，那么提高线程数量是有效果的</li>
<li>#note: 通常可以设置到15-50</li>
</ul></li>
<li>mapred.reduce.copy.backoff = 300(s) reduce下载线程最大等待时间</li>
<li>mapred.job.shuffle.input.buffer.percent = 0.7 用来缓存shuffle数据的reduce task heap百分比</li>
<li>mapred.job.shuffle.merge.percent = 0.66 缓存的内存中多少百分比后开始做merge操作</li>
<li>mapred.job.reduce.input.buffer.percent = 0.0 sort完成后reduce计算阶段用来缓存数据的百分比. 默认来说不会使用任何内存来缓存，因此完全从磁盘上进行读取。</li>
</ul>

<hr />
<p>
任务的执行
</p>
<ul class="org-ul">
<li>推测执行参数
<ul class="org-ul">
<li>如果某个任务执行缓慢的话会执行另外一个备份任务</li>
<li>mapred.map.tasks.speculative.execution true</li>
<li>mapred.reduce.tasks.speculative.execution true</li>
</ul></li>
<li>JVM重用
<ul class="org-ul">
<li>一个JVM实例可以用来执行多个task.</li>
<li>mapred.job.reuse.jvm.num.tasks/setNumTasksToExecutePerJvm 单个JVM运行任务的最大数目</li>
<li>-1表示没有限制</li>
</ul></li>
<li>任务执行环境
<ul class="org-ul">
<li>程序自身可以知道执行环境对于开发还是比较有帮助的</li>
<li>这些属性对于streaming可以通过环境变量获得</li>
<li>mapred.job.id string jobID</li>
<li>mapred.tip.id string taskID</li>
<li>mapred.task.id string attemptID</li>
<li>mapred.task.partition int 作业中任务编号</li>
<li>mapred.task.is.map boolean 是否为map</li>
<li>mapred.work.output.dir / FileOutputFormat.getWorkOutputPath 当前工作目录</li>
</ul></li>
<li>杂项
<ul class="org-ul">
<li>mapred.job.map.capacity  # 最大同时运行map数量</li>
<li>mapred.job.reduce.capacity # 最大同时运行reduce数量</li>
<li>mapred.job.queue.name # 选择执行queue</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org155486d" class="outline-2">
<h2 id="org155486d"><span class="section-number-2">7</span> MapReduce的类型与格式</h2>
<div class="outline-text-2" id="text-7">
<hr />
<p>
MapReduce的类型
</p>

<p>
老API里面还有MapRunner这个类，这个类主要的作用是可以用来控制Mapper运行的方法，比如可以多线程来控制Mapper的运行。
但是在新API里面已经完全集成到Mapper实现里面来了，用户可以重写两个方法来完全控制mapper的运行
</p>
<ul class="org-ul">
<li>map 如何处理kv</li>
<li>run 如何从context里面读取kv</li>
</ul>
<div class="org-src-container">
<pre class="src src-Java">protected void map(KEYIN key, VALUEIN value,
                   Context context) throws IOException, InterruptedException {
  context.write((KEYOUT) key, (VALUEOUT) value);
}
public void run(Context context) throws IOException, InterruptedException {
  setup(context);
  while (context.nextKeyValue()) {
    map(context.getCurrentKey(), context.getCurrentValue(), context);
  }
  cleanup(context);
}
</pre>
</div>
<p>
#note: 觉得这个特性不是特别有用
</p>
<ul class="org-ul">
<li>mapred.input.format.class setInputFormat</li>
<li>mapred.mapoutput.key.class setMapOutputKeyClass</li>
<li>mapred.mapoutput.value.class setMapOutputValueClass</li>
<li>mapred.output.key.class setOutputKeyClass</li>
<li>mapred.output.value.class setOutputValueClass</li>
<li>mapred.mapper.class setMapperClass</li>
<li>mapred.map.runner.class setMapRunnerClass</li>
<li>mapred.combiner.class setCombinerClass</li>
<li>mapred.partitioner.class setPartitionerClass</li>
<li>mapred.output.key.comparator.class setOutputKeyComparatorClass</li>
<li>mapred.output.value.groupfn.class setOutputValueGroupingComparator</li>
<li>mapred.reducer.class setReducerClass</li>
<li>mapred.output.format.class setOutputFormat</li>
</ul>

<hr />
<p>
输入格式
</p>

<p>
对于InputFormat来说包含两个任务
</p>
<ul class="org-ul">
<li>根据job描述来对输入进行切片（InputSplit）</li>
<li>根据切片信息来读取记录（RecordReader）</li>
</ul>
<div class="org-src-container">
<pre class="src src-Java">public abstract class InputFormat&lt;K, V&gt; {
  public abstract
    List&lt;InputSplit&gt; getSplits(JobContext context
                               ) throws IOException, InterruptedException;

   public abstract
    RecordReader&lt;K,V&gt; createRecordReader(InputSplit split,
                                         TaskAttemptContext context
                                        ) throws IOException,
                                                 InterruptedException;

}

public abstract class InputSplit {
  public abstract long getLength() throws IOException, InterruptedException;

  public abstract
    String[] getLocations() throws IOException, InterruptedException;
}

public abstract class RecordReader&lt;KEYIN, VALUEIN&gt; implements Closeable {
  public abstract void initialize(InputSplit split,
                                  TaskAttemptContext context
                                  ) throws IOException, InterruptedException;

  public abstract
  boolean nextKeyValue() throws IOException, InterruptedException;

  public abstract
  KEYIN getCurrentKey() throws IOException, InterruptedException;

  public abstract
  VALUEIN getCurrentValue() throws IOException, InterruptedException;

  public abstract float getProgress() throws IOException, InterruptedException;

  public abstract void close() throws IOException;
}
</pre>
</div>

<p>
下面是一些常见的InputFormat实现
</p>
<ul class="org-ul">
<li>FileInputFormat
<ul class="org-ul">
<li>addInputPath或者是setInputPaths修改输入路径 mapred.input.dir</li>
<li>setInputPathFilter可以修改过滤器 mapred.input.path.Filter.class
<ul class="org-ul">
<li>基本实现会排除隐藏.或者是_开头文件。</li>
<li>自定义的过滤器是建立在默认过滤器的基础上的。</li>
</ul></li>
<li>分片大小由下面三个参数控制
<ul class="org-ul">
<li>mapred.min.split.size 1</li>
<li>mapred.max.split.size MAX</li>
<li>dfs.block.size 64MB</li>
<li>算法是max(minSplitSize,min(maxSplitSize,blockSize))</li>
</ul></li>
<li>isSplitable可以控制输入文件是否需要分片</li>
</ul></li>
<li>CombineFileInputFormat 可以处理多个小文件输入，抽象类需要继承实现。</li>
<li>TextInputFormat
<ul class="org-ul">
<li>输入单位是行，key是LongWritable表示行偏移，value是Text表示行内容</li>
</ul></li>
<li>KeyValueTextInputFormat
<ul class="org-ul">
<li>输入单位是行，按照key.value.seperator.in.input.line来进行分隔默认是\t</li>
<li>key和value的格式都是Text</li>
</ul></li>
<li>NLineInputFormat
<ul class="org-ul">
<li>和TextInputFormat非常类似，大师使用多行输入默认为1行</li>
<li>通过mapred.line.input.format.linespermap来控制行数</li>
</ul></li>
<li>XML
<ul class="org-ul">
<li>InputFormat使用StreamInputFormat,</li>
<li>设置RecordReader使用stream.recordreader.class来设置</li>
<li>RecordReader使用org.apache.hadoop.streaming.StreamXmlRecordReader</li>
<li>#note: 也有现成的XmlInputFormat的实现</li>
</ul></li>
<li>SequenceFileInputFormat</li>
<li>SequenceFileAsTextInputFormat
<ul class="org-ul">
<li>将输入的kv转换成为text对象适合streaming处理方式</li>
</ul></li>
<li>SequenceFileAsBinaryInputFormat #note: 似乎没有什么用</li>
<li>MultipleInputs</li>
<li>DBInputFormat/DBOutputFormat JDBC数据库输入输出</li>
<li>TableInputFormat/TableOutputFormat HBase输入输出</li>
</ul>

<hr />
<p>
输出格式
</p>
<ul class="org-ul">
<li>TextOutputFormat
<ul class="org-ul">
<li>使用mpared.textoutputformat.seperator来控制kv的分隔，默认是\t</li>
<li>对应的输入格式为KeyValueTextInputFormat</li>
<li>可以使用NullWritable来忽略输出的k或者是v</li>
</ul></li>
<li>SequenceFileOutputFormat</li>
<li>SequenceFileAsBinaryOutpuFormat #note: 似乎没有什么用</li>
<li>MapFileOutputFormat</li>
<li>MultipleOutputFormat</li>
<li>MultipleOutputs
<ul class="org-ul">
<li>如果不像生成那写part-r-00000这些空文件的话，那么可以将OutputFormat设置成为NullOutputFormat</li>
<li>但是使用NullOutputFormat的话会没有输出目录，如果想保留目录的话那么可以使用LazyOutputFormat</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgb3beb21" class="outline-2">
<h2 id="orgb3beb21"><span class="section-number-2">8</span> MapReduce的特性</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>计数器
<ul class="org-ul">
<li>streaming计数器和可以通过写stderr来提交
<ul class="org-ul">
<li>reporter:counter:&lt;group&gt;,&lt;counter&gt;,&lt;amount&gt;</li>
<li>reporter:status:&lt;message&gt;</li>
</ul></li>
</ul></li>
<li>连接
<ul class="org-ul">
<li>map端连接
<ul class="org-ul">
<li>必须确保多路输入文件的reduce数量相同以及键相同。</li>
<li>使用CompositeInputFormat来运行map端连接。</li>
<li>#note: 稍微看了一下代码，实现上其实也是针对输入文件对每条记录读取，然后进行join包括inner或者是outer。感觉场景会有限，而且效率不会太高</li>
</ul></li>
</ul></li>
<li>分布式缓存
<ul class="org-ul">
<li>使用-files以及-archives来添加缓存文件</li>
<li>也可以使用DistributedAPI来完成之间事情
<ul class="org-ul">
<li>addCacheFile/addCacheArchive</li>
<li>然后在task里面通过configuration的getLocalCacheFiles以及getLocalCacheArchives来获得这些缓存文件</li>
</ul></li>
<li>工作原理
<ul class="org-ul">
<li>缓存文件首先被放到hdfs上面</li>
<li>task需要的话那么会尝试下载，之后会对这个缓存文件进行引用计数，如果为0那么删除
<ul class="org-ul">
<li>这也就意味着缓存文件可能会被多次下载</li>
<li>但是运气好的话多个task在一个node上面的话那么就不用重复下载</li>
</ul></li>
<li>缓存文件存放在${mapred.local.dir}/taskTracker/archive下面，但是通过软连接指向工作目录</li>
<li>缓存大小通过local.cache.size来配置</li>
</ul></li>
</ul></li>
<li>MapReduce库类
<ul class="org-ul">
<li>ChainMapper/ChainReducer 能够在一个mapper以及reducer里面运行多次mapper以及reducer
<ul class="org-ul">
<li>ChainMapper 允许在Map阶段，多个mapper组成一个chain,然后连续进行调用</li>
<li>ChainReducer 允许在Reuduce阶段，reducer完成之后执行一个mapper chain.</li>
<li>最终达到的效果就是 M+ -&gt; R -&gt; M* （1个或者是多个mapper, 一个reducer，然后0个或者是多个mapper)</li>
<li>#todo: 这样做倒是可以将各个mapper组合起来用作adapter.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org3fb52e2" class="outline-2">
<h2 id="org3fb52e2"><span class="section-number-2">9</span> 构建Hadoop集群</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>很多教程说hadoop集群需要配置ssh,但是配置这个前提是你希望使用start-all.sh这个脚本来启动集群
<ul class="org-ul">
<li>我现在的公司使用apt-get来安装，使用cssh来登陆到所有的节点上面进行配置，因此没有配置这个信任关系</li>
</ul></li>
<li>Hadoop配置
<ul class="org-ul">
<li>配置文件
<ul class="org-ul">
<li>hadoop-env.sh 环境变量脚本</li>
<li>core-site.xml core配置，包括hdfs以及mapred的IO配置等</li>
<li>hdfs-site.xml hadoop进程配置比如namenode以及datanode以及secondary namenode</li>
<li>mapred-site.xml mapred进程配置比如jobtracker以及tasktracker</li>
<li>masters 运行namenode（secondary namenode)的机器列表，每行一个, <b>无需分发到各个节点，在本地启动primary namenode</b></li>
<li>slaves 运行datanode以及tasktracker的机器列表，每行一个 <b>无需分发到各个节点，在本地启动jobtracker</b></li>
<li>hadoop-metrics.properties 对hadoop做监控的配置文件</li>
<li>log4j.properties 日志配置文件</li>
<li>这些文件在conf目录下面有，如果想使用不同的文件也可以使用-config来另行指定</li>
</ul></li>
<li>hadoop-env.sh
<ul class="org-ul">
<li>HADOOP_HEAPSIZE = 1000MB 守护进程大小</li>
<li>HADOOP_NAMENODE_OPTS</li>
<li>HADOOP_SECONDARYNAMENODE_OPTS</li>
<li>HADOOP_IDENT_STRING 用户名称标记，默认为${USER}</li>
<li>HADOOP_LOG_DIR hadoop日志文件，默认是HADOOP_INSTALL/logs</li>
</ul></li>
<li>core-site.xml
<ul class="org-ul">
<li>io.file.buffer.size IO操作缓冲区大小，默认是4KB <b>这个需要提高</b></li>
</ul></li>
<li>hdfs-site.xml
<ul class="org-ul">
<li>fs.default.name</li>
<li>hadoop.tmp.dir hadoop临时目录，默认是在/tmp/hadoop-${user.name}</li>
<li>dfs.name.dir namenode数据目录，一系列的目录，namenode内容会同时备份在所有指定的目录中。默认为${hadoop.tmp.dir}/dfs/name</li>
<li>dfs.data.dir datanode数据目录，一系列的目录，循环将数据写在各个目录里面。默认是${hadoop.tmp.dir}/dfs/data</li>
<li>fs.checkpoint.dir secondarynamenode数据目录，一系列目录，所有目录都会写一份。默认为${hadoop.tmp.dir}/dfs/namesecondary</li>
<li>dfs.namenode.handler.count namenode上用来处理请求的线程数目</li>
<li>dfs.datanode.ipc.address 0.0.0.0:50020 datanode的RPC接口，主要和namenode交互</li>
<li>dfs.datanode.address 0.0.0.0:50010 datanode的data block传输接口，主要和client交互</li>
<li>dfs.datanode.http.address 0.0.0.0:50075 datanode的HTTP接口，和user交互</li>
<li>dfs.datanode.handler.count datanode上用来处理请求的线程数目</li>
<li>dfs.datanode.max.xcievers datanode允许最多同时打开的文件数量</li>
<li>dfs.http.address 0.0.0.0:50070 namenode的HTTP接口</li>
<li>dfs.secondary.http.address 0.0.0.0:50090 secondard namenode的HTTP接口</li>
<li>dfs.datanode.dns.interface default 绑定的NIC，默认是绑定默认的NIC比如eth0</li>
<li>dfs.hosts / dfs.hosts.exclude 加入的datanode以及排除的datanode</li>
<li>dfs.replication = 3 副本数目</li>
<li>dfs.block.size = 64MB</li>
<li>dfs.datanode.du.reserved 默认datanode会使用目录所在磁盘所有空间，这个值可以保证有多少空间被reserved的</li>
<li>fs.trash.interval 单位分钟，如果不为0的话，那么删除文件会移动到回收站，超过这个单位时间的文件才会完全删除。
<ul class="org-ul">
<li>回收站位置/home/${user]/.Trash</li>
<li>#note: 回收站这个功能只是对fs shell有效。fs shell remove时候会构造Trash这个类来处理删除文件的请求。如果调用Java API的话那么会直接删除文件</li>
<li>haddop fs -expunge 强制删除</li>
<li>#note: grep代码发现只有NameNode在TrashEmptier里面构造了Trash这个类，因此这个配置之需要在nn上配置即可，决定多久定期删除垃圾文件</li>
</ul></li>
<li>fs.trash.checkpoint.interval 单位分钟，namenode多久检查一次文件是否需要删除。
<ul class="org-ul">
<li>#note: 似乎没有这个参数。如果没有这个参数的话，那么两次检查时长应该是由参数fs.trasn.interval来决定</li>
</ul></li>
</ul></li>
<li>mapred-site.xml
<ul class="org-ul">
<li>mapred.job.tracker</li>
<li>mapred.local.dir MR中间数据存储，一系列目录，分散写到各个目录下面，默认为${hadoop.tmp.dir}/mapred/local</li>
<li>mapred.system.dir MR运行期间存储，比如存放jar或者是缓存文件等。默认${hadoop.tmp.dir}/mapred/system</li>
<li>mapred.tasktracker.map.tasks.maximum = 2 单个tasktracker最多多少map任务</li>
<li>mapred.tasktracker.reduce.tasks.maximum = 2 单个tasktracker最多多少个reduce任务</li>
<li>mapred.tasktracker.dns.interface default 绑定的NIC，默认是绑定默认的NIC比如eth0</li>
<li>mapred.child.ulimit 单个tasktracker允许子进程占用的最大内存空间。通常为2-3* mapred.child.java.opts.</li>
<li>mapred.child.java.opts = -Xmx200m 每个子JVM进程200M. #note: 这个是在提交机器上面设置的，而不是每个tasktracker上面设置的，每个job可以不同
<ul class="org-ul">
<li>不一定支持将map/reduce的jvm参数分开设置 <a href="http://hadoop-common.472056.n3.nabble.com/separate-JVM-flags-for-map-and-reduce-tasks-td743351.html">http://hadoop-common.472056.n3.nabble.com/separate-JVM-flags-for-map-and-reduce-tasks-td743351.html</a></li>
<li>#note: 个人折中思路是限制内存大小为1G，然后大内存机器允许同时执行map/reduce数量上限提高，通过增加job的map/reduce数量来提高并发增加性能</li>
<li>#note: 我grep了一下cdh3u3的代码，应该是将map/reduce的jvm参数分开进行了设置
<ul class="org-ul">
<li>mapred.map.child.java.opts</li>
<li>mapred.reduce.child.java.opts</li>
</ul></li>
</ul></li>
<li>mapred.task.tracker.report.address 127.0.0.1:0 tasktracker启动子进程通信的端口，0表示使用任意端口</li>
<li>mapred.task.tracker.expiry.interval 600(sec) tt和jt之间的心跳间隔</li>
<li>mapred.job.tracker.handler.count. jobtracker用来处理请求的线程数目。</li>
<li>mapred.job.tracker.http.address 0.0.0.0:50030 jobtracker的HTTP接口</li>
<li>mapred.task.tracker.http.address 0.0.0.0:50060 tasktrackder的HTTP接口</li>
<li>mapred.hosts / mapred.hosts.exclude 加入的tasktracker以及排除的tasktracker.</li>
</ul></li>
</ul></li>
<li>Hadoop Benchmark
<ul class="org-ul">
<li>在hadoop安装目录下面有jar可以来做基准测试</li>
<li>TestDFSIO测试HDFS的IO性能</li>
<li>Sort测试MapReduce性能</li>
<li>MRBench多次运行一个小作业来检验小作业能否快速相应</li>
<li>NNBench测试namenode硬件的负载</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org8a65061" class="outline-2">
<h2 id="org8a65061"><span class="section-number-2">10</span> 管理Hadoop</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>永久性数据结构
<ul class="org-ul">
<li>namenode的目录结构
<ul class="org-ul">
<li>current表示当前的namenode数据（对于辅助节点上这个数据并不是最新的）</li>
<li>previous.checkpoint表示secondarynamenode完成checkpoint的数据（和current可能存在一些编辑差距）
<ul class="org-ul">
<li>hadoop dfsadmin -saveNamespace 可以强制创建检查点,仅仅在安全模式下面运行</li>
<li>辅助namenode每隔5分钟会检查
<ul class="org-ul">
<li>如果超过fs.checkpoint.period = 3600（sec），那么会创建检查点</li>
<li>如果编辑日志大小超过fs.checkpoint.size = 64MB,同样也会创建检查点</li>
</ul></li>
<li>除了将文件copy到namenode之外，在辅助节点上面可以使用选项-importCheckpoint来载入</li>
</ul></li>
<li>VERSION Java属性文件
<ul class="org-ul">
<li>namespaceID 每次格式化都会重新生成一个ID，这样可以防止错误的datanode加入</li>
<li>cTime namenode存储系统创建时间，对于刚格式化的存储系统为0.对于升级的话会更新到最新的时间戳</li>
<li>storageType NAME_NODE or DATA_NODE</li>
<li>layoutVersion 负整数表示hdfs文件系统布局版本号，对于hadoop升级的话这个版本号可能不会变化</li>
</ul></li>
<li>edits 编辑日志文件</li>
<li>fsimage 镜像文件</li>
<li>fstime ???</li>
</ul></li>
<li>datanode的目录结构
<ul class="org-ul">
<li>blk_&lt;id&gt;以及blk_&lt;id&gt;.meta 表示块数据以及对应的元信息，元数据主要包括校验和等内容</li>
<li>如果datanode文件非常多的话，超过dfs.datanode.numblocks = 64的话，那么会创建一个目录单独存放，最终结果就是形成树存储结构。</li>
<li>dfs.data.dir目录是按照round-robin的算法选择的。</li>
</ul></li>
</ul></li>

<li>安全模式
<ul class="org-ul">
<li>namenode启动的时候会尝试合并edit数据并且新建一个checkpoint，然后进入安全模式，在这个模式内文件系统是只读的</li>
<li>可以通过hadoop dfsadmin -safemode来操作安全模式</li>
<li>当达到下面几个条件的时候会离开安全模式
<ul class="org-ul">
<li>整个系统的副本数目大于某个阈值的副本数目比率超过一个阈值之后，然后继续等待一段时间就会离开安全模式</li>
<li>dfs.replication.min = 1 副本数目阈值</li>
<li>dfs.safemode.threshold.pct = 0.999 比率阈值</li>
<li>dfs.safemode.extension = 30000(ms) 等待时间</li>
</ul></li>
</ul></li>

<li>工具
<ul class="org-ul">
<li>dfsadmin</li>
<li>fsck</li>
<li>scanner
<ul class="org-ul">
<li>DataBlockScanner每隔一段时间会扫描本地的data block检查是否出现校验和问题</li>
<li>时间间隔是dfs.datanode.scan.period.hours = 504默认三周</li>
<li>可以通过页面访问每个datanode的block情况 <a href="http://localhost:50075/blockScannerReport">http://localhost:50075/blockScannerReport</a></li>
<li>加上listblocks参数可以看每个block情况 <a href="http://localhost:50075/blockScannerReport?listblocks">http://localhost:50075/blockScannerReport?listblocks</a> #note: 结果会很大</li>
</ul></li>
<li>balancer
<ul class="org-ul">
<li>通过start-balancer.sh来启动,集群中只允许存在一个均衡器</li>
<li>均衡的标准是datanode的利用率和集群平均利用率的插值，如果超过某个阈值就会进行block movement</li>
<li>-threshold可以执行阈值，默认为10%</li>
<li>dfs.balance.bandwidthPerSec = 1024 * 1024 用于balance的带宽上限。</li>
</ul></li>
</ul></li>

<li>监控
<ul class="org-ul">
<li>日志
<ul class="org-ul">
<li>jobtracker的stack信息（thread-dump）<a href="http://localhost:50030/stacks">http://localhost:50030/stacks</a></li>
</ul></li>
<li>度量
<ul class="org-ul">
<li>度量从属于特性的上下文(context),包括下面几个
<ul class="org-ul">
<li>dfs</li>
<li>mapred</li>
<li>rpc</li>
<li>jvm</li>
</ul></li>
<li>下面是几种常见的context
<ul class="org-ul">
<li>FileContext 度量写到文件</li>
<li>GangliaContext 度量写到ganglia <b>(这个似乎比较靠谱）</b></li>
<li>CompositeContext 组合context</li>
</ul></li>
<li>度量可以从hadoop-metrics.properties进行配置</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
</body>
</html>
