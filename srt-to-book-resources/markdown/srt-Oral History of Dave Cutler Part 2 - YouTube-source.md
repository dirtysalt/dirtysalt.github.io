# Chapter 1

so blowing off steam with the team skiing racing

well

one of the ways we blew off steam a little bit was one of the

the

in fact

the guy that was the microsoft guy that had joined us early on

decided that

um

it would be a great idea to

uh

go down to laguna sea and go to the russell racing school

so i i think about

um

maybe about eight of us went down to the school and we went to

uh

the beginner beginner school

which i think was four days

and and we

we were in

um

a mazda open wheel car

and you know it was

that was a good thing to blow off a little steam

and and it was really an eye opener about

um

for me about driving a a race car

i really wasn't very good at it or wasn't as good as i thought i should have been it

and the beginner school

they just teach you basically how to drive the car about the dynamics of the car

uh

g-forces cornering and all that sort of stuff

but then they have an advanced course where you actually at the end of the course

you get to do a race

so

um

a few of us decided

well

we'd like to go to that too

so i don't know

you know

a couple three months expire and we go down and we do that

and

uh

so we do the race

we go through the advanced school and and they do some more things

um

and i'm getting a little better at it

and we finished that

we do our race

and that was fun

so i thought

well

maybe

you know

they have the school series

what they call school series

you basically go down once a month and you race on saturday and then on sunday

and you come home

so

and debbie was involved in this too

debbie came down and did the um

the beginner one and she did the advanced one

and so she and i would go down there every month for

i think we went down from oh somewhere in march

just september

something like that every month

so it was 10 races or something like that

so i did that

and and and um

that was fun

and so then they had a

they had

every year

they had a what they called a pro race and the pro race

they would

um

they didn't have governors on the systems

but they sort of would

uh tune

they would open them up a little bit

they

they reprogram the ecu

the engine control unit

and um

give them a a little more harsh power

and you know

they say we're going to have a pro race now

and the pro race meant there was a pri

there was a u

um

a price package

um

and you could win some money

i think probably the top was 10k or something like that

but this would draw a lot of drivers that were pretty good

so i i did one of those

i think i finished next to last

only because one guy

my first one

only because the other guy was worse than i was

um

so then i got involved with a guy that was one of the instructors down there

and another guy that owned a race team to import an atlantic car from uh new

zealand

and i

that was when i started into racing really seriously

and so i owned that car and he raced that car one year

which was 1995

and the next year i decided that

well

we really should have a a new car to race

so i bought a new car and so the question became what to do with the old car

so i climbed in the old car and gez

i was pretty good

so i de saided

well

i'll race in this series

so i started racing the atlantic series and i raced

uh

56 races in that series

it had some per

i had some pretty um horrific accidents

nothing that i was really hurt really badly in

but one at laguna sea

um

is sort of an infamous one because espn played this over and over and over again for i

5 minutes of broadcast time or something and it was in one of the turns

i did a a um longitudinal flip

so you talk

you think about a flip that's going end over end

it wasn't end over end

it was a barrel roll flip

i did a flip like this and landed on the top and it was in a corner

where there was really dusty and the dust flew and there was big dust clouds

and what

what turn was that it was turn 10 laguna sea

the fast downhill sweeper to the right to the right

yeah

and uh

um

espn picked that up and and they just played that

you know

they

they played it over and over because

you know

there's a certain amount of time

they

they have to the yellow goes out

they have to clear the track

then they have to

you know

get the wreckers out and upate the car

so the races

you know

stop stopped

but they just keep playing this over and over and over again

so

uh

that was sort of my big wreck

my best

um

my best result

i finished eighth one time at um

the milwaukee mile

uh

this particular series we raced um montery mexico

which was a real

that was a real eye opener

um

you know

the rac trcks here are pretty safe

um

the racetrack there was not real safe

uh

i raced in um

homestead

uh raced in cleveland at the airport

um

mid ohio

which is outside of columbus

montreal

tw rivier

which

which is up by quebec city

um vancouver

british columbia

portland

uh

long beach road america

i never

oh yeah

road america that in fact road america

not road america

uh

no

no

road america

this is elkart

elkart

wisconsin

yeah

i had a big wreck at

well

that's my second biggest wreck

or maybe my first biggest wreck was at road america

there's a turn there

they call the kink

which is about 140 or 150 mile turn

and i lost control of the car and hit a had a hit a stone wall there

and ouch

i got

out of the car and the car was rocking like this

and i couldn't really understand why that was the case

and i looked down and all four wheels are gone

i'm just sitting there in the car

you know

the car is built with what they call a monoco

yeah

tub

and i'm in the tub and the engine's still on the back

but none of the wheels are

they're all gone

so i did race at road america

yeah

your favorite one

the milwaukee mile by far

yeah

oh

i

nazareth

pennsylvania's there too

any

uh

any analogies from

uh

racing into software development

yeah

actually

i think there is

and um it's focus

um

i've been always been a person that really can focus on the job at hand

and racing is driving a race car is focus

i mean what happened 10 milliseconds ago

it's gone

you're going to focus on what's coming up and what's going to happen

so

um

i think there's there's some analogy there about being really successful

i mean anything is to be to focus on what's important and uh

what what you um have to

uh

achieve

uh

to get

uh

to the success of so

in race car driving is

it was just another example that so the super intensity of concentration

yeah

it's like when

when you're writing code

what

how do you achieve that

can you stand music being on or want to be in a quiet office

or you know

in general

noise doesn't bother me much

um

you know

i would prefer that somebody's not

there's one guy at work now that whistles and that

you know that's not a problem

but he whistles down the hall

and you know i'm like

i

i really don't like that

but generally noise doesn't bother me much

but but i do focus on

uh

you know what's going on

especially if

if i write a new piece of code

um

i

i

you know

i write the code and i i will spend maybe um

three or four iterations of of executing the code in my mind

all the air paths

all the paths that can go through

to see if i can prove that it's correct before i even run the code

and most of the time

when i run code it

it pretty much runs the first time

it may not be absolutely correct

but it will run

it won't crash

um

so that's being able to focus on what's going on and not have things bother you or whatever

in in the nt program you

it was demolishing bugs

and you know how

how would you

uh

change the process to create less errors and make them easier to fix

the easiest

probably the easiest bugs to

well

the question is how how to make uh bugs easier to fix

and

um

and fewer of them

pardon

and fewer of them and fewer of them

um

i think fewer of them is probably the easier of the two

because

um

the fewer the bugs are

the harder

the ones that are left are going to be to solve

and the hardest bugs to solve are ones around synchronization

they're not around correctness of code flow

they're

they're around the correctness of synchronization um

where

um

there's not the correct barriers

there's not the correct locks or there's race conditions between code paths or something

um

one of the things that also exacerbated the five years was multiprocessing

um

i had the the be in my bonnet

when i went to microsoft that we were going to produce mp systems

and nobody else was producing mp systems

um deck had

at that time they had the 782

which was this funny asymmetric thing and we had 1170 that actually was smp

but there was some unibus problem that we decided not to manufacture that

so um s smp problems synchronization

is a big problem

um

the problem with less bugs is i think through the engineering process itself

and and the the people you've got to have quality has to start from the bottom up

it can't start from the top down

you can't legislate quality

you have to quality

has to be something that's im born in everybody at the lowest level

and any link in the lowest level

that doesn't produce a quality

piece

prod produces bugs up the up the line because they interact with other pieces of the system

if you're

if you're building the

the lower levels of the system

then your leverage as far as causing problems up in the levels is very high

so i think

uh

reducing the number of bugs is is basically thinking more about quality and paying more attention to quality

i don't think that that that necessarily

you have this thing

well

we'll do 100 % test afterward

you know

we'll

we'll do everything and then we'll test to see how good it is

it's got to be built in to start with

so i think building systems with fewer bugs means paying attention to that all the way along

and not for me

i hate it when there's a bug filed against me

i don't like that

at all

and i don't want that bug to exist filed against me for any longer than i have to

i'll drop everything to go fix that bug

because i know i can fix that

um

so there needs to be that kind of mentality

i mean there's a lot of people that say

oh yeah

i got 50 bugs

you know

i'll get them fixed

well

it's like quitting smoking

you know

the best time to quit smoking is right now

it's

not

it's not an hour from now or a day from now

or a week from now

it's right now

so the best time to fix the bug is

right now

so that would be fewer bugs

um

the make them easier to fix

um

i don't know how we make them easier to fix

other than the

the uh building

better tools for analyzing what's going on

i guess

is

is

um

primarily the way we would make them easier to fix

and we we have lots of tools now we have

we have lots of tools that do the same thing that you know

somebody has said

um

well

that's a good tool

but i'd like the tool to do this

i don't own the tool

but i think i could build a tool that was a little better

that would do do this and maybe we could find something a little better

and so we have a lot of

we have a lot of tools we have

we have a lot of source level tools

um

one of the big problems that we had

uh

partway through

um

the

the evolution of nt was hitting a big security

um

uh

attack or wall or whatever

somewhere after um

about 2001

somewhere in there

i you know

we were

we

the internet

we really got going on the internet

somewhere in the late 90s and

uh

the internet suddenly had problems with people with uh

viruses and trying to attack your system

um

so we developed some tools that analyze the source and try to to find places where you have um

buffer overflows are the biggest one

and the amount of buffer overflows that we had was just mindboggling that that

and it was like we have this tool and the tool says

look at

right here this

this could overflow

and so that was great

i mean that made it so that it lowered the bugs

um

even things like um

arithmetic overflow can cause a bug

because you're calcul

maybe you're calculating the size of the buffer that you want to allocate

because you got a bite count

and you do this computation and gez that overflows and now it looks like you need a small size

# Chapter 2

uh

the internet suddenly had problems with people with uh

viruses and trying to attack your system

um

so we developed some tools that analyze the source and try to to find places where you have um

buffer overflows are the biggest one

and the amount of buffer overflows that we had was just mindboggling that that

and it was like we have this tool and the tool says

look at

right here this

this could overflow

and so that was great

i mean that made it so that it lowered the bugs

um

even things like um

arithmetic overflow can cause a bug

because you're calcul

maybe you're calculating the size of the buffer that you want to allocate

because you got a bite count

and you do this computation and gez that overflows and now it looks like you need a small size

so you allocate that size and then you use this other size

uh

to to transfer data into it

and all of a sudden you have a problem there

so we have some tools that that analyze the source and

uh

and actually

um point out places where there's bugs and and we actually fix those like they're bugs

the problem with those tools are that they're static analysis tools and they have a lot of false positives

so you see a lot of things that that aren't really problems

and it can't see some things you know you

you

you may have in your code

you may have had logic that made it impossible for the thing that it's complaining about to occur

and it'll say

hey

this is bad

so those have to be filtered out

and so we have ways to filter that out too

if you go back a little bit to

you know

getting programmers to really produce good code is

is there a dave cutler school of how to get a programmer moving along in that direction

uh

do i have a a way to move people to build good code

um

i guess

the only way that i can say that i have

um

helped people build good code is

by example

you know

um

everything that i do

i try to make it get my best and everybody sees

the source

and obviously they see that i don't have a very big bug count or a zero bug count

um

they look at my code and i i hope that that that really

um

helps them become better programmers

um

but another aspect of this is is really with the young people starting out to really ingrain in them

the the importance of quality

i mean i

i

for me

there's nothing worse than software that doesn't work

i mean i

i just can get really upset with software that doesn't work where it's obvious that something

just

i mean something simple

i mean if something doesn't work on your phone or it doesn't work on your tablet

or it doesn't work on your pc

that should work it

it

it should infuriate you

because it just should not be that way

right

it should be all the stuff that doesn't work

should be stuff that that is little tiny things

maybe it's like there's a few pixels over here that are wrong

uh

or or something that that's just minor

uh

in fact

a lot of the bugs

uh

um

that are that have been and continue to be filed against nt

are

are these kind of things

they're cosmetic things and they tend to

they have low priority

so those things are not upsetting

but it's upsetting

when you have something where you ship a product and it's in the field for four months

and all of a sudden there's this disaster that happens where you wipe out

you know somebody's data

and then all of a sudden it's like wow

that's really a problem

so i think quality is something that starting out with young people and saying hey

you know

we really got to have quality

so you

you come to 93

i think it is in the final

93 is the release date of nt

the official release

millions of copies shipped

the uh

initial version of nt is shipped in uh

1993

and then we shipped

um

n35

which was alpha support about six months later and and part of that was also a a uh

kind of cleanup

let's improve the performance of the system release

um

we did not have the performance level in the system

in the first release

we would like to

had

it was a little bit bloated

now bloated in those days was like maybe it took 24 megabytes

this

of course

a two gigabytes or four gigabytes

um

so daytona was kind of this dual thing

where it was this

it was called daytona

it was actually the daytona release and our our big thing

there was the racetrack and everything

and um i think we actually may have

uh

well

we had some racetrack stuff because we off been all off to the race school

uh

and we

and we incorporated alpha support

and then

just a little bit later than that

we did the power pc

so that brought us to the first

the end of the first release

and then the next release was um

nt40

and nt40 is an interesting release

because at the end of of the release release

one

or we actually call it

we actually call it 3. 1

because windows was 3. 1

the 16-bit windows was 3. 1 and the the

the feeling was that nobody would buy an operating system that was a 1 nobody

so would start out with a number that wasn't a 1

and well

we pick the same number as the 16bit thing

so then then we had 35 and 351

well

the next one was going to be 40

and in the meantime another guy had been hired from banyan

his name was jim alon

and he had actually was starting another project called cairo and cairo was

was envisioned to be a system that would incorporate some of the things you now see with internet search

only it would be locally

an indexing

file

a new file system that had indexing indexing all your mail and everything

and it was internally in

microsoft was called information at your fingertips

and he started this project

and it was kind of running with in parallel with the tail end of release one

so when we started release 2

um

well actually was would be it was n4o

um

the cairo project

alon actually came became my boss and the cairo project

uh

became part of the n development

and that was supposedly where we were going to be going

and i was really worried about this

so

um

i proposed another project called and we called it tucka

and the reason we picked tuck willa was

because we know where tua is and we know how to get there

it's just down the street

so i convinced jim that we should we had the the capability to do both of these at once

and throw one away

and it turned out that the one we threw away was cairo

and nt40 was probably one of the best systems that we produced

um

certainly not functionally

but as far as

uh

its acceptance and quality and performance

and

um

it contained the

uh

it was in 1996

so it was just after windows 95

we talk a little bit

we'll talk a little about that lineage of system

yeah

um

so it contains a new graphical user interface

which was drastically different from 3. 1

3. 1 was sort of

it was graphical

but you sort of put things together

you built your menus

and you had to do a whole bunch of stuff

um

and then the new ui actually had all that stuff

you know everything

when you got

the system was already installed with start menus and all that stuff

so nt40 had the new ui in it and it was an evolution of nt

caro

would have been an evolution of also

but it would have had a new file system

a new shell

just a whole bunch of new new mail system

everything

um

so i started to diver

or

um

i digress into windows 95 and widen

windows 95 came about

windows 95 is actually built on the dos code base

so it's actually the 16bit system with the capability to run 32-bit programs and it included this new ui

and it actually was very popular and sold a lot of systems it sold in in that time frame

it

it sold a lot more systems than nt sold

um

but nt sold in the places where you were doing enterprise stuff

uh

you needed some security

you needed to run server

you wanted to run file servers or print servers

those

those are any kind of servers

we had

then

um

so nt was alive and well and very healthy

but at the same time

windows 95 made the company a lot of money

and then they continued on with that same code base for windows 98

and then was with millennium

um

which i believe was in 2000

so

and it died

it completely died

it was

um

uh

a non-extensible um

it was bug written

it was notorious for doing just hanging

you know

it just freeze

and that was

not

um

unexpected

because it was built on doss

it wasn't built on security

no

security

none

none

um

one of the things this

you didn't ask me about this

but i might say something about security

you know

we started out in the beginning to have really robust security

and we designed of the original security model was pretty robust

but by today's standards completely different

because in those days you were protecting things

um

you were protecting people against f file access and um

uh

system resource access

but it wasn't like the security today where um

somebody invites the

the breach right into the system

they're in the browser and they click on something

and here comes a program they didn't even know about

all of a sudden

it

it

it

uh

it exploits a buffer overflow and bang

it puts something in the operating system

and now you're under the control of the virus

right

so anyway

there was a lot of controversy about whether we should make people log on or not

because the original pc

you know

you turn it on

there

it is well building

we're talking about security

and and the fact that we maybe shortcut the system a little bit with security in the beginning

because

um

the pc mentality was you just turn on the system and use it

and we really

we had come from the the background of time sharing systems

where everybody lo logged on and everything was shared and you worried about

you know

people accessing your files

and geez

if it's a pc

you own it

you can access your files

so we actually designed the security system and built the security system and we did have log on

uh

but there were some aspects of the the system

that we didn't do quite as well as we we we could have

uh

one was

um

uh

when you install an application

you should really install an application for the user that installed it

not for the system

but since it's a pc

you install it for the system

so that was one problem

because now

um

you assume now that that everybody is going to use this thing

and that if two people have two different versions

well that you can't have that

you can only have one version

and then the other thing that happened with that was

um

we would have all these people that were reshipping binaries

and so somebody would have an application like office and they'd reship a binary and somebody have

maybe a database application that would ship a binary

same binary never been tested against the other guy's product

right

so we

we had

we

and we're still somewhat trying to work through this about state separation

which is part of of of casting this as part of security

is separating everybody's state

so it's only their state

so

but nt does have security and had security built in oras

um

windows 995 did

not

so the end of the

the dos windows

uh

comes to

you know

it can't go any further

and where does nt go in terms of influencing the future

it's called personal operating systems

where does it oh you mean like

uh

xp

you know seven

oh so on

well

let me tell you

it's all nt

there is nothing that's not nt

when when 10 is nt

it's all the same stuff

it's an evolution of the same code base going all the way back to 1988

um

there is some interesting

um diversion along the way

um

if you want to go

you want to go into that right now or or sort of a little bit later

because i was going to

well

you know

take the direction you want to take

okay

i

i was going to say what happens in after nt40

yeah

good

after nt40 nt has grown to 400 people

and i'm sort of

uh

at the point of of

um

maybe i don't want to manage 400 people

maybe i want to just work on the technical things that are important

um

so i decide at nt40 that i'm not managing the the system anymore

that somebody else is going to manage the system

and

um

i become an individual contributor

and being individual contributor from then on basically meant i was doing the same things i was doing on the the coding implementation side

as i was doing before

i just wasn't carrying all the other stuff with me

so the next system we produced is wind

2k windows 2000 and windows 2000 was uh probably one of the first systems that we really produced

um

we

we produced a a separate serv system server skew from a

uh

a personal skew

uh

i don't know whether we produced the server

sk

we probably produced the server skew for n402

but the 2000 was more oriented towards that about writing server applications

um

wind 2k was another

you know

great system

as far as um

the reliability and everything

um

and my part

it was just basically

um

any new features we put in the kernel performance

um

nothing real big

# Chapter 3

uh

a personal skew

uh

i don't know whether we produced the server

sk

we probably produced the server skew for n402

but the 2000 was more oriented towards that about writing server applications

um

wind 2k was another

you know

great system

as far as um

the reliability and everything

um

and my part

it was just basically

um

any new features we put in the kernel performance

um

nothing real big

um

and then we shipped that in 2000 and in 2000

um

there's a guy that's in charge of the consumer group

and there's a ch guy that's in charge of the server group

and you know they've been working together under another guy to produce the system

this

but the guy

that's in charge of the consumer group decides

that that um consumers don't need the quality that the server group needs

and the server group's um laundry list of features

that they want to put in the next release is way beyond what they they need for the next consumer release

so we split the codebase we split in xp

and the other one was a server 2003 codebase and that turned out to be not a good decision

and and what happened there was

um

the server 2003 codebase

we fixed all the security problems we were having

uh

we put in the server features and it actually turned out

in the end

it almost shipped at the same time as the the xp code base and the xp code base

uh

shipped with some new ui stuff

it

you know

it had this start

the the new start button and some other stuff

it was mostly ui work

uh

but also shipped with a lot of security problems and more bugs than the server 2003

so and i work mainly on two

our server 2003 and about this time

um

i don't remember the exact day

but it

it was slightly after 2000

amd came to us and said um

we have

um

a new

or we have an extension to the x86 architecture that will extend it compatibly to 64 bits

are you interested

and one of the things i kind of left out here is the addition of yet another platform

in which was in two in 2k

which was the itanium

we added itanium support in in uh wind

2k and the itanium would run x86 binaries

32-bit binaries

but it wouldn't run them at speed

so there was a speed penalty plus the fact

that titanium was never ever as fast as the fastest x86 ever

so amd proposing this

this extension

you know

looked kind of good and so we sort of looked at it and said

well

it looks pretty interesting

you know

why don't you go back and um

come back when you've got it more solid and you're

you know

you're

you think you really want to build it

so they come back back in like 6 months and say here it is

and and i i look at it and say boy

this is great

the x86 runs at speed

we can produce a a small

like the ame thing

we can produce a small wrapper envelope that just executes x86 binaries

and they'll run it

whatever the speed of the processor is

the 64bit stuff will run at the speed of the processor

except it'll have a bigger address space

so i said this is pretty good

um

you know we we need to talk about whether we're going to do this or not

so i don't know

not very much time went by and there was not much

um

there was not much happening and i just

i went to al and said we're doing it

we're just going to do this

i'm gonna

i'm going to do it

i got a couple guys and we'll do it

so i basically four of us started out to do this

and we had done a lot of groundwork on making our codebase um

data type

neutral

as far as pointer size because of the itanium

and also because we were actually at one time doing a 64-bit alpha system

and then compact said we're not building those anymore

so we quit doing that

so we started out um on the the

what became the the x64 version of nt in the ear

early 2000

at the same time

amd was developing the architecture and got um a pretty good say in some things that were really important

um

we

i think we got about six features put into the processor architecture

that i consider to be one of them was absolutely essential

and that was they put in relative addressing and it's 32-bit displacement

so it meant that if we were willing to

if we were willing to say our binaries were never any bigger than two two gigabytes

then that displacement would always span a binary

so they put in the the rally of addressing they put on

they put in some other things were performance oriented and i had a really good relationship with a

with a

the lead micro code guy

i mean he was having a graph was just great

um

and we

um

going back to the how important this 32-bit displacement thing was

maybe you wouldn't think that would be important

but one is position independent code

it's hard to write code for the 64-bit architecture that isn't positioned independent

which means that one of the main security things that you do is something called alsr

which is address space relocation

uh

randomization

so you take an image and you randomize where you put it in the address space

well

you have to relocate it when you do that

well

if there's no relocations

you don't

you don't have to do much right now

there still can be relocations

but but to have position independent code

you need the code to be independent

as opposed to the data

you can always produce pointers to the code or the data

so anyway that we decided to do that with a windows 2003

uh

codebase

in the meantime the xp is shipped

and we're producing a system on the consumer side called longhorn and it became

i call it does it matter

horn

because it became so bug written

and so hard to actually get it to run

that eventually it got to the point that i convinced alan

i said we should just junk that codebase and start over with a wind 2k

i'm sorry the windows 2003 codebase is the nude codebase and we did that

we started over that system became vista and vista was that

that's the way that that got delivered with system was vista

but we actually delivered um the x64 support as a service pack to the windows 2003 server

was

it was

it was windows 2003 server sp1

and it had some new sks and they were 64-bit sks

there was a a professional um desktop skew

and then there was a server skew and um

um

that turned out to be very successful

i mean everything's 64 bits

now

almost everything

the telephone's not

well

i can't say the telephone's not 64 bits

because um

your cell phone is

anyway

well

the cell phone it turns out

the cell phone turns out is actually going to 64-bit arm

so um

they want more than 4 gigabyt of physical address space

so they're going to go to

uh

64-bit arm

there is some places where 30

well

i thought the 32-bits would entirely go away

but there are some things like cell phones where

uh

smaller pointer sizes actually do end up meaning less memory

you leave less memory

and on phones

less memory means less power drain

less power drain means happier users

okay

so in the meantime here we ship 2003

but just before we ship 2003

we have to go back to xp again

and we have to spend a ginormous effort on xp to bring up

all

bring it up to all the security enhancements we've made to um the server system

so basically we do xp

service pack 2

which is basically a release

a re-release of that software

so that sort of brings us to the point where where and again

this is all nt

this is not

you know

you read

like you read mary joe foley

i don't know if you ever

if you know who she is

she's

um

she's written about microsoft forever and it's like this is a new operating system

well

it's not a new operation

it's an evolution it's like

um

every time linux comes out with a new release

it's not a new system

it's an evolution of the old system

so the xp sp2 was really a new system because it was a re-release of almost every single binary

and then we went back to

we did xp

we d it back to

then we did the the x

the x64 release

and then we went back and and put the resources back on vista

and so vista came out basic as a 64-bit system and 32 and i vista actually supported vista

i think vista actually supported

um

the itanium

also meantime

one of the things you left out here is the risk systems were dropping off

and i the reason here's why i think they dropped off

i think the ris guys were so so focused on simple architecture with simple implementation

that they in intel intel was like they got this architecture

it's a little complex

but they got got lots of transistors

they got lots of design and they got lots of verification expertise

letus put these these transistors to work to make everything run faster and running faster

is things like

uh

very sophisticated branch prediction

uh

better caching

you know

set associative caching and just all sorts of stuff

um speculation all that that the risk guys are like

well

you know

we don't really want to do that stuff

you know

we want this to be simple

so the thing about risk having a performance advantage

just kind of went away

it went away because they didn't want to

there was nobody that had the resources to put to work on the chip architecture

and the chip design that intel did

and they didn't have the resources to do the big designs with all the transistors they had

i mean the they're

you know

they're billion billion transal chips now

right

so in the risk gu going to

you know they want to build

see

look at this

we built this machine with three

you know

300, 000 gates right like

so what

and this

the stuff on the intel processors now and the amd processes is really complicated

it really is there

just a ter

you know

out order

uh

execution

and all this stuff there

r guys

you know they don't want to do that

um

so i think

that's why the risk systems kind of went away is

that they couldn't offer the price performance that the intel systems could

they couldn't pro

they couldn't provide the compatibility through the line

i mean we had all these um software emulators running

and and one of the things that we're doing now in in itanium

and and actually alpha started

this too is binary recompilation

where you take a binary

you take an xx6 binary

you run it through a binary recompilation

produce another binary which runs under a special um emulation

uh

system that mostly executes at speed of the processor

because it's translated everything that it can find from x86 code to to alpha code

or whatever the carget is

but there's still maybe a few pieces around there

and so you're actually run the real binary

and sometimes you have to actually flip into a mode that actually emulates the instructions

but most of the time

excuse

so binary compilations has come a long ways and we would be a lot better off

but still you have

it's not like you just do the

re

the binary recompilation and then you say you

well

i'm sorry

you just say i'll do the recompilation and i'll just

i'll just put it in the store

right it

it'll work

then

well

it doesn't

you know

you have to go and make sure you have to test and make sure

so it's a doubling of the work

so

um

i think the the risk architectures with um with um went away in their popularity

because of all those things now arm arm has taken a hold in um phones

and it's taken a hold in some of the mobile devices

um

but arm is not anywhere near the performance capability of the x86 stuff and either from

uh

from amd or intel

and you know they're trying to get there

they're

you know they're trying to to up their their their performance

but they

they've been primarily aimed at power and you use

you use amd or i'm not amd

you use arm processors and applications where you don't need

um

a lot of power

maybe you need a little ship

one of the things that's happened is

you know

intel and amd to to a certain extent is like we got a billion transistors we we got

we just got to build this chip

that's this big mh

the last one was that size

the next one's got to be that size

even though we have four times as many transistors

we're going to build it the same size

right

well

the arm guys actually haven't done that

arm guys have kind of a

they have a uh

a portfolio of a lot of different size chips

so if you're building a watch

you can build it with a chip that's smaller

right

yeah

so but intel and amd have never taken this thing about

well

let's take

we now can build the same functionality in one quarter the size

maybe that would be a good product

well

this whole semiconductor process technology

you

the the end game with a p4 is we get to maybe four gig gigahertz and we

and

and the

you know

the chip is incandescent

# Chapter 4

arm guys have kind of a

they have a uh

a portfolio of a lot of different size chips

so if you're building a watch

you can build it with a chip that's smaller

right

yeah

so but intel and amd have never taken this thing about

well

let's take

we now can build the same functionality in one quarter the size

maybe that would be a good product

well

this whole semiconductor process technology

you

the the end game with a p4 is we get to maybe four gig gigahertz and we

and

and the

you know

the chip is incandescent

so now we go to multicores

so this is a big event in the operating system world

that we're going to have four processors to play with

how did that start coming into the

well

we started

you know

nt

from day one was

we built nt to be mp

and we

our

our initial

our risk prototype

or our reference was mp

so we were mp from day one

so cores are no no different than you know

there's two kinds of cores

actually

do you think about cores as being autonomous cores or multi-threaded cores

if they're multi-threaded cores

then they're

they're a con set of context

that's a thread and the core hardware that actually executes that context

and then you switch among these contexts and intel did

um

it's called smt

uh

well

multi-threading just call it multi-threading intel did this early on

but we already had mp support

so the only thing that was kind of a curveball

there was that sm smp in uh

increased your parallelism

but not necessarily your performance

because you basically have the same amount of execution capabilities that you had before

you just have multiple contexts that you can run that run against that

now the place that you could gain is that there's delays

like

uh

cash misses

where you can say

well

that cash miss

i

i missed in the cash on this set of context

i can switch to another context and it can immediately execute

maybe it had a cash miss before and now that data is there so you can get

you know

maybe 15

%

you can also lose 5 % or 10

%

so very unpredictable

so that kind of threw us a cruit ball

amd went the other way and they did what was what they called cmt

multi-threading was called smt

symmetric multi-threading and the other one was called cmt

and cmt was chip multiprocessing

which actually put more than one processor on a chip

so the original amd 64-bit chips were processor chips

so they had two real processors

now

since then they've

they've all migrated to this multi-core thing where they actually have

uh

core logic that shares some other piece

uh

they may share

like you may have uh a couple cores that share an l2 cache

for instance

which then shares

then all the the the two pairs share on l3 cache

and all of that

all of that now is all in nt

you know how many levels of cash do you have

how many

what are they

you know

uh

how many waste set

associative

are they and all of this stuff

so the thing didn't really affect nt

particularly it

but it affected the applications

because the applications now could get more performance if they're multi-threaded so if somebody started out originally with nt

and said i just have a single threaded app

then these other processors

well

they

well

they they progress through to the point where we're at 3. 5 gigahertz

and you know they're all ready for the next leap to four

and the next leap to four doesn't happen

because we can't build it at four because we would have such high

uh

current leakage

that you're right

it would

it would glow

the thing would glow

so we start building cores

and then it seems to be like a race of how many cores we can get on a single die

um

i don't know what the biggest one is

but it's big

it's like i don't know maybe 80 or something like that

so there's a lot lot of cores

but but for nt itself

that doesn't mean much at all

not at all

it's

it's mainly the applications

where do we go from here

so we're in the the kind of chronology here

we're

we're at vista and

uh

you know

we we retargeted longhorn to one code base

so so we're actually back to one code base and i'm still an individual contributor

and and i worked on vista

i did some things for vista

um

mainly x64 related

because i i've been the guy that that was the spearhead for x64 and you know

of course

i

i say we're

there are four of us that that basically did this

we

we did a lot of it

um

we did the line share of it

but there was a whole another effort going on that compiler world

where we had a couple guys from the compiler group that were just absolutely superb

and

um

they did a great job with a compiler

so there was a a whole another group of people

i

i mean i don't know if you

how many people actually

you would say you know were responsible for the x64 uh system

but it was pretty small

you

maybe a 100 people mh

anyway

so vista we shi vista

um

and vista is big dilemma

because it's like

should we ship it or should we start over

you know

it's

doesn't look very good

it's not

it doesn't look the same as windows

it doesn't look the same as xp

it doesn't look like the same as anything we've done before it's different

um

so we shipped it and with not very good market reception

a vista was probably the poorest received version of all of the windows systems

that is show

there was some other bob and some other things

well

window windows systems

yeah

yeah

window bob

yeah

bob lasted

um

i don't know

three to six months

that was about it

so this is shipped in

uh

november of 2006

and

uh

so i sort of stuck around on the operating system group for a while

but then

and

um

later on in that year

and i think it was around october

um

cloud computing was becoming a hot topic and cloud computing

um

is basically

um

moving back the other way

where you know

we

we move

we had server

we had time sharing system

one time

then we moved to servers

then we moved to peurs computers

and now we're moving back to central storage

again

where in central computing

where we have a big server farm somewhere

that that you can somehow you can interface through from whatever your device is

and all the heavy computing or the heavy storage will occur on that end

and we had server um farms in several places

but they were specifically for servers for this

or servers for that or whatever

so there was a project that or incubation project actually was started called azure

and it was to produce a um

a system that would

uh

provide

uh

a platform for for people to rent

where they could rent compute power

they could rent storage

and so i

and we decided it was going to be a virtualized system

because you want to run multiple instances of operating system

so it had to be virtualized

and this was at a time when the first virtualization extensions had come out for amd and for intel

and we're not quite um

at the level that we thought we had to have um

specifically

the paging was a real real problem

and the virtualization systems that that existed

the virtualization in implantations that existed at that time were their hypervisors

that mainly did shadow pages

shadow page tables

and we thought that the direct translation was better

so we decided that we would go with direct translation

which adds more translation levels

but it's direct

and you don't have this

this duplicate copy of page tables on the side

and amd was the first um company that was producing those intel came along

later

um

and we decided that that our hypervisor would be based on that

and i became responsible for the hypervisor for azure

and we

um

brought azure up and you

we started a server farm in quincy

um

washington

um

i don't remember how many servers we had

but it was quite a few tens of millions of dollars worth of servers

which was our just our test system right

and we carried on for about two years and our

our main differentiation at that point was

and

and what we were actually asked to do was produce a system that was a platform as a service

which included all the things that you have to do

if you have a server

you know you have

you have problems with configuration control

where you have to keep track of the operating system you're running

what version

it is

what versions of all the apps are

and all that

and then if you have multiple of these

you you have to update them all together

so we build all the infrastructure to do all that stuff

thinking that that was going to be the big thing that people really wanted

and to a certain extent it is because you don't want to have to have

um

you don't want to do this manually

you don't want to manually

uh

have

say

oh geez

i got 150

i got 2,

000

i got 10, 000 servers and a new update came out for the operating system

well

i've got to update every single one of those

right

do i want to sit there and do that

well

no

and there were some internal people in in um in microsoft

that actually had developed some tools to do that

and they were mainly the ones that were running our web services

so we decided to produce another set of tools

and

um

i guess

about

um

i think

about two and a half years into the project

we were doing well enough that

um

steve bomber decided that

well

geez

we are to really make this a product now

so we we made um azure a product

and i forget exactly when the first

i think 2010 was the

when we introduced

um

azure was the platform as a service

and at that point we

we're out of the incubation

and um

you know we're were

um

worried about

you have multiple data centers because you want triple redundant logic on all of the storage

and of course

um

we have

we have

we want to do this internationally

so we have

you know

we're building data centers in germany or in europe

we're building data centers in the east in far east

and

uh

then you have problems about

um

we can't migrate any

you can't replicate any data across

uh

geopolitical regions cost money to move it to canada

well

it's mainly because of the geop geopolitical problems of interesting

you know

if you're storing a replication of data from germany that belongs to the german government

they really don't want it stored on servers in texas

right

so

um

we had

we shipped the first version of azure and um

there was

um

a change in the management

the server group and the guy that would run the server group

um took over azure

and at that time

um

a couple of us decided that we'go work on the xbox and the irony of working on the xboxes

is

i once sent steve bomber

a piece of mail that said steve

i got an idea

why don't we take that million dollars a week that we're losing on xbox

and take it out in the parking lot on friday night

and have a bonfire and roast hot dogs and and marshmallows

we can take the people that we're working on that

and put them on things that'll really produce some good stuff

and we'll save all that money

of course it was just kind of a tongue and cheek thing

so here i am

like seven years l

going over to the dark side

seven years later

i'm over on the dark side

so the xbox was was kind of a real um new thing for me

because this is working on something

where the security is something that's much different than the security for anything else

you think of security

um

the way you you generally think about it is physically

phys

you physically have the machine

it's yours

it's secure

and now you just worry about keeping all those other people out that could invade it through the web

or whatever

the xbox is entirely different than that

we

we want to guard against people that have a soldering iron and a logic analyzer

they can't break the system

if they do something to modify the system

it will immediately see that it's been modified and it will not

it

will

will

will do what it's called bricking

it will brick itself

it now becomes a brick

it's no longer an xbox

it's a brick

so building such a system is kind of interesting and it requires a lot of uh

a lot of detail and attention to security

a lot of hardware

um

not necessarily in terms of cost

but a lot of hardware

a lot of

uh

a lot of encryption

um

amd is in the business of building custom s soc's and they built the custom s

so for this

and it has um it has eight cores

um

and they're split into um four

two core groups

but it also has a arm security processor

# Chapter 5

it now becomes a brick

it's no longer an xbox

it's a brick

so building such a system is kind of interesting and it requires a lot of uh

a lot of detail and attention to security

a lot of hardware

um

not necessarily in terms of cost

but a lot of hardware

a lot of

uh

a lot of encryption

um

amd is in the business of building custom s soc's and they built the custom s

so for this

and it has um it has eight cores

um

and they're split into um four

two core groups

but it also has a arm security processor

so the secure boot is actually secure

you can't decide that you're going to solder some parts on

you can't decide

you'll take some parts off and reprogram them and put them back

it will discover this

you know everything's

everything is encrypted

um

it runs with a hypervisor

so there's a hypervisor level of protection in the system

um

it runs

it's a three-headed operating system where actually runs three virtual machines

one is called the host system which communicates with a hypervisor

and it's part of the trusted computer base and the hypervisor

actually

you know

you could think of that

it's running on the bare hardware

but under the opes of the security processor

you know

the security processor has the capability to just gate off certain pieces of hardware

so you can't even see them

so it's if the hardware is only going to be accessible by the security processor

it has the ability to do that

it has the ability to just stop the processor

it has a lot of control over what's going on

so back up a bit and say why

okay

so the question that we were discussing was

uh

why all this security on the xbox and make it so that it's

uh

so the

uh

the owner can't steal

and the answer is piracy

the xbox games are

are called aaa rated games

and aaa rated games means that

um

they're very responsive

they're high

uh

frame rate games

um

the

typically

the people that produce them spend a lot of money producing them

and they're not like a pc game

where typically in a pc game

there's piracy

but they get a big surge when they

when they put them out

and i guess that they figure that that

um

that that offsets whatever piracy that

but a aaa rated game

um

is one that's a high expense

it might be hundred bucks

and we guarantee that they can't

we people can't pirate those games and we actually get

uh money for that

so if they can't pirate games and we can convince the people that write the games

they can't comp pirate the games

we make money because of that

okay

so you're talking about all the all the security functions

and so you've been working on the

you worked on the hypervisor

i work on the hypervisor

and

um

you know

the hypervisor isolates all the memory um does all the scheduling

one of the things on the xbox is that

and you know generally an operating system you want to share on the xbox

you don't necessarily always want to share

and there's a lot of actual physical partitioning of the system

depending on what you're doing

if you're running a aaa rated

games would take a set of cores and dedicate those to the game in a vm

and so they don't deal now with the interference

that they get with other things going on in the operating system

and there's a lot of housekeeping stuff that goes on

uh

and the other things that on xbox is you actually can be running a game

and viewing live tv at the same time

or even skyping at the same time or running the internet

explorer

so

um

and not having them interfere with each other

so if if you're running a game and it's in the foreground

youve got six cores dedicated to you

if you're running a game and it's in the quote background

in other words

you're

you're focusing more on watching tv

then you have four cores

and the other environment has

uh

four cores

so we have eight cores total

so we're constantly switching these cores around

and the hypervisor doing all that at the command of the host system

the host systems

keeping track what's going on

um

so it's

it's a much different

you

you think of this as like you think of virtualization as you're running mobile operating systems

so you could think of the xbox is just virtualization

but it's really not because all this is the operating system which we call hydra

and it it really has these three different os's running or three different vms running all right

and one of them

the the system os is called is our shared resource environment

where you actually could be running things that were like

um

you

you'be running live tv or netflix or hulu or whatever there

and it has all the ui

so everything you do

your game controller is interfacing with something in that particular operating system

but all the device drivers and everything are in the host os

so there's some communication between the two through shared buffers

and the game is setting it in here in another vm all right

with its own resources

and whatever

so the memory is is separate

we don't

it's not like

uh

a demand page system

where

like a time sharing system where you steal pages from joe to give to sally

right

they get what they get

so that

so that every time that game runs

it runs the same

the audio doesn't glitch

the video doesn't glitch

and of course

behind this is some some pretty good

uh

gpu hardware

so is this is got you fully engaged in terms of the future of xbox

or you have your eye on something else

right now

i don't have my eye on anything else

i'm sort of

uh

just trying to to keep up with what we're planning to do

um

in the future

um

which will be

i mean most i can say about that this time is it's evolutionary

um

there are some thoughts about

you know what do we do

do

we do should we really have a console

or should we really try to

uh

beef up the the um

the pc environment to be able to run these aaa rated games

and what would that mean it's not going to be a secure

um

for instance

on xbox

um

there's a bunch of u certificates that you get when you buy one

and that say what you

well

there certificates say what you can do

well

if you're a c

if you're a consumer

you get an xbox that you can play games on and you can do these other things

that

what are they apps for

you can't run kently buggers

you can't do any of that stuff

so there's no opportunity for people to run those kind of attacks

but on the pc operating system that you can't

uh

rule that out because somebody buys a pc

they say i own the pc

it's mine

now

thankfully

from the day we introduced xbox

until now

um

the people that buy xboxes

they actually

uh

have become accustomed to the fact that that environment doesn't really belong to them to tinker

with

they can't load device drivers

they can't put code in the operating system

um

the typical attacks that somebody would have through the um

the uh

internet explorer or the browser are not possible

um

or they're severely mitigated by the way the layering in the system

um

one of the things that the hypervisor does is

and it we do all this through

uh

um

i won't call it cryptography

but it's secure hashing is

uh

we use nested paging

which means that the hypervisor has the real page table and the real ais bits

and that the vm has what it thinks are the page tables

and what it thinks the access bits are

but it can't get an

can't get an execute bit turned on

unless the hypervisor turn it on

hypervisor only turn it on

if it's in a page that has a hash that we recognize

so you can inject code in the operating system

if you find a buffer overflow

then the best you can do is maybe you can jump somewhere where you can

you can find a gadget

and a gadget is a bunch of btes that are executable but not necessarily on instruction boundaries

that do something

some weird thing you know

since the x86 is a is a variable length instruction machine

there's no nice crisp instruction boundary

so you can jump into the middle instructions

so

that's typically what these guys do is they find a buffer overflow they jump into the middle of one of these gadgets

which then jumps somewhere else into code that they've loaded or something

but you can't do that on the xbox

so let's shift gears into little prog prognostications about the future

you know what's the future of operating systems

that's a good question

uh

well

the question is what's what's uh

the op

the future of operating systems

and

um

you know

we vms is still alive after whatever

it's uh

35 years

a little over 35 years

it's 37

30

yeah

37 years

um

vms

i do not believe is nearly as big as windows as windows

i

you know

i hate to guess how many lines of coder in windows

but i think it's well over a billion

uh

might be several billion

it's huge

um

linux is smaller

unix is sort of gone

um

i really thought that linux would go the way same way that unix went where everybody took

unix

got a license to it and then tried to add their value

by making it incompatible with all the other versions of unix

which was great for us

because it just made it so that there there was fragmentation

um

linux seems to have not gone that way

i mean they've pretty much seem to have held themselves to be compatible

um

but still that's a huge system too

it's not as huge as as as windows

because it doesn't have 28 years behind it yet

you know it's got 15 or whatever it's got

but in 10 more years it'll have that too

um

there's a lot of

uh

little things that you can do like there's there's people that are building little operating systems for engine control

or something

but to build a big operating system is in in to build some level of compatibility

to run all these apps that exist is a very large effort

it may be an effort that even the the us government would want to take on

so the the thought that there's going to be a new operating system at the level of of linux

or of um

even unix or even

or or

uh

nt is kind of like

you know it's going to be difficult

um

i don't think it's going to happen very

if that happens

it's going to be a long time from now

um

and it'll happen

if it happens

it'll happen because the complexity the code bases grow to the point where it's like

do we want to solve the complexities of the code base or just want to throw it over

throw it away

and start over and people may say

well

we just want to throw away and start over

however

throwing it away and starting over doesn't mean that you can just junk the compatibility because you can't

you can't junk the compatibility is is big data

kind of a fork in the road for what an operating system is

no

big data is big data

the way i understand big data is just it's um

employing applications to um

visualize analyze sort through big big sets of data to find relationships that you otherwise couldn't find

it's not really an operating system per se issue

it's

it's more of a a data analysis thing

and it's

you know

it's

it's

um

we have these huge data sets

we were doing this stuff at dupont

we were doing one of the things they did at dupont

they they did their own own program called rammer and rammer stored for

uh

uh

regression analysis and multiple regression or something

which was basically

you're all the time at these chemical plants

you're trying to take the data that you collect and see what environmental variables

human variables

operational variables

chemical purity and whatever

what correlates with what

so you can rise to the optimum on some curve

some process

some on pro

some process

right

and so that's part of the engineering services department had

was a a math and stat group that did just that

right

so we've been doing this stuff

but now people are starting to look at it in terms of things like marketing

you know

where do you target ads

um

and a lot of different things

i don't think it's per se an operating system thing

i mean

at some point we may have

in fact

we probably already do have big cloud applications that people you can buy

um and run and provide your data and have thousands of processors

yeah

well

one of the things that's nice about the cloud is the elas icity

is you can say i only want one processor right now or one core

or you could say i want 10, 000 and you could get 10, 000 processors all running in parallel

and

and maybe

um

they wouldn't be

they would be running as multiple instances of of um vms

or they could be running as multi-processing within a vm

right

so

is there any hope for the general decomposition of programs into parallel processing

well

you know people keep banging away at that stuff and it keeps getting better

um people have been doing that

you know

uh

ken kennedy at rice

i mean you

maybe you know

ken

ken

ken

kennedy was the big guy for the dusty deck fortran and infamous

and i'm sure he must be a fellow is

if he know

i don't know

yeah

um

he was part of

uh

the tera cray startup

m

um

he was doing dusty deck fortran in 1970

right

where they were taking fortran

and trying to take dusty deck fortran

and compile it so it could be vectorized and and done in parallel

# Chapter 6

maybe you know

ken

ken

ken

kennedy was the big guy for the dusty deck fortran and infamous

and i'm sure he must be a fellow is

if he know

i don't know

yeah

um

he was part of

uh

the tera cray startup

m

um

he was doing dusty deck fortran in 1970

right

where they were taking fortran

and trying to take dusty deck fortran

and compile it so it could be vectorized and and done in parallel

and you know there's just lots of stuff going on

i think more of the the stuff is going on now

um

to not to not necessarily take the old stuff and make it run in parallel

but to always produce the new stuff to run in parallel

uh

one of the things in windows 10

in fact

i think it was in windows 8 too is um

user mode scheduling

to make it so that you can have

you know tens of thousands of threads and you schedule them yourself

um

so that there's a minimum overhead

because you know how you're switching

you don't necessarily have um 10, 000 processors

you might only have 20 processors

but you have

you know 10, 000 things that you might schedule

so there's s of sort of a move in a direction

that's

um

partly partly what was driving

that was the core um frequency thing where people realized

um

i don't know when that was about five years ago

or so

we realized that when

when fact intel said within 10 years we're going to have a 10 gz processor

and then they said oops

we're not probably ever going to have a 10 gz processor because of this problem

unless we

you know

we find some other way to build transistors

so

um

being able to run multiple threads

and schedule them yourself became something that that at least our people thought was um

essential to being able to

uh

to exploit parallelism inherently in programs from the start rather than saying

oh

we're going to take this old program and make it run in parallel

what do you think of ai

current state of ai ai

well

you know

ai is doing some things now that that

um

i think you know there

when ai started

there was this huge uh

uh

uproar about

oh

well

gez

you know

it's not going to be long because computers going to be everything

and it wasn't long before we thought well

computers ever do anything

but now you know there's a lot of ai that's going on

that's pretty

uh

groundbreaking

like

um

um

well

i i would

i'll call this ai

i don't know you call it ai

but i think the skype translator is absolutely unbelievably something that that is just unbelievable

this is where i don't know if you know about this or not

this is where you can

you can be french

and i can be spanish

and we can actually talk to each other and the skype will automatically translate it

when i talk

transl my language to your language

that's

that's unbelievable

that's unbelievable

right

how many phd theses were written about this before it happened

right

a lot

a lot

and you know

now we have on windows

we have um

fingerprint recognition for log on and we

debbie's

like she's

she just got a new phone

she dropped her phone i guess yesterday morning and broke it

and she says she's got her new phone

it's got windows 10 on it

and she says

look at this

i can log on with my eye

my eye print

my iris print can log on

so i think ai is really taken off

um

i

you know

the other thing

i guess ai

i

i guess you should think about

um

computer controlled cars

right

is ai

and you know

i think that that's great

but i see on one of these things that you gave me

uh

there was a question about

you know

will you ever sit in the back seat of a ai car

and i think the answer to that is not for a long time

um

you

i

i tell you why i believe that

i believe that

because i you know

that kind of ai is a little different than the speech thing

it's like the difference between

uh

having a machine like

um

a cat scan machine kind of machine

where you have

you have a real-time control

that machine

and if that control goes wacky

it kills somebody

as opposed to

we're speaking back and forth and we gar garble a word

that's a very different thing

right

so knowing how big and how complicated windows is and how complicated and big

uh

linux is

um

i think that there's a high probability that there is a large number of bugs in the software

unless it's extremely simple

now they may have taken linux

and stripped it down or whatever they took

and stripped it down to such a small thing

that they can actually reasonably be able to prove that it's correct

however

you know computers are not 100

%

you know they have every once in a while

there's like what happened

it just went away

you know

like

well

you know

tandem built systems that were triple redundant logic or whatever

so i don't know

i i haven't read anything about whether they have triple redundant um controllers in these systems

uh

that control cars but i would expect they do

and the other thing is

you know

like what happens when you know

one time we're in lancaster california and we've

we're going to a racetrack and we've rented a car from herz that has a neverlost

and guess what we lost

the never lost and we lost it

because the atmospheric conditions were such that the gps could not not work

so what happens

when you're whiting down the highway

and those atmospheric conditions occur and the gps doesn't no longer works your your proximity

uh

things work

but you don't know where you're going anymore

so i think there's some questions

that need a lot of answering before we put cars on a highway at 70 m an hour

and say yeah

here we'll get in the backseat and watch tv

me

