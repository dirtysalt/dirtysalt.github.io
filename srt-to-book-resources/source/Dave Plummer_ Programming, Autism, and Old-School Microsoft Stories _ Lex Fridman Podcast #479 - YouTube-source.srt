1
00:00:00,140 --> 00:00:02,100
以下是与 Dave Plummer 的对话

2
00:00:02,100 --> 00:00:08,480
程序员，也是微软资深软件工程师，曾参与 Windows 95 开发工作

3
00:00:08,480 --> 00:00:13,340
NT 和 XP 系统，开发了许多令人惊叹的工具

4
00:00:13,340 --> 00:00:19,100
其中一些工具已被数亿人持续使用至今

5
00:00:19,100 --> 00:00:23,020
像著名的 Windows 任务管理器那样。

6
00:00:23,020 --> 00:00:26,160
是的，就是那个 Windows 任务管理器。

7
00:00:26,160 --> 00:00:29,140
还有 Windows 中的 zip/unzip 压缩支持功能。

8
00:00:29,140 --> 00:00:32,780
他还移植了《太空军校生弹珠台》的代码

9
00:00:32,780 --> 00:00:36,460
又名 Windows 三维弹球

10
00:00:36,460 --> 00:00:43,800
如今，他因名为"Dave's Garage"的精彩 YouTube 频道而深受众多程序员和工程师喜爱，你绝对应该去看看。

11
00:00:43,800 --> 00:00:46,980
他还写了一本关于自闭症的书

12
00:00:46,980 --> 00:00:52,240
以及讲述他人生故事的作品，名为《自闭症百万富翁的秘密》

13
00:00:52,240 --> 00:00:55,920
他提供了关于如何在自闭症状态下经营人际关系

14
00:00:55,920 --> 00:00:59,760
事业以及日常生活的非常有趣的见解。

15
00:00:59,760 --> 00:01:05,640
总而言之，这是一次关于编程历史和未来的超有趣对话

16
00:01:05,640 --> 00:01:13,620
计算机技术，以及如何在这个传奇车库中打造酷炫产品。

17
00:01:13,620 --> 00:01:15,390
这里是莱克斯·弗里德曼播客。

18
00:01:15,390 --> 00:01:18,580
如需支持，请查看简介中的赞助商信息

19
00:01:18,580 --> 00:01:21,920
现在，亲爱的朋友们，有请戴夫·普卢默。

20
00:01:21,920 --> 00:01:24,680
聊聊你的第一台电脑吧。

21
00:01:24,680 --> 00:01:25,400
你还记得吗？

22
00:01:25,400 --> 00:01:25,960
我同意。

23
00:01:25,960 --> 00:01:27,640
我很久之后才拥有自己的第一台电脑

24
00:01:27,640 --> 00:01:30,280
但我使用的第一台电脑是 TRS-80 Model 1

25
00:01:30,280 --> 00:01:34,490
一级，4K 机器，我大概在五六年级时骑自行车

26
00:01:34,490 --> 00:01:37,140
那时我大约 11 岁，去了当地的 RadioShack 商店。

27
00:01:37,140 --> 00:01:40,880
你知道的，他们有标准的组合音响系统和 RadioShack 该有的其他东西

28
00:01:40,880 --> 00:01:43,840
但他们有一摞标着"电脑"的箱子

29
00:01:43,840 --> 00:01:45,540
于是我就向那里的工作人员询问这件事

30
00:01:45,540 --> 00:01:48,400
他们说刚拿到设备，还没设置好

31
00:01:48,400 --> 00:01:50,770
当时我算是比较早熟的，就想

32
00:01:50,770 --> 00:01:51,904
"那我来帮你们设置吧"

33
00:01:51,904 --> 00:01:53,765
他们说：“好吧，试试看吧。”

34
00:01:53,765 --> 00:01:54,860
“你知道自己在做什么吗？”

35
00:01:54,860 --> 00:01:55,600
完全不知道。

36
00:01:55,600 --> 00:01:57,200
我是说，这比组合音响好不到哪去

37
00:01:57,200 --> 00:01:59,020
唯一的问题是，Tandy 公司以其无穷的智慧

38
00:01:59,020 --> 00:02:01,340
使用了相同的五针 DIN 接口来供电

39
00:02:01,340 --> 00:02:04,280
视频，还有卡带机，所以它们看起来完全一样

40
00:02:04,280 --> 00:02:06,660
如果插错了接口，设备就会烧毁。

41
00:02:06,660 --> 00:02:08,620
于是我看了标签。

42
00:02:08,620 --> 00:02:11,180
然后，呃，把它弄好了就开始摆弄起来

43
00:02:11,180 --> 00:02:14,420
我对电脑一窍不通，所以就在上面输入英文指令

44
00:02:14,420 --> 00:02:23,600
你看，输入 PRINT 2+2 完全没问题，但要是只用这种基础的一级解释器，输入些简单的英文指令可走不了多远。

45
00:02:23,600 --> 00:02:25,220
所以你试着用英语和它交流？

46
00:02:25,220 --> 00:02:25,700
是的。

47
00:02:25,700 --> 00:02:27,600
当时不知道有更好的方法。

48
00:02:27,600 --> 00:02:30,700
我至今还保留着六年级时写的一份

49
00:02:30,700 --> 00:02:33,580
虽然逻辑上不太严谨但勉强能运行的程序

50
00:02:33,580 --> 00:02:37,140
但在当时存在的任何解释器上都没有运行的可能

51
00:02:37,140 --> 00:02:40,520
所以我花了一些时间才弄清楚它们实际上的运行原理

52
00:02:40,520 --> 00:02:43,040
不过，呃，我每周四和周六都会骑自行车去那里

53
00:02:43,040 --> 00:02:45,120
他们也很慷慨地让我使用那台机器

54
00:02:45,120 --> 00:02:46,160
这是什么时候的事？

55
00:02:46,160 --> 00:02:47,160
79 年、80 年。

56
00:02:47,160 --> 00:02:47,620
好的。

57
00:02:47,620 --> 00:02:49,700
那时候的计算机技术水平如何？

58
00:02:49,700 --> 00:02:50,720
那我们当时在讨论什么呢？

59
00:02:50,720 --> 00:02:51,960
三大巨头已然问世。

60
00:02:51,960 --> 00:02:56,370
TRS-80 Model 1、PET 2001 相继亮相

61
00:02:56,370 --> 00:02:59,180
而 Apple II 也几乎同时面世。

62
00:02:59,180 --> 00:02:59,930
Apple II。

63
00:02:59,930 --> 00:03:02,160
你会说这是有史以来最伟大的计算机吗？

64
00:03:02,160 --> 00:03:04,080
回想起来可能是的。

65
00:03:04,080 --> 00:03:06,690
嗯，我可能会把这个称号给 Commodore 64。

66
00:03:06,690 --> 00:03:07,510
是的。

67
00:03:07,510 --> 00:03:10,769
我们在这点上达成一致，那是我第一台电脑。

68
00:03:10,769 --> 00:03:12,820
可能是在它发布多年之后，但确实如此

69
00:03:12,820 --> 00:03:14,200
Commodore 64 确实了不起。

70
00:03:14,200 --> 00:03:18,920
不过确实，Apple II 对个人电脑历史产生了巨大影响。

71
00:03:18,920 --> 00:03:19,280
没错。

72
00:03:19,280 --> 00:03:24,400
长期影响难以估量，但我认为 64 本身可能影响了更多人

73
00:03:24,400 --> 00:03:26,230
这就是我选择它的原因。

74
00:03:26,230 --> 00:03:26,840
你这么认为吗？

75
00:03:26,840 --> 00:03:28,140
销量确实更高。

76
00:03:28,140 --> 00:03:30,120
所以 Commodore 64 卖得很好？

77
00:03:30,120 --> 00:03:30,660
是的。

78
00:03:30,660 --> 00:03:32,040
我是说，这些数字令人难以置信。

79
00:03:32,040 --> 00:03:36,800
这取决于你相信哪些数据，但即便是中等估计值也相当高。

80
00:03:36,800 --> 00:03:37,380
好吧，不错。

81
00:03:37,380 --> 00:03:40,390
所以你后来升级到了 Commodore 64。

82
00:03:40,390 --> 00:03:42,750
呃，那个，给我讲讲那台机器的事吧。

83
00:03:42,750 --> 00:03:45,140
你在 Commodore 64 上做过什么？

84
00:03:45,140 --> 00:03:47,760
嗯，我做的第一件事就是把它上面的软驱给烧坏了

85
00:03:47,760 --> 00:03:50,060
这挺倒霉的，因为那台机器不在保修范围内。

86
00:03:50,060 --> 00:03:50,386
我们拥有过。

87
00:03:50,386 --> 00:03:50,470
..

88
00:03:50,470 --> 00:03:54,680
我父母没有太多钱，所以我们是从 Computer House 买的，而不是从大型零售商那里购买的。

89
00:03:54,680 --> 00:03:58,700
这意味着当它坏了时，必须送回德国之类的地方修理。

90
00:03:58,700 --> 00:04:01,320
所以我当时没有软驱，只能用磁带录音机。

91
00:04:01,320 --> 00:04:02,760
这已经是当时你能做到的最好的了

92
00:04:02,760 --> 00:04:07,780
所以我当时写些小程序，有一个可以从磁带加载的机器语言监视器

93
00:04:07,780 --> 00:04:09,720
虽然没有内置汇编器，但它带有一个反汇编器

94
00:04:09,720 --> 00:04:11,920
这样你就能输入 6502 的操作码了

95
00:04:11,920 --> 00:04:15,320
以十六进制表示，如果你仔细规划的话

96
00:04:15,320 --> 00:04:17,029
你就能编写一些基础程序

97
00:04:17,029 --> 00:04:19,040
我就是这样入门的。

98
00:04:19,040 --> 00:04:23,740
而且，呃，我在上面写的第一个程序是《Galaga》的克隆版。

99
00:04:23,740 --> 00:04:25,140
现在，这只是一个拙劣的《Galaga》克隆版

100
00:04:25,140 --> 00:04:27,700
但它包含了随时间推移发动攻击的主要敌人

101
00:04:27,700 --> 00:04:29,690
而且全部是用手工编写的机器语言写成

102
00:04:29,690 --> 00:04:33,420
6502 处理器不支持代码重定位，所以如果你需要在中间添加代码

103
00:04:33,420 --> 00:04:35,200
你得手动跳转到别处去

104
00:04:35,200 --> 00:04:36,680
干完活再跳回原来的地方

105
00:04:36,680 --> 00:04:38,800
这简直就是一团乱麻般的代码

106
00:04:38,800 --> 00:04:40,780
不过最终好歹是跑通了

107
00:04:40,780 --> 00:04:42,640
于是我去做了备份

108
00:04:42,640 --> 00:04:46,043
为了保存给未来的学者们，或者管我当时在搞什么名堂——

109
00:04:46,043 --> 00:04:46,050
..

110
00:04:46,050 --> 00:04:51,260
然后，呃，我把空白软盘的内容复制到了存有数据的软盘上。

111
00:04:51,260 --> 00:04:52,030
这就是我第一次——哦不。

112
00:04:52,030 --> 00:04:52,096
.

113
00:04:52,096 --> 00:04:52,170
..

114
00:04:52,170 --> 00:04:53,200
有数据管理方面的经验。

115
00:04:53,200 --> 00:04:55,340
所以我已经没有自己第一个程序的副本了。

116
00:04:55,340 --> 00:04:56,950
那种感觉是怎样的，你还记得吗

117
00:04:56,950 --> 00:04:59,280
呃，就是随便做点什么

118
00:04:59,280 --> 00:05:01,890
呃，如果我能这么说的话，就像个傻瓜一样

119
00:05:01,890 --> 00:05:02,220
你明白吗？

120
00:05:02,220 --> 00:05:04,320
这也是编程体验的一部分。

121
00:05:04,320 --> 00:05:05,500
是啊，当时充满了内疚感

122
00:05:05,500 --> 00:05:08,090
因为，对吧，你毁掉了好几周的工作——是啊。

123
00:05:08,090 --> 00:05:08,090
.

124
00:05:08,090 --> 00:05:08,090
.

125
00:05:08,090 --> 00:05:09,780
而且你知道这是因为你太着急了

126
00:05:09,780 --> 00:05:10,190
或者你确实——是啊。

127
00:05:10,190 --> 00:05:10,190
.

128
00:05:10,190 --> 00:05:10,190
.

129
00:05:10,190 --> 00:05:12,940
做了些蠢事，或者做了不明智的决定。

130
00:05:12,940 --> 00:05:16,040
那个游戏里用到的编程，能具体讲讲吗？

131
00:05:16,040 --> 00:05:17,920
所以真的是机器语言。

132
00:05:17,920 --> 00:05:18,456
太机器了。

133
00:05:18,456 --> 00:05:18,550
..

134
00:05:18,550 --> 00:05:18,950
对- 就是 6502。

135
00:05:18,950 --> 00:05:18,950
.

136
00:05:18,950 --> 00:05:18,950
.

137
00:05:18,950 --> 00:05:19,960
这连汇编都不是？

138
00:05:19,960 --> 00:05:21,960
还不是汇编，因为还没内置汇编器

139
00:05:21,960 --> 00:05:24,980
所以我本该先写个用汇编语言编写的汇编器作为首要任务

140
00:05:24,980 --> 00:05:26,900
但当时我没那么聪明，所以...

141
00:05:26,900 --> 00:05:28,720
这有多难实现？

142
00:05:28,720 --> 00:05:29,460
轻而易举。

143
00:05:29,460 --> 00:05:30,920
而且这是那种会形成习惯的事情

144
00:05:30,920 --> 00:05:31,400
我认为。

145
00:05:31,400 --> 00:05:32,820
你反复做了太多次。

146
00:05:32,820 --> 00:05:35,320
你知道，如果我给你一个 C 语言的问题

147
00:05:35,320 --> 00:05:38,440
C 语言中有一些语法问题你永远不会忘记，也不会再犯错。

148
00:05:38,440 --> 00:05:39,010
是的。

149
00:05:39,010 --> 00:05:40,280
这就是其中之一。

150
00:05:40,280 --> 00:05:43,240
比如，用机器码编程有哪些局限性

151
00:05:43,240 --> 00:05:44,520
作为一名程序员？

152
00:05:44,520 --> 00:05:47,300
最大的问题是你必须完全按顺序编写代码

153
00:05:47,300 --> 00:05:50,080
因为至少在 6502 这个版本中

154
00:05:50,080 --> 00:05:51,490
你无法在之后添加内容

155
00:05:51,490 --> 00:05:52,620
你只能在末尾添加内容。

156
00:05:52,620 --> 00:05:54,370
某种程度上，这就像在编程磁带一样。

157
00:05:54,370 --> 00:05:57,710
你用机器语言构建过的最复杂的东西是什么？

158
00:05:57,710 --> 00:05:59,200
呃，应该就是那个游戏了。

159
00:05:59,200 --> 00:06:01,680
我是说，在汇编语言方面，我做过不少复杂的东西

160
00:06:01,680 --> 00:06:06,100
但在实际的机器语言层面，我想那款游戏可能是我唯一真正——你真的亲手开发过一款游戏？

161
00:06:06,100 --> 00:06:07,530
算不上多出色的游戏，但它确实能运行。

162
00:06:07,530 --> 00:06:08,760
好的。

163
00:06:08,760 --> 00:06:09,099
好的。

164
00:06:09,099 --> 00:06:10,320
然后你就把它删除了。

165
00:06:10,320 --> 00:06:11,020
我做到了。

166
00:06:11,020 --> 00:06:11,680
好的。

167
00:06:11,680 --> 00:06:14,099
你是什么时候第一次爱上编程的？

168
00:06:14,099 --> 00:06:18,379
当你意识到，这——这是件特别的事情时。

169
00:06:18,379 --> 00:06:19,900
对我来说，这分两个阶段。

170
00:06:19,900 --> 00:06:22,640
我始终清楚地知道，这些机器令我心驰神往

171
00:06:22,640 --> 00:06:27,800
从 TRS-80 Model 1 开始，我唯一的愿望就是骑车去那里，花更多时间与它相处

172
00:06:27,800 --> 00:06:31,900
我也确实这么做了，可以说是在尽可能透支我的热情

173
00:06:31,900 --> 00:06:35,700
另一个顿悟时刻，我想是在大学二年级或三年级时，当我意识到

174
00:06:35,700 --> 00:06:37,920
我热爱编程，但我完全不知道自己将来要做什么。

175
00:06:37,920 --> 00:06:40,210
是要去捣鼓某个录像机上的 12 点闪烁显示

176
00:06:40,210 --> 00:06:41,840
还是去开发操作系统？

177
00:06:41,840 --> 00:06:45,440
毕业后究竟要做什么，我完全没有头绪。

178
00:06:45,440 --> 00:06:46,997
但我热爱我所做的事。

179
00:06:46,997 --> 00:06:49,800
"所以，我觉得那给了我很大的安慰。

180
00:06:49,800 --> 00:06:52,260
就像，此刻我在做什么其实并不重要

181
00:06:52,260 --> 00:06:53,881
因为我就是喜欢做这些事，所以。

182
00:06:53,881 --> 00:06:54,110
..

183
00:06:54,110 --> 00:06:55,289
你会找到解决方法的。

184
00:06:55,289 --> 00:06:55,850
是的。

185
00:06:55,850 --> 00:06:59,490
只要跟随这种直觉指引——我就知道自己找对了方向

186
00:06:59,490 --> 00:07:00,219
最终，没错。

187
00:07:00,219 --> 00:07:01,130
是的。

188
00:07:01,130 --> 00:07:01,360
好的。

189
00:07:01,360 --> 00:07:02,880
你高中辍学了。

190
00:07:02,880 --> 00:07:04,000
是啊，这可不是最明智的选择。

191
00:07:04,000 --> 00:07:04,560
好的。

192
00:07:04,560 --> 00:07:07,940
但你最终重返校园并在学业上取得了巨大成功

193
00:07:07,940 --> 00:07:11,159
而且总体来说，作为一名程序员也很成功

194
00:07:11,159 --> 00:07:14,539
作为开发者，作为软件的创造者。

195
00:07:14,539 --> 00:07:17,220
呃，你是怎么找到方向的？

196
00:07:17,220 --> 00:07:19,850
能说说那段辍学的经历吗？——嗯。

197
00:07:19,850 --> 00:07:19,850
.

198
00:07:19,850 --> 00:07:19,850
.

199
00:07:19,850 --> 00:07:21,780
然后又是怎么重新找到方向的？

200
00:07:21,780 --> 00:07:23,300
我其实并没有真正辍学的时刻。

201
00:07:23,300 --> 00:07:28,039
你去的次数越来越少，直到某天意识到：要是我突然出现会很尴尬，因为已经太久没去了

202
00:07:28,039 --> 00:07:29,360
很快你就会彻底不去了

203
00:07:29,360 --> 00:07:30,680
这就是你从高中辍学的方式

204
00:07:30,680 --> 00:07:32,470
所以如果你发现自己正走上这条路

205
00:07:32,470 --> 00:07:34,080
别那么做了。

206
00:07:34,080 --> 00:07:36,280
呃，但我确实就那么做了。

207
00:07:36,280 --> 00:07:39,110
所以现在我没在上学，得找份工作

208
00:07:39,110 --> 00:07:42,840
于是我在 7-Eleven 便利店和油漆仓库之类的地方打工。

209
00:07:42,840 --> 00:07:53,180
在 7-Eleven 工作其实挺有意思的，我觉得这个岗位会轮换给那些足够聪明、能胜任夜班的人，因为夜班要处理所有会计和行政之类的工作

210
00:07:53,180 --> 00:07:56,659
但这些人选择在 7-Eleven 工作都有各自的个人原因

211
00:07:56,659 --> 00:07:58,460
嗯，我就是其中之一

212
00:07:58,460 --> 00:08:00,480
因为我没有高中文凭

213
00:08:00,480 --> 00:08:03,720
在 7-Eleven 工作期间有哪些难忘的时刻？

214
00:08:03,720 --> 00:08:06,340
呃，也许你，呃

215
00:08:06,340 --> 00:08:09,140
觉得这份工作最难的地方是什么？

216
00:08:09,140 --> 00:08:10,330
对我来说最糟糕的时刻大概是——我是说

217
00:08:10,330 --> 00:08:11,789
我被持刀抢劫之类的事

218
00:08:11,789 --> 00:08:13,830
这些都挺刺激的，但最糟糕的是

219
00:08:13,830 --> 00:08:17,578
对我来说最痛苦的部分是测油井倾斜度

220
00:08:17,578 --> 00:08:23,020
要用一根大约 15 到 20 英尺长的木棍，上面标着英寸和英尺的刻度

221
00:08:23,020 --> 00:08:28,560
你把量油杆放进油箱，再抽出来测量汽油液面位置，因为当时没有电子传感器。

222
00:08:28,560 --> 00:08:29,060
嗯哼。

223
00:08:29,060 --> 00:08:30,620
我正在这么做，第一次尝试时

224
00:08:30,620 --> 00:08:33,000
量油杆脱手滑落，我赶紧重新抓住

225
00:08:33,000 --> 00:08:38,720
结果手上扎满了木刺，当时零下 40 度的低温让这糟糕透了。

226
00:08:38,720 --> 00:08:39,659
哇，天哪。

227
00:08:39,659 --> 00:08:43,268
嗯，然后我意识到，"我不想一辈子都做这个。

228
00:08:43,268 --> 00:08:44,193
" 我明白这一点，所以。

229
00:08:44,193 --> 00:08:44,309
..

230
00:08:44,309 --> 00:08:44,780
好的。

231
00:08:44,780 --> 00:08:47,589
于是你站在那里，手里扎着木刺，动弹不得。

232
00:08:47,589 --> 00:08:51,220
在某个瞬间，我突然对自己的生活有了顿悟

233
00:08:51,220 --> 00:08:54,100
下一次我要以不同的方式生活。

234
00:08:54,100 --> 00:08:57,410
三秒后我才意识到这个念头有多荒谬

235
00:08:57,410 --> 00:08:57,680
对吧？

236
00:08:57,680 --> 00:09:02,560
那一刻我真正意识到：必须做出改变。

237
00:09:02,560 --> 00:09:04,850
尽管我已经 21 岁了，我还是去见了

238
00:09:04,850 --> 00:09:07,160
呃，我们当地高中的校长

239
00:09:07,160 --> 00:09:08,932
我问他："能让我重新入学吗？

240
00:09:08,932 --> 00:09:11,635
" 他回答说："不行，你年龄太大了，而且我们也没有名额。"

241
00:09:11,635 --> 00:09:13,640
"这是他最主要的原因。

242
00:09:13,640 --> 00:09:15,860
而我说："好吧，从现在到那时

243
00:09:15,860 --> 00:09:16,940
总会有人退出的。

244
00:09:16,940 --> 00:09:18,640
所以你会有位置的。

245
00:09:18,640 --> 00:09:19,970
那么假设你有空位。

246
00:09:19,970 --> 00:09:20,581
我能回来吗？

247
00:09:20,581 --> 00:09:22,450
" 他很和善，允许我回来

248
00:09:22,450 --> 00:09:24,960
于是我补上了需要的那三四节课。

249
00:09:24,960 --> 00:09:27,339
是啊，你知道的，如果我们能多停留一会儿

250
00:09:27,339 --> 00:09:29,640
慢慢抽离出来。

251
00:09:29,640 --> 00:09:32,620
这是你可以用大脑做的一件奇妙的事。

252
00:09:32,620 --> 00:09:37,140
你会意识到，你不必随波逐流做大家都在做的事。

253
00:09:37,140 --> 00:09:39,440
而这正是个危险的认知。

254
00:09:39,440 --> 00:09:44,240
因为，某种程度上，你必须融入社会才能完成某些事情。

255
00:09:44,240 --> 00:09:44,880
没错。

256
00:09:44,880 --> 00:09:48,149
而如果你意识到，其实不必随波逐流

257
00:09:48,149 --> 00:09:53,910
那么，你的人生要么会精彩绝伦，要么将举步维艰。

258
00:09:53,910 --> 00:09:57,380
问题是，这个过程让你只做了一个小决定。

259
00:09:57,380 --> 00:09:58,914
"我今天就不去上课了。"

260
00:09:58,914 --> 00:09:59,260
"是的。"

261
00:09:59,260 --> 00:10:00,400
这就是你做出的全部决定。

262
00:10:00,400 --> 00:10:02,940
但当你重复多次，实际上是在做一个更大的决定。

263
00:10:02,940 --> 00:10:03,579
嗯哼。

264
00:10:03,579 --> 00:10:04,440
这就是问题所在。

265
00:10:04,440 --> 00:10:05,761
所以最好明确做出决定。

266
00:10:05,761 --> 00:10:06,010
..

267
00:10:06,010 --> 00:10:08,329
如果你想以非标准的方式生活

268
00:10:08,329 --> 00:10:12,670
最好明确做出重大决定，然后就可以停止前行了。

269
00:10:12,670 --> 00:10:13,170
是的。

270
00:10:13,170 --> 00:10:17,390
呃，别让自己犯那个——那个——那个错误，它迟早会找上你的。

271
00:10:17,390 --> 00:10:17,690
是的。

272
00:10:17,690 --> 00:10:18,600
好的。

273
00:10:18,600 --> 00:10:23,160
后来你回来了，最终上了大学，作为学生非常成功，

274
00:10:23,160 --> 00:10:24,960
而你以前并不是那么好的学生。

275
00:10:24,960 --> 00:10:26,160
没错，我高中时是个糟糕透顶的学生。

276
00:10:26,160 --> 00:10:32,660
甚至在我大学第一学期时，我仍然没太当回事，因为几何 90 这门课老师仁慈地让我及格了

277
00:10:32,660 --> 00:10:37,200
这门课相当于我 12 年级没上的几何课的补修课程

278
00:10:37,200 --> 00:10:43,569
这让我感到后怕，因为我意识到只差 1%——或者说全凭那位放我过关的教授的仁慈

279
00:10:43,569 --> 00:10:46,130
我差点就在这里断送了自己的整个大学生涯

280
00:10:46,130 --> 00:10:50,280
幸运的是，这些成绩不计入成绩单，因为它们只是补习课程。

281
00:10:50,280 --> 00:10:55,839
于是我在新学期获得了重新开始的机会，这次是真正为自己而学，一切都变得不同了。

282
00:10:55,839 --> 00:11:00,260
关于如何成为一名成功的学生，你有什么建议可以分享吗？

283
00:11:00,260 --> 00:11:03,220
理想情况下，你应该能找到学校里某个你真正喜欢的方面

284
00:11:03,220 --> 00:11:05,000
无论是艺术，还是计算机科学

285
00:11:05,000 --> 00:11:06,810
无论是工艺课，还是其他任何课程

286
00:11:06,810 --> 00:11:14,390
所以去上这些课吧，坚持完成那些困难的内容，因为这比以后不得不补要容易得多

287
00:11:14,390 --> 00:11:15,990
这话从 50 多岁的人嘴里说出来当然轻松

288
00:11:15,990 --> 00:11:18,289
15 岁左右的时候很难说出口，但是——确实。

289
00:11:18,289 --> 00:11:19,003
.

290
00:11:19,003 --> 00:11:19,010
..

291
00:11:19,010 --> 00:11:20,280
这很有道理。

292
00:11:20,280 --> 00:11:21,280
好的。

293
00:11:21,280 --> 00:11:23,260
你加入微软的故事是怎样的？

294
00:11:23,260 --> 00:11:27,860
我们是怎么从 7-Eleven 便利店一路走到微软的？

295
00:11:27,860 --> 00:11:28,770
是的，这是个巨大的跨越。

296
00:11:28,770 --> 00:11:32,720
当时我重返校园，记得是在大学的第三年

297
00:11:32,720 --> 00:11:40,360
暑期我在电话公司打工，负责将他们 UBNET 系统转换为 TCP/IP 现代网络协议

298
00:11:40,360 --> 00:11:43,436
实际上就是更换硬件卡件，然后排查配置问题

299
00:11:43,436 --> 00:11:48,819
系统不再允许 Lotus 运行，因为它比从前少了 1 万，现在真不是从事计算机工作的好时候

300
00:11:48,819 --> 00:11:50,440
但我还是坚持在做。

301
00:11:50,440 --> 00:11:55,770
午餐时分，我坐在美食广场，周围都是些上了年纪的人和百无聊赖的人，我正在读一本买来的书

302
00:11:55,770 --> 00:12:00,060
嗯，书名是《微软或比尔·盖茨与微软硬盘的诞生》

303
00:12:00,060 --> 00:12:00,860
我认为这是标题。

304
00:12:00,860 --> 00:12:02,420
这是一本很棒的书。

305
00:12:02,420 --> 00:12:05,700
它只是实事求是地记录了微软的崛起历程

306
00:12:05,700 --> 00:12:08,733
包括公司的运作方式、内部文化以及员工风貌。

307
00:12:08,733 --> 00:12:08,984
..

308
00:12:08,984 --> 00:12:14,540
我正在读这本书，完全被它迷住了，因为它描述的地方正是我心之所向

309
00:12:14,540 --> 00:12:17,740
但我身在萨斯喀彻温省，又能怎么办呢？

310
00:12:17,740 --> 00:12:21,780
最终我采取的行动是，通过一个叫 HyperCache 的项目半工半读完成学业

311
00:12:21,780 --> 00:12:24,400
这是为 Amiga 计算机设计的文件系统缓存

312
00:12:24,400 --> 00:12:27,520
因为 Amiga 电脑开箱即用的功能有限

313
00:12:27,520 --> 00:12:30,880
而且它表现相当不错，于是我开始整理用户登记卡

314
00:12:30,880 --> 00:12:34,849
那时候每张 4x6 英寸的卡片都需要用户填写姓名、地址

315
00:12:34,849 --> 00:12:36,219
如果有电子邮箱的话还要填写邮箱地址

316
00:12:36,219 --> 00:12:39,003
他们提交后，会收到更新通知等等。

317
00:12:39,003 --> 00:12:39,010
..

318
00:12:39,010 --> 00:12:44,459
我翻遍了整个技术栈，寻找任何带有微软邮箱地址的人

319
00:12:44,459 --> 00:12:46,699
结果只找到大概三四个人

320
00:12:46,699 --> 00:12:48,000
我就直接给他们发了冷邮件说

321
00:12:48,000 --> 00:12:52,349
"嘿，我是萨斯喀彻温省的一名操作系统专业学生，正在寻找机会。

322
00:12:52,349 --> 00:12:54,740
"我不太记得当时具体说了什么

323
00:12:54,740 --> 00:12:59,099
但有个叫阿利斯泰尔的人，阿利斯泰尔·班克斯，他回复我说

324
00:12:59,099 --> 00:13:00,943
"我认识个人可以帮你牵线联系"

325
00:13:00,943 --> 00:13:02,120
" 是他帮我牵线搭桥的，我想

326
00:13:02,120 --> 00:13:04,300
联系到了一个叫本·斯利夫卡的人，他对我进行了电话面试

327
00:13:04,300 --> 00:13:07,880
最终想雇我在暑期从事 MS-DOS 方面的工作

328
00:13:07,880 --> 00:13:10,180
就这样我得到了这个机会。

329
00:13:10,180 --> 00:13:12,117
你靠自己的力量完成了学业。

330
00:13:12,117 --> 00:13:12,569
..

331
00:13:12,569 --> 00:13:13,959
跟我讲讲 HyperCache 吧。

332
00:13:13,959 --> 00:13:17,260
你开发了一款软件——堪称硬盘的瘦身程序。

333
00:13:17,260 --> 00:13:24,800
这款软件对足够多的人确实有用，以至于他们愿意为此付费？

334
00:13:24,800 --> 00:13:25,910
确实赚了不少钱。

335
00:13:25,910 --> 00:13:27,920
我是说，我卖出了几千份——没错。

336
00:13:27,920 --> 00:13:27,930
.

337
00:13:27,930 --> 00:13:27,930
..

338
00:13:27,930 --> 00:13:29,575
每份 20 美元或 40 美元。

339
00:13:29,575 --> 00:13:29,589
..

340
00:13:29,589 --> 00:13:29,890
大概就是这个价。

341
00:13:29,890 --> 00:13:31,560
那个程序是用什么语言编写的？

342
00:13:31,560 --> 00:13:32,280
C 语言。

343
00:13:32,280 --> 00:13:32,620
C 语言。

344
00:13:32,620 --> 00:13:33,602
所以还用了些汇编语言。

345
00:13:33,602 --> 00:13:33,609
..

346
00:13:33,609 --> 00:13:38,280
实际执行数据进出缓存的核心代码仅有 68 行

347
00:13:38,280 --> 00:13:39,359
汇编语言

348
00:13:39,359 --> 00:13:40,699
其余部分都是用 C 语言编写的

349
00:13:40,699 --> 00:13:42,520
好吧，这就像是...

350
00:13:42,520 --> 00:13:43,599
文件系统 IO？

351
00:13:43,599 --> 00:13:44,920
设备块 IO。

352
00:13:44,920 --> 00:13:48,000
因此，任何从驱动器处理的块都会先经过我的缓存

353
00:13:48,000 --> 00:13:54,500
这是一个 N 路组相联缓存，它会尝试匹配驱动器的几何结构并基于此进行预取

354
00:13:54,500 --> 00:13:56,099
你知道，试图一次性读取整个轨道

355
00:13:56,099 --> 00:13:57,260
类似这样的事情。

356
00:13:57,260 --> 00:14:02,540
当时尝试把你的软件推广出去是什么感觉？

357
00:14:02,540 --> 00:14:05,699
比如，你在哪里、如何能找到客户？

358
00:14:05,699 --> 00:14:06,420
是啊，这挺有意思的。

359
00:14:06,420 --> 00:14:09,400
我记得最早是在 Usenet 和一些 Amiga 论坛上

360
00:14:09,400 --> 00:14:13,459
发帖说"这是我的试用版，30 天免费试用

361
00:14:13,459 --> 00:14:16,640
看看你喜欢哪些功能"，后来有几家零售商开始进货销售

362
00:14:16,640 --> 00:14:19,240
我记得当时我和现在的妻子一起坐在她的车里

363
00:14:19,240 --> 00:14:22,230
她有一部手机，因为她父亲非常担心她的安全

364
00:14:22,230 --> 00:14:24,468
那是 80 年代末，她车里装着

365
00:14:24,468 --> 00:14:26,468
车顶有天线，后备箱里还有个大大的机箱

366
00:14:26,468 --> 00:14:27,589
整笔交易。

367
00:14:27,589 --> 00:14:28,930
但我们接到一个

368
00:14:28,930 --> 00:14:32,730
呃，软件零售商的电话，他们想以 20 美元的价格购买 50 份

369
00:14:32,730 --> 00:14:36,170
对我来说这就是一千美元，在 1989 年或不管哪一年

370
00:14:36,170 --> 00:14:41,180
这是一件大事，所以最终不少公司直接采购了大量库存。

371
00:14:41,180 --> 00:14:45,339
让我们回到那个时代，那是个非常有趣的时期，比尔·盖茨和微软正如日中天。

372
00:14:45,339 --> 00:14:50,140
你认为为什么当时微软能在软件和个人计算领域占据主导地位，

373
00:14:50,140 --> 00:14:52,599
并且在之后的很多很多年里都保持着这种优势？

374
00:14:52,599 --> 00:14:58,839
当时，那是我参与过的最为强大的精英团队集合

375
00:14:58,839 --> 00:15:02,220
而我也曾在学术界和工业界有过一定经历

376
00:15:02,220 --> 00:15:03,165
并且

377
00:15:03,165 --> 00:15:03,569
..

378
00:15:03,569 --> 00:15:06,849
你知道，当你在普通计算机公司工作时

379
00:15:06,849 --> 00:15:09,180
那个真正懂行的家伙

380
00:15:09,180 --> 00:15:10,540
他那个更聪明的朋友？

381
00:15:10,540 --> 00:15:12,000
他八成在微软工作吧

382
00:15:12,000 --> 00:15:14,260
所以当你到了那儿 就成了小地方来的大人物

383
00:15:14,260 --> 00:15:16,390
你以为自己懂得很多，突然间

384
00:15:16,390 --> 00:15:17,650
你发现自己所处的环境让你觉得

385
00:15:17,650 --> 00:15:20,007
"呃，我还是别开口了，免得显得很蠢"

386
00:15:20,007 --> 00:15:20,599
嗯。

387
00:15:20,599 --> 00:15:20,910
好的。

388
00:15:20,910 --> 00:15:23,430
那比尔·盖茨本人呢？他又是怎样的？

389
00:15:23,430 --> 00:15:28,180
你认为比尔·盖茨的哪些特质促成了微软的成功？

390
00:15:28,180 --> 00:15:31,020
我认为他对自己梦想的追求始终不懈

391
00:15:31,020 --> 00:15:35,000
这个梦想正是他早年提出的口号：让每个家庭、每张办公桌都拥有一台电脑。

392
00:15:35,000 --> 00:15:37,020
这是一种非凡的执着。

393
00:15:37,020 --> 00:15:39,140
他是个聪明人，而且极其坚定

394
00:15:39,140 --> 00:15:42,760
他雇佣了与他同样聪明甚至更聪明的人来协助执行

395
00:15:42,760 --> 00:15:49,380
他打造了一台几乎不可阻挡的智力机器去创造

396
00:15:49,380 --> 00:15:51,160
可以说是非常简单的产品

397
00:15:51,160 --> 00:15:53,920
MS-DOS 绝非复杂的产品

398
00:15:53,920 --> 00:15:56,079
但它正是当时市场所需要的

399
00:15:56,079 --> 00:15:56,900
是的。

400
00:15:56,900 --> 00:16:00,339
我的意思是，MS-DOS 改变了游戏规则

401
00:16:00,339 --> 00:16:02,319
而你加入的正是那个团队

402
00:16:02,319 --> 00:16:06,550
MS-DOS 团队，我记得你是在 Windows 95 发布前加入的 - 是的。

403
00:16:06,550 --> 00:16:06,550
.

404
00:16:06,550 --> 00:16:06,550
.

405
00:16:06,550 --> 00:16:07,800
发布之前。

406
00:16:07,800 --> 00:16:10,939
嗯，给我讲讲 MS-DOS 的故事吧。

407
00:16:10,939 --> 00:16:18,230
MS-DOS 的成功可以说对微软的成功起到了关键作用。

408
00:16:18,230 --> 00:16:20,490
是的，在 DOS 之前，他们主要是一家语言公司。

409
00:16:20,490 --> 00:16:24,359
他们为许多电脑开发了 BASIC 语言，还拥有 Fortran 编译器和 Pascal 编译器

410
00:16:24,359 --> 00:16:33,349
这类产品，但他们让 MS-DOS 成为每台 PC 标配的协议，实际上确立了他们的行业标准地位

411
00:16:33,349 --> 00:16:37,240
这个优势让他们得以在之后几十年里持续获益

412
00:16:37,240 --> 00:16:40,750
在一定程度上，他们算是幸运地碰上了这个机会，而从另一方面来看

413
00:16:40,750 --> 00:16:42,801
他们这么做确实很聪明。

414
00:16:42,801 --> 00:16:43,270
..

415
00:16:43,270 --> 00:16:45,859
因为我听说他们并没有向 IBM 收取太多费用

416
00:16:45,859 --> 00:16:51,160
但将其确立为标准确实在长期发展中给他们带来了优势。

417
00:16:51,160 --> 00:16:54,920
呃，那时候的 MS-DOS 还没有图形界面。

418
00:16:54,920 --> 00:16:57,500
你能简单说说 MS-DOS 到底是什么吗？

419
00:16:57,500 --> 00:16:59,160
它本质上是个命令启动器。

420
00:16:59,160 --> 00:17:00,660
就是你输入命令名称来操作

421
00:17:00,660 --> 00:17:04,118
它会检查该路径是否在当前目录或特定的文件夹路径中

422
00:17:04,118 --> 00:17:07,319
并将其加载到内存中，如果存在则执行

423
00:17:07,319 --> 00:17:10,240
这就是 MS-DOS 90%的功能

424
00:17:10,240 --> 00:17:14,550
它现在拥有环境变量和一些复杂性，还内置了一个小型脚本语言

425
00:17:14,550 --> 00:17:17,980
但本质上它只是一个允许你操作的操作系统外壳

426
00:17:17,980 --> 00:17:19,579
呃，利用计算机的资源

427
00:17:19,579 --> 00:17:23,579
比如硬盘或 CPU，但它不允许你进行多任务处理。

428
00:17:23,579 --> 00:17:25,040
没有图形界面。

429
00:17:25,040 --> 00:17:32,594
后来，微软确实在 DOS 5 中为编辑器和 QuickBASIC 等程序添加了基于文本的图形界面。

430
00:17:32,594 --> 00:17:34,720
我相信，当时确实有一个 DOS shell

431
00:17:34,720 --> 00:17:38,509
它在 MS-DOS 4 中算是一种图形化的文件管理器

432
00:17:38,509 --> 00:17:38,840
0.

433
00:17:38,840 --> 00:17:42,000
所以他们尝试过这个方案，但主要还是命令行界面

434
00:17:42,000 --> 00:17:44,320
D-它能进行通信吗

435
00:17:44,320 --> 00:17:47,980
呃，外部设备，比如驱动程序和那些东西？

436
00:17:47,980 --> 00:17:52,159
那么，MS-DOS 这个操作系统有多庞大呢？

437
00:17:52,159 --> 00:17:55,620
嗯，它受限于最初的 x86 指令集

438
00:17:55,620 --> 00:17:57,990
这限制了它只能使用 640K 内存，然后——没错。

439
00:17:57,990 --> 00:17:57,990
.

440
00:17:57,990 --> 00:17:57,990
.

441
00:17:57,990 --> 00:18:02,600
在那基础上还有各种临时解决方案来实现高内存，甚至进一步扩展内存。

442
00:18:02,600 --> 00:18:09,763
而且，呃，要让任何程序在不占用基础内存的情况下运行，都需要费尽周折。

443
00:18:09,763 --> 00:18:13,136
是啊，我是说，你——所以你是在 MS-DOS 系统上编程的。

444
00:18:13,136 --> 00:18:13,896
那——那是什么感觉？

445
00:18:13,896 --> 00:18:15,716
那里有什么有趣的细节？

446
00:18:15,716 --> 00:18:19,476
就像你说的，有内存限制——640

447
00:18:19,476 --> 00:18:20,315
呃，千字节。

448
00:18:20,315 --> 00:18:21,096
是的。

449
00:18:21,096 --> 00:18:23,636
640K 是永远可用的最大内存

450
00:18:23,636 --> 00:18:29,436
所以这不是操作系统开发者能随意使用的资源，因为你所用的正是用户无法获得的。

451
00:18:29,436 --> 00:18:31,602
因此，如果你不必要地消耗了 10K 资源，那么...

452
00:18:31,602 --> 00:18:31,726
..

453
00:18:31,726 --> 00:18:33,555
全球每台机器都将因此减少 10K 可用资源

454
00:18:33,555 --> 00:18:35,596
这确实是项重大责任。

455
00:18:35,596 --> 00:18:37,676
这是比尔·盖茨的真实语录吗

456
00:18:37,676 --> 00:18:40,505
他说过"没人会需要超过 640K 内存"这句话？

457
00:18:40,505 --> 00:18:40,815
是的。

458
00:18:40,815 --> 00:18:40,956
是的。

459
00:18:40,956 --> 00:18:41,896
不，这不是他说的

460
00:18:41,896 --> 00:18:42,254
好的。

461
00:18:42,254 --> 00:18:43,836
虽然常被归到他名下，但并非事实。

462
00:18:43,836 --> 00:18:44,356
呃，好的。

463
00:18:44,356 --> 00:18:51,936
那么，你在实习期间以及加入 MS-DOS 团队后，有哪些特别有意思的工作经历可以分享吗？

464
00:18:51,936 --> 00:18:53,836
我最初接手的工作之一就是负责 SmartDrive

465
00:18:53,836 --> 00:18:56,106
这个磁盘缓存程序，因为我对磁盘缓存比较熟悉——嗯。

466
00:18:56,106 --> 00:18:56,122
.

467
00:18:56,122 --> 00:18:56,136
..

468
00:18:56,136 --> 00:18:58,876
并且为它添加了 CD-ROM 缓存功能，因为这项技术当时还是新鲜事物。

469
00:18:58,876 --> 00:19:01,075
CD-ROM 驱动器那时才刚刚——才刚刚问世。

470
00:19:01,075 --> 00:19:04,096
微软书架(Microsoft Bookshelf)是少数几个能在其上运行的应用程序之一。

471
00:19:04,096 --> 00:19:08,386
正如你所想象的，如果处理得当，为 CD 设置缓存可以将其运行速度提升数十倍。

472
00:19:08,386 --> 00:19:11,936
所以，这——这是一个显著的性能提升，也是值得投入的工作。

473
00:19:11,936 --> 00:19:19,456
嗯，其中更重要的部分是将大量 SmartDrive 以及最终的双倍间距压缩引擎迁移到所谓的高内存区域。

474
00:19:19,456 --> 00:19:19,835
嗯哼。

475
00:19:19,835 --> 00:19:22,396
在不深入探讨技术细节的情况下

476
00:19:22,396 --> 00:19:24,176
在 x86 架构上，存在某种机制，我相信

477
00:19:24,176 --> 00:19:25,466
称为 A20 线。

478
00:19:25,466 --> 00:19:28,015
我可能搞反了，或者有 50%的几率猜对

479
00:19:28,015 --> 00:19:30,596
但如果你启用了 A20 线

480
00:19:30,596 --> 00:19:33,596
那么你的内存指针会在 1MB 标记处回绕

481
00:19:33,596 --> 00:19:34,076
嗯哼。

482
00:19:34,076 --> 00:19:35,835
如果没有，它们就不会。

483
00:19:35,835 --> 00:19:37,745
因此，它会继续在内存中向上增长。

484
00:19:37,745 --> 00:19:43,866
所以你可以通过将段寄存器和偏移寄存器组合成一个大于 1MB 的数字来重写上方内存

485
00:19:43,866 --> 00:19:51,275
这样你就获得了额外的 64K 空间，将代码放入其中，然后只需在低内存中放置跳转到该代码的存根即可。

486
00:19:51,275 --> 00:19:53,896
这样你就能从机器中再榨取出 64K 内存

487
00:19:53,896 --> 00:19:56,243
我们为几款产品都采用了这种做法

488
00:19:56,243 --> 00:19:56,406
..

489
00:19:56,406 --> 00:20:01,096
我当时完全不懂什么是高端内存，因为我之前是 Amiga 程序员，在加入之前从未写过任何 x86 代码

490
00:20:01,096 --> 00:20:01,738
所以...

491
00:20:01,738 --> 00:20:02,126
..

492
00:20:02,126 --> 00:20:04,876
所以，能参与这样的优化工作真的很酷

493
00:20:04,876 --> 00:20:05,555
是的。

494
00:20:05,555 --> 00:20:07,076
那么，Windows 的情况如何？

495
00:20:07,076 --> 00:20:09,196
当时 Windows 95 也在并行开发中

496
00:20:09,196 --> 00:20:10,265
就在那个时候。

497
00:20:10,265 --> 00:20:12,755
你有机会和那些人交流吗？

498
00:20:12,755 --> 00:20:15,376
我实际上在 Windows 95 上工作了大约三四个月。

499
00:20:15,376 --> 00:20:17,876
我当时在 COM/OLA 团队负责演示缓存功能

500
00:20:17,876 --> 00:20:19,696
就是当你插入一个

501
00:20:19,696 --> 00:20:23,706
比如 Word 或 Excel 电子表格或图表到 Word 文档时的功能

502
00:20:23,706 --> 00:20:26,606
你不想每次都要加载 Excel 才能渲染它

503
00:20:26,606 --> 00:20:30,376
因此有一个增强型图元文件的呈现缓存，我当时就在做这个

504
00:20:30,376 --> 00:20:36,216
这个功能随 Windows 95 一起发布，但我在加入微软约六个月后就转到了 Shell 团队

505
00:20:36,216 --> 00:20:38,656
从那时起，我就开始从事 NT 系统的工作

506
00:20:38,656 --> 00:20:39,876
好的，那 95 是什么？

507
00:20:39,876 --> 00:20:40,856
NT 是什么？

508
00:20:40,856 --> 00:20:44,646
呃，Windows 95 是 16 位 Windows 3.1 的升级版，

509
00:20:44,646 --> 00:20:48,035
而 3.1 是 Windows 最早流行的版本。

510
00:20:48,035 --> 00:20:54,576
它增加了 32 位支持、VXD 驱动程序、一系列新技术以及全新的用户界面。

511
00:20:54,576 --> 00:20:56,626
这在当时是具有革命性的。

512
00:20:56,626 --> 00:20:58,146
人们甚至彻夜排队，

513
00:20:58,146 --> 00:20:59,775
就为了购买这款产品。

514
00:20:59,775 --> 00:21:07,445
能否带我们回到那个时代，解释一下为什么 95 相比 3 是一个巨大的飞跃？

515
00:21:07,445 --> 00:21:07,656
1？

516
00:21:07,656 --> 00:21:10,676
当时苹果已经有了图形界面。

517
00:21:10,676 --> 00:21:11,709
呃，Windows 3。

518
00:21:11,709 --> 00:21:13,936
1 拥有图形界面。

519
00:21:13,936 --> 00:21:17,196
W- 为什么 Windows 95 是一个如此巨大的飞跃？

520
00:21:17,196 --> 00:21:19,136
我不想让它像开始菜单那样基础

521
00:21:19,136 --> 00:21:20,284
但我认为- 。

522
00:21:20,284 --> 00:21:20,284
..

523
00:21:20,284 --> 00:21:21,156
这是其中很重要的一部分。

524
00:21:21,156 --> 00:21:22,725
当我第一次看到它时，我就知道——是的。

525
00:21:22,725 --> 00:21:22,725
.

526
00:21:22,725 --> 00:21:22,725
.

527
00:21:22,725 --> 00:21:25,616
我无法具体说出它有何不同和出色之处

528
00:21:25,616 --> 00:21:27,456
但我意识到我想成为其中的一部分

529
00:21:27,456 --> 00:21:30,136
这就是我开始编写一个后来演变成

530
00:21:30,136 --> 00:21:31,535
呃，zip 文件夹的 shell 扩展程序的原因。

531
00:21:31,535 --> 00:21:31,916
嗯哼。

532
00:21:31,916 --> 00:21:34,755
但我当时只是对新 shell 着迷

533
00:21:34,755 --> 00:21:39,596
所以最终我加入了将那个 shell 移植到 NT 系统（也就是今天的 Windows）的团队。

534
00:21:39,596 --> 00:21:43,676
你会说那是有史以来最伟大的操作系统吗？

535
00:21:43,676 --> 00:21:46,716
什么是有史以来最具影响力的操作系统？

536
00:21:46,716 --> 00:21:48,275
对我来说，Windows 95 会排在第二位。

537
00:21:48,275 --> 00:21:50,436
我认为 OS/360 将是第一名。

538
00:21:50,436 --> 00:21:51,495
好的，有意思。

539
00:21:51,495 --> 00:21:55,735
因为你可以用一台机器在 1962 年写一个 COBOL 程序

540
00:21:55,735 --> 00:22:00,856
跳进你的时间机器，去波基普西启动一台 IBM z17 大型机，今天就能运行它。

541
00:22:00,856 --> 00:22:02,775
而他们这么多年来一直在这么做。

542
00:22:02,775 --> 00:22:04,116
就是这样。

543
00:22:04,116 --> 00:22:08,235
而且这些都集中在商业领域，我们作为普通消费者很难接触到

544
00:22:08,235 --> 00:22:14,686
但我认为它对商业领域的影响，可能就像 Windows 95 对家庭用户的影响一样深远。

545
00:22:14,686 --> 00:22:16,515
然后对我来说，Linux 可能排在第三位。

546
00:22:16,515 --> 00:22:18,995
我把 Linux b-标为比 Unix 更强大

547
00:22:18,995 --> 00:22:21,656
但这并不成立，因为没有 Unix 就不会有 Linux

548
00:22:21,656 --> 00:22:24,555
不过 Unix、BSD 等系统的影响力

549
00:22:24,555 --> 00:22:26,335
主要还是在学术领域。

550
00:22:26,335 --> 00:22:29,396
这是程序员为程序员打造的作品。

551
00:22:29,396 --> 00:22:32,340
就这样，Linux 诞生了。

552
00:22:32,340 --> 00:22:32,706
..

553
00:22:32,706 --> 00:22:39,196
我的意思是，它是以最大规模体现开源精神的典范。

554
00:22:39,196 --> 00:22:39,505
明白了吗？

555
00:22:39,505 --> 00:22:45,525
它几乎创造了一个社区，并且形成了一种编程精神

556
00:22:45,525 --> 00:22:48,045
这种精神延续至今。

557
00:22:48,045 --> 00:22:49,196
确实如此。

558
00:22:49,196 --> 00:22:49,815
确实如此。

559
00:22:49,815 --> 00:22:51,156
规模确实很重要。

560
00:22:51,156 --> 00:22:53,676
是的，现在服务器端已经实现了渗透

561
00:22:53,676 --> 00:22:56,696
我不确定这是否达到了 System/360 的成就水平

562
00:22:56,696 --> 00:22:59,176
但它几乎无处不在，所以。

563
00:22:59,176 --> 00:22:59,466
是的。

564
00:22:59,466 --> 00:22:59,873
这个世界。

565
00:22:59,873 --> 00:22:59,946
..

566
00:22:59,946 --> 00:23:02,976
我是说，这是宇宙中不为人知的秘密

567
00:23:02,976 --> 00:23:05,476
它运行在 Linux 系统上。

568
00:23:05,476 --> 00:23:08,255
好吧，那么，呃，跟我讲讲那些日子

569
00:23:08,255 --> 00:23:10,535
呃，你的工作日。

570
00:23:10,535 --> 00:23:12,056
那时候的工作日是什么样子的？

571
00:23:12,056 --> 00:23:15,376
回到，呃，回到 MS-DOS 和 Windows 95 时代？

572
00:23:15,376 --> 00:23:17,015
带我了解一个高效的工作日。

573
00:23:17,015 --> 00:23:20,815
好吧，你刚来上班就得先下载通讯录

574
00:23:20,815 --> 00:23:23,755
当时微软员工规模在 1 万到 1.5 万

575
00:23:23,755 --> 00:23:26,255
人之间，我们全都使用 MSMail 系统

576
00:23:26,255 --> 00:23:29,315
我们刚淘汰了那台绰号"猪小姐"的 PDP-11 主机

577
00:23:29,315 --> 00:23:33,136
该公司运营的是 Whizmail 系统，而我们现在使用的是 MSMail。

578
00:23:33,136 --> 00:23:37,631
但 MSMail 有一个固定的地址簿，每位用户每天早上都必须下载，而当有 10

579
00:23:37,631 --> 00:23:40,855
《Immersive Translate》

580
00:23:40,855 --> 00:23:43,815
我认为当时我们使用的是 10 兆比特的网络

581
00:23:43,815 --> 00:23:45,815
所以你第一个小时都在下载通讯录

582
00:23:45,815 --> 00:23:46,936
这总是让人很沮丧。

583
00:23:46,936 --> 00:23:51,795
但你会利用这段时间查看夜间"压力测试"过程中可能发生的崩溃

584
00:23:51,795 --> 00:23:57,806
所谓 NNT，就是让所有闲置的机器整夜运行测试，试图让自己崩溃。

585
00:23:57,806 --> 00:24:06,376
如果他们设法让系统崩溃，就会通过串行电缆连接到另一台机器的调试器，你可以连接到那台机器远程调试崩溃的系统。

586
00:24:06,376 --> 00:24:08,495
你来了之后，他们会先对错误进行分类处理

587
00:24:08,495 --> 00:24:11,245
比如，开始菜单出现了崩溃问题

588
00:24:11,245 --> 00:24:12,936
我们就会把这个任务分配给戴夫。

589
00:24:12,936 --> 00:24:14,315
所以你进来的第一件事

590
00:24:14,315 --> 00:24:17,323
就是连接，因为得把那台机器还给它的主人。

591
00:24:17,323 --> 00:24:17,461
..

592
00:24:17,461 --> 00:24:18,740
并解锁机器。

593
00:24:18,740 --> 00:24:21,560
这就是你每天的第一个小时。

594
00:24:21,560 --> 00:24:24,379
基本上是对夜间压力测试出现的漏洞进行分类处理

595
00:24:24,379 --> 00:24:27,439
然后这个时候，可能又要回到编码工作

596
00:24:27,439 --> 00:24:30,659
遗憾的是，80%的时间都在修复漏洞

597
00:24:30,659 --> 00:24:31,560
尤其在我的职业生涯中更是如此

598
00:24:31,560 --> 00:24:33,340
我在移植代码和修复漏洞。

599
00:24:33,340 --> 00:24:34,699
我没有编写太多新代码。

600
00:24:34,699 --> 00:24:35,419
而且存在一些例外情况。

601
00:24:35,419 --> 00:24:39,600
我私下写了很多新代码来释放压力——嗯哼。

602
00:24:39,600 --> 00:24:39,610
.

603
00:24:39,610 --> 00:24:39,610
..

604
00:24:39,610 --> 00:24:43,919
从日复一日为他人代码修复漏洞的繁琐工作中解脱出来

605
00:24:43,919 --> 00:24:46,479
这是绝佳的学习机会

606
00:24:46,479 --> 00:24:48,019
所以你在这方面投入了大量精力

607
00:24:48,019 --> 00:24:48,330
..

608
00:24:48,330 --> 00:24:51,270
在微软期间，你主导了大量的移植工作

609
00:24:51,270 --> 00:24:52,030
呃，这是什么？

610
00:24:52,030 --> 00:24:53,760
将 Windows 95 代码移植到 NT 系统？

611
00:24:53,760 --> 00:24:54,030
是的。

612
00:24:54,030 --> 00:24:57,219
我们把整个 Windows 95 的用户界面都移植到了 NT 系统上

613
00:24:57,219 --> 00:24:59,860
这意味着首先需要将其转换为 Unicode 编码。

614
00:24:59,860 --> 00:25:01,979
所以原本 8 位的现在都变成了 16 位

615
00:25:01,979 --> 00:25:03,047
指针也是如此。

616
00:25:03,047 --> 00:25:03,209
..

617
00:25:03,209 --> 00:25:06,060
转换代码时确实相当混乱

618
00:25:06,060 --> 00:25:07,360
你可以想象得到。

619
00:25:07,360 --> 00:25:12,020
能否为我们解析移植过程中涉及的内容？

620
00:25:12,020 --> 00:25:17,399
这就像闯入别人家里，翻遍他们的物品，看到他们不想让你看到的抽屉里的东西。

621
00:25:17,399 --> 00:25:17,639
是的。

622
00:25:17,639 --> 00:25:20,020
你会发现所有好东西，墙上挂着的漂亮画作

623
00:25:20,020 --> 00:25:23,100
也会在床头柜里发现一些令人不安的东西。

624
00:25:23,100 --> 00:25:25,120
呃，我看到过那种代码，大概

625
00:25:25,120 --> 00:25:27,919
有 200 多个字符那么宽，里面还夹杂着

626
00:25:27,919 --> 00:25:29,813
各种脏话和咒骂，不过

627
00:25:29,813 --> 00:25:29,889
..

628
00:25:29,889 --> 00:25:33,080
到我离职的时候，这些代码已经全部被清理干净了

629
00:25:33,080 --> 00:25:36,939
但这并不总是世界上最专业的代码。

630
00:25:36,939 --> 00:25:40,260
没错，因为你必须检查每一行代码。

631
00:25:40,260 --> 00:25:41,699
逐行检查，这样你就能看到所有内容。

632
00:25:41,699 --> 00:25:42,820
是的。

633
00:25:42,820 --> 00:25:44,020
是的。

634
00:25:44,020 --> 00:25:46,070
我是说，这就是程序员的故事。

635
00:25:46,070 --> 00:25:46,489
你认为。

636
00:25:46,489 --> 00:25:46,590
..

637
00:25:46,590 --> 00:25:49,790
你写了一段代码，以为永远不会

638
00:25:49,790 --> 00:25:51,870
永远不会被任何人看到，但有时

639
00:25:51,870 --> 00:25:55,489
很多时候，这段代码会被很多人看到——是的。

640
00:25:55,489 --> 00:25:55,563
.

641
00:25:55,563 --> 00:25:55,570
..

642
00:25:55,570 --> 00:25:58,439
五年后的你，包括你自己在内，都会受到影响。

643
00:25:58,439 --> 00:26:02,139
你自己审视自己写的代码。

644
00:26:02,139 --> 00:26:02,800
好的。

645
00:26:02,800 --> 00:26:05,100
那么，跟我讲讲 Windows NT 吧。

646
00:26:05,100 --> 00:26:06,540
那也是一次巨大的飞跃。

647
00:26:06,540 --> 00:26:06,929
是的。

648
00:26:06,929 --> 00:26:08,340
它基本上是一个全新的设计。

649
00:26:08,340 --> 00:26:11,520
于是他们找来了数字设备公司的戴夫·卡特勒

650
00:26:11,520 --> 00:26:17,419
他曾为他们开发过操作系统，包括 VMS 和 RSX-11。

651
00:26:17,419 --> 00:26:24,199
我记得是在 Prism 和 Mica 这两个 DEC 西部的项目被取消后，他就过来了

652
00:26:24,199 --> 00:26:28,119
所以当时有一整个团队的人，他们的项目都被取消了

653
00:26:28,119 --> 00:26:30,520
基本上他们中的一大群人后来都加入了微软

654
00:26:30,520 --> 00:26:31,899
具体交易细节我并不清楚

655
00:26:31,899 --> 00:26:33,260
但他们全都出现了。

656
00:26:33,260 --> 00:26:36,699
于是你有了戴夫·卡特勒、马克·卢科夫斯基这些来自 DEC 的顶尖高手

657
00:26:36,699 --> 00:26:41,959
他们基本上是从零开始，但也以 OS/2 作为起点

658
00:26:41,959 --> 00:26:46,580
不过 OS/2 是用汇编语言写的，而 NT 将用 C 语言编写

659
00:26:46,580 --> 00:26:49,780
他们能在多大程度上利用其中任何一点

660
00:26:49,780 --> 00:26:53,139
我实际上并不清楚,但至少他们已经有了一个可以起步的系统。

661
00:26:53,139 --> 00:26:55,260
你说过戴夫·卡特勒(Dave Cutler)是那个人

662
00:26:55,260 --> 00:26:58,139
Windows 背后的智囊。

663
00:26:58,139 --> 00:26:59,800
呃，你能解释一下吗？

664
00:26:59,800 --> 00:27:02,080
Dave Cutler 是内核架构的设计师。

665
00:27:02,080 --> 00:27:04,879
相当于 Linux 领域的 Linus。

666
00:27:04,879 --> 00:27:05,580
就是 Dave C。

667
00:27:05,580 --> 00:27:06,560
在 Windows 的世界里。

668
00:27:06,560 --> 00:27:07,179
戴夫·C.

669
00:27:07,179 --> 00:27:07,399
好的。

670
00:27:07,399 --> 00:27:09,500
而且，呃，并不是说没有其他人做出贡献

671
00:27:09,500 --> 00:27:10,830
当然，其中很大一部分功劳也属于他们。

672
00:27:10,830 --> 00:27:15,159
但是，呃，我认为他是背后的推动力，而且一直以来都是如此。

673
00:27:15,159 --> 00:27:16,212
他现在依然是。

674
00:27:16,212 --> 00:27:16,290
..

675
00:27:16,290 --> 00:27:17,500
我想他现在 85 岁了。

676
00:27:17,500 --> 00:27:18,419
他仍然每天写代码。

677
00:27:18,419 --> 00:27:19,280
他是微软院士。

678
00:27:19,280 --> 00:27:20,860
据我所知，他至今仍坚持上班工作

679
00:27:20,860 --> 00:27:21,407
所以...

680
00:27:21,407 --> 00:27:21,719
..

681
00:27:21,719 --> 00:27:24,439
呃，你能说说这家伙的天才之处吗？

682
00:27:24,439 --> 00:27:27,219
比如，他的思维方式有什么特别有趣的地方

683
00:27:27,219 --> 00:27:30,399
与他共事过，与戴夫·卡特勒打过交道吗？

684
00:27:30,399 --> 00:27:33,439
这家伙聪明绝顶，但也像个农民一样务实。

685
00:27:33,439 --> 00:27:42,239
他会像监工一样盯着你，确保事情不仅完成还要做对，绝不允许任何垃圾代码混进他的操作系统。

686
00:27:42,239 --> 00:27:42,360
嗯哼。

687
00:27:42,360 --> 00:27:43,429
他对此零容忍。

688
00:27:43,429 --> 00:27:45,959
在这方面，他可是个不折不扣的严师

689
00:27:45,959 --> 00:27:54,899
但我认为这非常值得，因为这让微软开发人员经历了巨大的范式转变，体验了戴夫·卡特勒带来的数字设备公司式领导风格。

690
00:27:54,899 --> 00:27:59,280
那么，你从中领悟到了什么关于

691
00:27:59,280 --> 00:28:05,780
大型协作软件开发团队的成功之道呢？

692
00:28:05,780 --> 00:28:08,760
因为微软当时拥有许多杰出的工程师

693
00:28:08,760 --> 00:28:10,040
正如你所说，比如戴夫·卡特勒

694
00:28:10,040 --> 00:28:15,159
他们不得不，呃，他们必须创建全新的系统

695
00:28:15,159 --> 00:28:17,310
其中许多系统我们至今仍在使用

696
00:28:17,310 --> 00:28:21,719
从那段经历中，你对优秀的软件工程团队有哪些领悟？

697
00:28:21,719 --> 00:28:23,629
首先我认为工具决定一切

698
00:28:23,629 --> 00:28:25,739
人当然是最重要的——这个我们视为理所当然

699
00:28:25,739 --> 00:28:28,620
但工具集确实是关键因素

700
00:28:28,620 --> 00:28:31,379
如果我们当时能继续并获取，事情就会容易得多。

701
00:28:31,379 --> 00:28:33,840
我们当时用的是 Diff，你知道

702
00:28:33,840 --> 00:28:35,219
手动差异对比——嗯。

703
00:28:35,219 --> 00:28:35,230
.

704
00:28:35,230 --> 00:28:35,230
..

705
00:28:35,230 --> 00:28:40,909
来进行支持和维护之类的工作，所以能够分叉一个源代码分支对我来说是一种前所未有的奢侈体验。

706
00:28:40,909 --> 00:28:44,169
所以那时候，这功能会非常实用。

707
00:28:44,169 --> 00:28:49,500
你走过去隔壁时，有哪些难忘的对话？

708
00:28:49,500 --> 00:28:50,389
呃，就是和其中一些人聊了聊。

709
00:28:50,389 --> 00:28:50,389
.

710
00:28:50,389 --> 00:28:50,389
.

711
00:28:50,389 --> 00:28:53,100
我不在场时，有人在抱怨

712
00:28:53,100 --> 00:28:57,739
团队来了一位新人，正在开发一个我记得叫 Cairo 的项目。

713
00:28:57,739 --> 00:29:00,100
Cairo 本将成为下一代操作系统

714
00:29:00,100 --> 00:29:04,340
它将会非常精美，拥有比 Windows 95 更先进的全新用户界面

715
00:29:04,340 --> 00:29:05,480
但最终未能实现。

716
00:29:05,480 --> 00:29:11,439
但在他们开发过程中，有个参与 Cairo 项目的家伙在 NT 开发公开邮件列表上大放厥词

717
00:29:11,439 --> 00:29:16,179
（那可是有几千人订阅的列表），说 NT 系统的启动体验简直烂透了

718
00:29:16,179 --> 00:29:18,840
而收到的回复是

719
00:29:18,840 --> 00:29:20,800
呃...一场史诗级的骂战，真希望我当时保存了那些邮件

720
00:29:20,800 --> 00:29:22,060
我就不点名是谁写的了。

721
00:29:22,060 --> 00:29:24,902
他心里有数，不过嘛...

722
00:29:24,902 --> 00:29:24,909
..

723
00:29:24,909 --> 00:29:27,520
那封愤怒的邮件堪称艺术杰作

724
00:29:27,520 --> 00:29:30,699
就像偶尔能看到 Linus 发的那些关于内核事务的咆哮邮件一样

725
00:29:30,699 --> 00:29:32,699
所以情绪非常相似。

726
00:29:32,699 --> 00:29:35,379
当时有没有那种，比如，知识分子的辩论

727
00:29:35,379 --> 00:29:35,649
类似——哦，确实有。

728
00:29:35,649 --> 00:29:35,649
.

729
00:29:35,649 --> 00:29:35,649
.

730
00:29:35,649 --> 00:29:38,639
工程师之间有过一些激烈的争论？

731
00:29:38,639 --> 00:29:38,649
是的。

732
00:29:38,649 --> 00:29:38,649
..

733
00:29:38,649 --> 00:29:40,020
是的，争论变得激烈起来。

734
00:29:40,020 --> 00:29:48,780
所以你会看到才智之士相互较量，最终对某些人来说技术优势反而成了次要的，重点变成了要在辩论中胜过对方。

735
00:29:48,780 --> 00:29:51,050
而且往往发展到这个阶段时，争论就已经失去建设性了

736
00:29:51,050 --> 00:29:53,259
但这种情况确实屡见不鲜。

737
00:29:53,259 --> 00:29:55,829
是的，我见过这类争论

738
00:29:55,829 --> 00:30:01,300
比如在编程语言设计社区里，像吉多·范罗苏姆

739
00:30:01,300 --> 00:30:05,206
这些社区的领导者们，会被搞得精疲力尽，因为人们总是...

740
00:30:05,206 --> 00:30:05,590
..

741
00:30:05,590 --> 00:30:12,379
你几乎会忘记自己的使命，开始对细节吹毛求疵。

742
00:30:12,379 --> 00:30:18,219
我是说，工程师们聚在一起，就会为最愚蠢的

743
00:30:18,219 --> 00:30:20,199
比如语法上的细微差别

744
00:30:20,199 --> 00:30:20,520
没错。

745
00:30:20,520 --> 00:30:20,758
好吧，这...

746
00:30:20,758 --> 00:30:20,790
..

747
00:30:20,790 --> 00:30:23,732
我不该说愚蠢，但确实是很小的...

748
00:30:23,732 --> 00:30:23,982
..

749
00:30:23,982 --> 00:30:25,532
语法精妙之处。

750
00:30:25,532 --> 00:30:26,972
现在来说，这是针对编程语言的。

751
00:30:26,972 --> 00:30:32,732
我确信在特定内核组件上存在内部争论。

752
00:30:32,732 --> 00:30:35,232
是啊，有个我输掉的争论至今还让我耿耿于怀。

753
00:30:35,232 --> 00:30:35,912
我认为。

754
00:30:35,912 --> 00:30:36,292
是吗？

755
00:30:36,292 --> 00:30:38,242
还有，呃...

756
00:30:38,242 --> 00:30:38,242
..

757
00:30:38,242 --> 00:30:39,052
因为我还是觉得——那是什么？

758
00:30:39,052 --> 00:30:39,075
.

759
00:30:39,075 --> 00:30:39,081
..

760
00:30:39,081 --> 00:30:40,732
我当时——嗯，就是我们在做外壳的时候

761
00:30:40,732 --> 00:30:42,412
我们当时正将所有内容从 ANSI 编码转换为 Unicode 编码

762
00:30:42,412 --> 00:30:45,732
因此每个原本 8 位的字符现在变成了 16 位

763
00:30:45,732 --> 00:30:49,292
现在的问题是，我正在 MIPS 架构机器上工作，因为我要将其移植到 RISC 平台

764
00:30:49,292 --> 00:30:52,922
而你不能使用未对齐的地址，但如果你处理两个 ID 列表

765
00:30:52,922 --> 00:30:56,131
即路径组件，取 C 盘反斜杠的那个部分

766
00:30:56,131 --> 00:30:58,672
取 Windows 目录的部分，再取 System32 的部分

767
00:30:58,672 --> 00:31:01,912
然后将它们拼接起来，但如果字符数是奇数

768
00:31:01,912 --> 00:31:03,672
此时在这个结构中就处于奇数地址位置

769
00:31:03,672 --> 00:31:07,452
这需要我付出巨大的工作量来开启异常处理程序

770
00:31:07,452 --> 00:31:11,611
进行非对齐字节访问以提取字符串并手动复制

771
00:31:11,611 --> 00:31:20,172
这简直需要，毫不夸张地说，在 R-MIPS 机器上从这个 ID 列表中读取字符串的工作量是正常情况的百倍到千倍，因为它没有对齐。

772
00:31:20,172 --> 00:31:22,742
所以我正在争论，尽管 Windows 95 的开发已进入后期阶段

773
00:31:22,742 --> 00:31:31,802
他们已经发布了一个测试版，我们现在应该确保 ID 列表始终是偶数个字节，或者采取某种变通方法确保这种情况永远不会发生，这样引用它们的代码

774
00:31:31,802 --> 00:31:33,752
在其他繁重的工作上，就可以快速推进了。

775
00:31:33,752 --> 00:31:37,292
结果演变成了一场争吵，甚至有点私人恩怨

776
00:31:37,292 --> 00:31:38,812
那次我输了。

777
00:31:38,812 --> 00:31:41,101
时至今日，我依然认为

778
00:31:41,101 --> 00:31:44,562
那些在 Windows 上运行的代码比它应有的速度慢了成千上万倍

779
00:31:44,562 --> 00:31:46,732
只是没人关心这个，毕竟它已经够快了

780
00:31:46,732 --> 00:31:47,192
不过...确实如此。

781
00:31:47,192 --> 00:31:47,202
.

782
00:31:47,202 --> 00:31:47,202
..

783
00:31:47,202 --> 00:31:49,052
可能会快很多。

784
00:31:49,052 --> 00:31:49,692
是的。

785
00:31:49,692 --> 00:31:52,251
所以，呃，是的，我是说，你提到了 MIPS 和 RISC。

786
00:31:52,251 --> 00:31:57,172
你需要对底层有多深入的理解

787
00:31:57,172 --> 00:32:02,902
对于你正在构建的东西，需要理解软件甚至硬件的最底层？

788
00:32:02,902 --> 00:32:12,331
要理解 NT 系统以及之前 MS-DOS 系统运作的所有抽象层次才能成功，这具体是指哪些层面呢？

789
00:32:12,331 --> 00:32:14,492
嗯，你大概有一半的时间都得花在调试上

790
00:32:14,492 --> 00:32:20,951
而且大部分调试时间都得泡在纯汇编语言的调用堆栈里，因为那时候根本没有源代码级调试

791
00:32:20,951 --> 00:32:21,371
嗯哼。

792
00:32:21,371 --> 00:32:25,572
完全不像现在用 Visual Studio 那样——碰到断点就自动弹出源代码窗口

793
00:32:25,572 --> 00:32:26,692
你可以查看源代码

794
00:32:26,692 --> 00:32:29,292
但你始终看到的是机器输出的原始汇编转储。

795
00:32:29,292 --> 00:32:33,232
所以即使你用 C 语言编程，调试时也要看汇编？

796
00:32:33,232 --> 00:32:34,552
是的，百分之百。

797
00:32:34,552 --> 00:32:35,732
哎呀，老兄。

798
00:32:35,732 --> 00:32:36,591
这确实有点麻烦。

799
00:32:36,591 --> 00:32:37,632
哦。

800
00:32:37,632 --> 00:32:41,312
更棒的是，我们正在处理四种指令集架构，因为我们要兼容英特尔

801
00:32:41,312 --> 00:32:45,192
呃，MIPS、Alpha 和 PowerPC，具体要看它在哪台机器上崩溃

802
00:32:45,192 --> 00:32:46,922
你掌握了完全不同的指令集——没错。

803
00:32:46,922 --> 00:32:46,955
.

804
00:32:46,955 --> 00:32:47,022
..

805
00:32:47,022 --> 00:32:47,938
还有寄存器等等。

806
00:32:47,938 --> 00:32:48,141
..

807
00:32:48,141 --> 00:32:50,532
因此你对调试所有四种架构都相当熟练

808
00:32:50,532 --> 00:32:52,861
不过，呃，我在 MIPS 架构上经验更丰富

809
00:32:52,861 --> 00:32:54,532
所以 MIPS 相关的工作会找上我。

810
00:32:54,532 --> 00:32:55,952
那真是场耐力考验。

811
00:32:55,952 --> 00:32:57,052
我是说，你能谈谈那个吗

812
00:32:57,052 --> 00:33:01,712
那种调试的折磨，特别是没有调试工具时的调试

813
00:33:01,712 --> 00:33:03,351
没有配套工具怎么行？

814
00:33:03,351 --> 00:33:05,488
我是说，这其实就是编程的本质。

815
00:33:05,488 --> 00:33:05,621
..

816
00:33:05,621 --> 00:33:07,904
现在的年轻人啊。

817
00:33:07,904 --> 00:33:08,182
..

818
00:33:08,182 --> 00:33:12,130
呃，编程并不全是为了创造美好的事物

819
00:33:12,130 --> 00:33:12,952
对吧？

820
00:33:12,952 --> 00:33:18,512
这，呃，也跟解决问题有关。

821
00:33:18,512 --> 00:33:23,712
是啊，我可以说职业生涯中 20%的时间在创造，80%都在调试和修复问题。

822
00:33:23,712 --> 00:33:24,391
是的。

823
00:33:24,391 --> 00:33:26,831
而且，我算是因此有了个能解决问题的名声

824
00:33:26,831 --> 00:33:28,132
所以这类事情总会找上我

825
00:33:28,132 --> 00:33:29,552
因此我会花更多时间去做这件事。

826
00:33:29,552 --> 00:33:34,232
我并非那种以创意 UI 设计闻名的天才，能不断涌现各种新点子

827
00:33:34,232 --> 00:33:37,331
所以我专注于修复那些不够美观的设计，但在这方面我确实变得非常擅长

828
00:33:37,331 --> 00:33:48,341
我并不介意这种工作，除非遇到那种情况——你花了太长时间去解决某个问题，却不知下一步该怎么做，既搞不懂为什么它不工作，也不明白它之前是怎么正常运行的，或者无论你碰巧处于哪种困境中

829
00:33:48,341 --> 00:33:51,161
而且，你知道，经过一整天这样的工作后

830
00:33:51,161 --> 00:33:52,841
这可能会相当折磨人。

831
00:33:52,841 --> 00:33:55,932
是啊，调试代码简直是种酷刑。

832
00:33:55,932 --> 00:33:57,262
这真的可能非常、非常困难。

833
00:33:57,262 --> 00:33:59,641
我觉得这里面还有心理层面的因素

834
00:33:59,641 --> 00:34:00,871
坚持不懈的成果。

835
00:34:00,871 --> 00:34:02,202
我觉得那些——你知道的

836
00:34:02,202 --> 00:34:04,472
花你一天时间的问题，最终会以两种方式之一解决。

837
00:34:04,472 --> 00:34:08,072
要么是像"哦，多了个分号"这样，然后你终于发现了——是的。

838
00:34:08,072 --> 00:34:08,081
.

839
00:34:08,081 --> 00:34:08,081
..

840
00:34:08,081 --> 00:34:13,411
或者这是跨线程单元公寓机制导致的可怕问题，确实很难搞

841
00:34:13,411 --> 00:34:15,152
但这问题可能双向出现。

842
00:34:15,152 --> 00:34:17,572
呃，我遇到过一个 bug，其实不是我的问题

843
00:34:17,572 --> 00:34:21,252
而是任务管理器本身的 bug 偶尔会显现出来

844
00:34:21,252 --> 00:34:24,513
它会显示"CPU 总使用率超过 100%"。

845
00:34:24,513 --> 00:34:26,511
这在任务管理器中看起来相当荒谬

846
00:34:26,511 --> 00:34:29,911
所以我花了很长时间试图解决这个问题

847
00:34:29,911 --> 00:34:33,351
我曾向内核开发人员反映过这个问题，但他们并不以为然

848
00:34:33,351 --> 00:34:38,172
比方说，内核开发者们都是特殊的一群人，他们对我的用户态问题不感兴趣。

849
00:34:38,172 --> 00:34:40,371
我的代码里可能确实有问题，对吧？

850
00:34:40,371 --> 00:34:42,871
他们可能说得对，但这次情况并非如此

851
00:34:42,871 --> 00:34:48,451
我对此非常确定，于是我在代码中不断添加断言来确保

852
00:34:48,451 --> 00:34:54,112
将材料相加的预备步骤从未超过 100，且最终总和也从未超过 100

853
00:34:54,112 --> 00:34:57,412
而最终，它从未触发断言

854
00:34:57,412 --> 00:35:00,392
但偶尔我们会遇到这个 bug，人们仍然能看到它

855
00:35:00,392 --> 00:35:03,132
于是我在断言里加上了我的电话号码

856
00:35:03,132 --> 00:35:05,092
我当时就想，"如果你看到这条消息

857
00:35:05,092 --> 00:35:08,647
就给戴夫打电话，号码是 425-836-我的电话号码。

858
00:35:08,647 --> 00:35:11,362
" 呃，最后我们确实——

859
00:35:11,362 --> 00:35:11,362
..

860
00:35:11,362 --> 00:35:16,282
在我之前提到的实际压力调试器中捕捉到了这个情况，当时恰好有人连接着调试器遇到了这个问题。

861
00:35:16,282 --> 00:35:20,241
我们最终查明这实际上是一个内核记账问题，而非任务管理器的问题

862
00:35:20,241 --> 00:35:24,912
所以在我证明这确实是内核问题后，他们就在内核中修复了它

863
00:35:24,912 --> 00:35:27,272
而且，呃，你可能会认为我们会删除我的电话号码

864
00:35:27,272 --> 00:35:31,208
但我们只是把它注释掉了，所以它被发布出去，并出现在所有泄露的 NT 源代码中

865
00:35:31,208 --> 00:35:31,221
..

866
00:35:31,221 --> 00:35:32,442
这真是太棒了。

867
00:35:32,442 --> 00:35:32,442
.

868
00:35:32,442 --> 00:35:32,442
.

869
00:35:32,442 --> 00:35:37,922
我是这样找到任务管理器代码的：在谷歌搜索我的电话号码，它会反向查找——哦

870
00:35:37,922 --> 00:35:38,112
这太有趣了。

871
00:35:38,112 --> 00:35:38,122
.

872
00:35:38,122 --> 00:35:38,122
..

873
00:35:38,122 --> 00:35:39,192
NT 源代码。

874
00:35:39,192 --> 00:35:40,452
你能谈谈关于断言（assert）的事情吗？

875
00:35:40,452 --> 00:35:45,782
顺便说一句，我记得你在推特或其他地方说过，如果你想非常认真地对待你的断言

876
00:35:45,782 --> 00:35:47,511
你会把自己的家庭电话号码

877
00:35:47,511 --> 00:35:48,592
嗯，加在里面。

878
00:35:48,592 --> 00:35:48,702
是的。

879
00:35:48,702 --> 00:35:49,132
确实如此。

880
00:35:49,132 --> 00:35:49,261
确实如此。

881
00:35:49,261 --> 00:35:51,452
有点开玩笑的意思，因为这可能不是最明智的做法

882
00:35:51,452 --> 00:35:51,782
但——不，确实不是。

883
00:35:51,782 --> 00:35:51,782
.

884
00:35:51,782 --> 00:35:51,782
.

885
00:35:51,782 --> 00:35:52,971
你会发现

886
00:35:52,971 --> 00:35:58,572
但我的意思是，assert 本身就已经是件严肃的事情，因为它会完全停止所有执行。

887
00:35:58,572 --> 00:36:00,192
这就是我为什么如此

888
00:36:00,192 --> 00:36:07,432
如此喜爱 assert 的原因 - 它们会终止一切，迫使你解决问题。

889
00:36:07,432 --> 00:36:09,301
是啊，我对断言也有点执着。

890
00:36:09,301 --> 00:36:11,232
我不会对那些我希望不成立的事情做断言。

891
00:36:11,232 --> 00:36:14,102
我只对那些明知不可能成立的事情做断言。

892
00:36:14,102 --> 00:36:16,152
我认为这才是断言的真正本意

893
00:36:16,152 --> 00:36:18,741
所以我虽然是在强调显而易见的事实，但当这种情况发生时

894
00:36:18,741 --> 00:36:19,962
这就是个 bug，简单明了。

895
00:36:19,962 --> 00:36:21,912
这不是警告。

896
00:36:21,912 --> 00:36:30,313
有趣的是，它经常能帮你找出问题所在，因为如果你到处都加上断言——

897
00:36:30,313 --> 00:36:30,490
..

898
00:36:30,490 --> 00:36:34,020
你能很快找到问题的根源。

899
00:36:34,020 --> 00:36:37,840
是的，我倾向于...这不是我想建议你回头再补充的内容。

900
00:36:37,840 --> 00:36:40,390
这是你在编写代码时应该反复做的事情。

901
00:36:40,390 --> 00:36:40,740
在构建过程中就要这样做。

902
00:36:40,740 --> 00:36:43,020
因此对于每个函数，如果你有前提假设

903
00:36:43,020 --> 00:36:44,960
比如我知道这个指针永远不会是空值

904
00:36:44,960 --> 00:36:45,790
好的，我们会插入这个断言

905
00:36:45,790 --> 00:36:48,880
如果你知道这个计数总是小于两倍的字节宽度

906
00:36:48,880 --> 00:36:49,879
断言这一点。

907
00:36:49,879 --> 00:36:51,760
别害怕，因为如果它断言了

908
00:36:51,760 --> 00:36:53,340
它其实是在帮你。

909
00:36:53,340 --> 00:36:54,310
我觉得有些人会害怕，你知道

910
00:36:54,310 --> 00:36:58,480
就像你驶出十字路口时，可能觉得会有来车却没看左边那样。

911
00:36:58,480 --> 00:36:58,680
是的。

912
00:36:58,680 --> 00:36:59,650
或许我不会那么做。

913
00:36:59,650 --> 00:37:02,080
但，呃，情况就是那样。

914
00:37:02,080 --> 00:37:04,369
人们不敢坚持己见，是怕会被解雇。

915
00:37:04,369 --> 00:37:06,000
嗯，不，你想知道吧。

916
00:37:06,000 --> 00:37:08,160
你提到了任务管理器。

917
00:37:08,160 --> 00:37:10,640
显然，我们得聊聊这个

918
00:37:10,640 --> 00:37:14,340
你开发的传奇程序——Windows 任务管理器。

919
00:37:14,340 --> 00:37:16,480
告诉我你构建它的每一个细节。

920
00:37:16,480 --> 00:37:18,260
什么是 Windows 任务管理器？

921
00:37:18,260 --> 00:37:23,360
所以 Windows 任务管理器是一种可以查看系统中哪些应用程序正在使用计算机资源的方式

922
00:37:23,360 --> 00:37:25,740
包括硬件资源、CPU 使用情况和内存占用

923
00:37:25,740 --> 00:37:30,040
哪些进程可能占用过多资源、被锁定或出现异常

924
00:37:30,040 --> 00:37:32,120
并允许你终止这些进程。

925
00:37:32,120 --> 00:37:34,519
因此它既是检查工具也是修复工具。

926
00:37:34,519 --> 00:37:36,380
是的，它会列出所有进程。

927
00:37:36,380 --> 00:37:38,100
我是说，这简直就是个传奇级的软件。

928
00:37:38,100 --> 00:37:38,770
这太疯狂了。

929
00:37:38,770 --> 00:37:40,740
我们啊，你就觉得这是理所当然的。

930
00:37:40,740 --> 00:37:42,490
就像开始菜单那样，对吧？

931
00:37:42,490 --> 00:37:42,670
是的。

932
00:37:42,670 --> 00:37:44,300
这简直，太天才了。

933
00:37:44,300 --> 00:37:47,550
很幸运，我参与开发过许多大家耳熟能详的项目

934
00:37:47,550 --> 00:37:52,840
而任务管理器正是这些个人兴趣项目之一，最初只是为满足自己的需求而开发

935
00:37:52,840 --> 00:37:54,270
最终被公司采纳为正式产品

936
00:37:54,270 --> 00:37:58,490
于是我开始在家编写代码，逐步实现了基础功能框架

937
00:37:58,490 --> 00:38:06,260
我当时使用的是注册表中的 HKey Current Perform 或 HKey Performance 来获取统计数据，因为在家办公时无法访问内部 API

938
00:38:06,260 --> 00:38:07,880
而且我不会因为在家办公就调用这些

939
00:38:07,880 --> 00:38:08,620
嗯哼。

940
00:38:08,620 --> 00:38:10,360
后来当我把它引入内部系统后

941
00:38:10,360 --> 00:38:17,790
就能直接调用 NtQuerySystemInformation 或 NtQueryProcessInformation 这类函数快速获取真实数据了

942
00:38:17,790 --> 00:38:20,480
这使得它能够成为一个非常快速且响应灵敏的应用程序。

943
00:38:20,480 --> 00:38:23,840
因此人们开始依赖它，因为我编写时就力求让它尽可能可靠。

944
00:38:23,840 --> 00:38:24,960
我并不担心功能的多寡。

945
00:38:24,960 --> 00:38:28,000
我只确保其中包含我想要的一套基本功能。

946
00:38:28,000 --> 00:38:31,940
我得到了想要的一切，但希望它能真正健壮可靠

947
00:38:31,940 --> 00:38:33,430
而且要小巧

948
00:38:33,430 --> 00:38:35,180
最初的版本大约有 87K 大小

949
00:38:35,180 --> 00:38:35,420
好的。

950
00:38:35,420 --> 00:38:40,380
你能谈谈开发这样一款不会卡死的软件需要哪些关键要素吗？

951
00:38:40,380 --> 00:38:42,210
呃，你不会做太多假设吧？

952
00:38:42,210 --> 00:38:44,980
如果你打算通过 shell 调用来运行应用

953
00:38:44,980 --> 00:38:49,720
那可能是个基于 TCP/IP 共享的网络路径，需要 90 秒才会超时

954
00:38:49,720 --> 00:38:53,500
所以每当你执行这类可能耗时的 AP-API 调用时

955
00:38:53,500 --> 00:38:55,640
你最终会需要在单独的线程上完成这个操作。

956
00:38:55,640 --> 00:38:58,860
因此应用程序会变得稍微复杂一些，因为所有操作都是多线程的。

957
00:38:58,860 --> 00:39:01,520
好的，那么你当时用的是哪种编程语言？

958
00:39:01,520 --> 00:39:02,480
C++。

959
00:39:02,480 --> 00:39:04,720
那么这是针对 Windows N-NT 的吗？

960
00:39:04,720 --> 00:39:05,300
是的。

961
00:39:05,300 --> 00:39:05,970
好的。

962
00:39:05,970 --> 00:39:07,620
那么它最初是在 NT 4 中发布的。

963
00:39:07,620 --> 00:39:07,900
0.

964
00:39:07,900 --> 00:39:08,300
好的。

965
00:39:08,300 --> 00:39:10,980
那么这个程序有哪些有趣的细节呢？

966
00:39:10,980 --> 00:39:12,780
因为你必须让它尽可能简单

967
00:39:12,780 --> 00:39:16,720
同时还要尽可能保持稳健。

968
00:39:16,720 --> 00:39:18,860
呃，有哪些有趣的优化方案，比如

969
00:39:18,860 --> 00:39:20,080
你不得不实施的？

970
00:39:20,080 --> 00:39:22,210
有几个现在看起来有点硬核的东西我...

971
00:39:22,210 --> 00:39:23,049
我居然做到了。

972
00:39:23,049 --> 00:39:25,360
我根本不想链接到 C 运行时库

973
00:39:25,360 --> 00:39:27,750
所以我确保绝不调用任何运行时函数

974
00:39:27,750 --> 00:39:30,800
也没有链接它们，这让我省去了 C 运行时库的开销

975
00:39:30,800 --> 00:39:35,690
96K 左右，所以你知道，只要调用任何 C 函数，应用体积几乎就会翻倍。

976
00:39:35,690 --> 00:39:36,940
因此我小心翼翼地避免这样做

977
00:39:36,940 --> 00:39:39,680
但实际上我是在用 C++编写

978
00:39:39,680 --> 00:39:42,260
它更像是带对象的 C 语言。

979
00:39:42,260 --> 00:39:45,280
但是，呃，为了让它能运行起来

980
00:39:45,280 --> 00:39:50,820
我不得不手动从调度表里剔除所有对象构造函数之类的，因为没有运行时环境帮你处理这些。

981
00:39:50,820 --> 00:39:53,380
所以你用的这个编译器是没有自带运行时的

982
00:39:53,380 --> 00:39:55,320
不过我不想在技术细节上钻牛角尖

983
00:39:55,320 --> 00:39:58,010
但这需要大量额外工作才能让它运行起来

984
00:39:58,010 --> 00:40:00,080
但当你做到时，它的类型会变得非常小

985
00:40:00,080 --> 00:40:02,460
大概就是这个大小——是的

986
00:40:02,460 --> 00:40:02,470
.

987
00:40:02,470 --> 00:40:02,470
..

988
00:40:02,470 --> 00:40:03,600
程序的大小

989
00:40:03,600 --> 00:40:06,540
呃，追踪每个进程及其 CPU 占用率有哪些有趣的地方呢？

990
00:40:06,540 --> 00:40:10,310
比如，每个、每个进程以及该进程占用了多少 CPU？

991
00:40:10,310 --> 00:40:12,680
我见过最酷的事情之一是

992
00:40:12,680 --> 00:40:14,400
虽然我不想说汉明码是我发明的

993
00:40:14,400 --> 00:40:17,860
但我其实是在不知道汉明码存在的情况下，自己琢磨出了类似汉明码的东西

994
00:40:17,860 --> 00:40:22,740
所以任务管理器里的每一列和每一行都有一个标记位来表示是否变脏

995
00:40:22,740 --> 00:40:28,340
然后我可以用和汉明码检查 X/Y 列相同的方式，找出哪些行发生了变化

996
00:40:28,340 --> 00:40:31,360
遍历并确定哪些部分真正需要重绘

997
00:40:31,360 --> 00:40:35,660
因此，任务管理器效率极高，它与 ListView 控件协同工作

998
00:40:35,660 --> 00:40:42,820
该控件能够实现逐帧遍历并仅重绘发生变化的单个单元格的功能。

999
00:40:42,820 --> 00:40:46,080
这使得绘制速度极快，调整尺寸时也能保持流畅

1000
00:40:46,080 --> 00:40:49,580
而尺寸调整可能是我最大的...呃

1001
00:40:49,580 --> 00:40:51,299
使用该应用的个人目标。

1002
00:40:51,299 --> 00:40:53,920
因此你可以调整到任意尺寸，它依然能正常工作

1003
00:40:53,920 --> 00:40:59,610
即便你有 32 个 CPU（这在当时是不可能的）

1004
00:40:59,610 --> 00:41:01,920
它只会绘制，我认为，八个图表然后就会自动换行

1005
00:41:01,920 --> 00:41:05,300
但是，呃，它至今仍能正常工作，所以我对此还挺自豪的。

1006
00:41:05,300 --> 00:41:13,340
这太不可思议了，嗯，你有机会亲眼见证了任务管理器的演变历程。

1007
00:41:13,340 --> 00:41:16,420
从某些方面来说，它其实变化并不大。

1008
00:41:16,420 --> 00:41:21,460
或许只是界面变得更美观了些，以适应不同版本的 Windows 系统。

1009
00:41:21,460 --> 00:41:23,220
但这基本上是一样的东西。

1010
00:41:23,220 --> 00:41:28,640
功能上非常相似，呃，报告更多是因为他们添加了 GPU 和散热之类的东西

1011
00:41:28,640 --> 00:41:30,000
这些确实是很不错的功能。

1012
00:41:30,000 --> 00:41:31,460
而我们那时候还没有这些功能

1013
00:41:31,460 --> 00:41:32,080
所以...

1014
00:41:32,080 --> 00:41:33,180
我是说，你能说些什么，你知道吗

1015
00:41:33,180 --> 00:41:37,680
比如，有没有进行过重构，还是基本上还是原来的代码？

1016
00:41:37,680 --> 00:41:38,780
呃，据我所知

1017
00:41:38,780 --> 00:41:44,700
原始代码大部分都还在那里，所以有绘图代码层、暗黑模式代码层以及其他各种代码层

1018
00:41:44,700 --> 00:41:49,640
XML 模式代码，这使得文件大小从 87K 膨胀到了 4MB

1019
00:41:49,640 --> 00:41:51,700
但这就是我们生活的世界，没办法。

1020
00:41:51,700 --> 00:41:54,592
是啊，这就是那种你开发完就直接搁那儿的软件。

1021
00:41:54,592 --> 00:41:54,650
..

1022
00:41:54,650 --> 00:41:57,520
一旦安装就固定在那里，简直就像开始菜单一样

1023
00:41:57,520 --> 00:41:59,300
那我敢肯定如果你去掉它

1024
00:41:59,300 --> 00:42:02,360
人们会发疯的。

1025
00:42:02,360 --> 00:42:04,800
是啊，这个可能会被锁定一段时间。

1026
00:42:04,800 --> 00:42:04,810
是的。

1027
00:42:04,810 --> 00:42:06,100
或许还不错。

1028
00:42:06,100 --> 00:42:08,280
是的，我原以为 Clippy 也会如此

1029
00:42:08,280 --> 00:42:12,540
不过，呃，Clippy 总有一天会卷土重来的

1030
00:42:12,540 --> 00:42:14,370
好吧，那么，当时

1031
00:42:14,370 --> 00:42:18,980
你还创造了哪些堪称传奇的软件呢？

1032
00:42:18,980 --> 00:42:21,280
所以你参与了《太空军校生三维弹球》的开发

1033
00:42:21,280 --> 00:42:22,360
至少负责移植工作

1034
00:42:22,360 --> 00:42:22,590
是的。

1035
00:42:22,590 --> 00:42:24,490
于是他们来到我的办公室说

1036
00:42:24,490 --> 00:42:25,160
"嘿，你在忙什么呢？

1037
00:42:25,160 --> 00:42:26,190
我告诉他们我在做什么

1038
00:42:26,190 --> 00:42:28,472
他们说："那么，接下来三个月你想怎么安排？"

1039
00:42:28,472 --> 00:42:29,560
我回答："我还没想好"，他们接着问

1040
00:42:29,560 --> 00:42:30,596
"你想移植《Pinball》吗？"

1041
00:42:30,596 --> 00:42:30,735
"

1042
00:42:30,735 --> 00:42:30,874
..

1043
00:42:30,874 --> 00:42:36,263
我曾见过《太空军校生弹珠台》作为 Win95 平台的独立游戏

1044
00:42:36,263 --> 00:42:38,303
它有几个不同的弹球台，是个很酷的游戏

1045
00:42:38,303 --> 00:42:39,223
所以我当时还挺兴奋的

1046
00:42:39,223 --> 00:42:42,763
他们想要的是为 NT 系统制作一些视觉特效来展示 NT 系统的能力

1047
00:42:42,763 --> 00:42:48,144
那时需要高速图形处理，或者至少是响应迅速的图形。

1048
00:42:48,144 --> 00:42:51,093
于是我尝试了一下，但很不幸

1049
00:42:51,093 --> 00:42:52,203
大部分代码是用汇编语言写的

1050
00:42:52,203 --> 00:42:57,964
而我用的是 MIPS 架构，所以不得不先用 C 语言重写代码，这样才能移植到所有不同的平台上。

1051
00:42:57,964 --> 00:43:01,223
而游戏的核心是一个庞大的状态引擎。

1052
00:43:01,223 --> 00:43:03,424
它就像一个巨大的 switch 语句，

1053
00:43:03,424 --> 00:43:06,283
如果我没记错的话，里面大约有 50 个条目。

1054
00:43:06,283 --> 00:43:06,823
是的。

1055
00:43:06,823 --> 00:43:09,383
而且它还内置了一个彩蛋。

1056
00:43:09,383 --> 00:43:15,343
解码状态的过程，就像让神经网络处理不同状态输入一样

1057
00:43:15,343 --> 00:43:18,723
我只是把它放在一边，当作一个黑箱来处理。

1058
00:43:18,723 --> 00:43:22,524
因此我的代码在此基础上运行，负责绘图、音效等其他所有功能。

1059
00:43:22,524 --> 00:43:24,644
但原始游戏仍在运行中。

1060
00:43:24,644 --> 00:43:28,924
最近有人问我：“为什么会有细微差别

1061
00:43:28,924 --> 00:43:32,139
物理效果与 Windows 95 版本略有不同

1062
00:43:32,139 --> 00:43:35,113
但代码应该是相同的，因为我非常努力地想要保持原样

1063
00:43:35,113 --> 00:43:40,444
其实是因为我有个 bug，导致它会尽可能多地绘制每秒帧数

1064
00:43:40,444 --> 00:43:42,107
在现代计算机上可以达到 5

1065
00:43:42,107 --> 00:43:45,343
000 帧每秒的弹珠游戏性能，因为这是个相当基础的游戏。

1066
00:43:45,343 --> 00:43:47,619
因此所有物理效果都是以 5

1067
00:43:47,619 --> 00:43:50,183
000 次/秒而非 30 次/秒的频率进行插值计算

1068
00:43:50,183 --> 00:43:51,493
或者你在旧版本中能得到的任何东西。

1069
00:43:51,493 --> 00:43:54,323
所以你得到的可以说是更好的，或者至少是不同的物理效果。

1070
00:43:54,323 --> 00:43:57,025
但他们后来修复了这个问题，所以。

1071
00:43:57,025 --> 00:43:57,254
..

1072
00:43:57,254 --> 00:43:59,263
为-为什么这个游戏这么棒？

1073
00:43:59,263 --> 00:44:00,223
我认为这是个很棒的设计。

1074
00:44:00,223 --> 00:44:01,363
我的意思是，这并非我的功劳。

1075
00:44:01,363 --> 00:44:03,504
这完全归功于 Cinematronics 团队的那些人。

1076
00:44:03,504 --> 00:44:04,993
但原版游戏的设计确实非常出色。

1077
00:44:04,993 --> 00:44:09,484
这和我实际拥有的弹珠台实物《Black Knight 2000》非常相似

1078
00:44:09,484 --> 00:44:12,044
而且两者的布局也确实很相近。

1079
00:44:12,044 --> 00:44:14,104
我不确定它是否受到了前者的启发。

1080
00:44:14,104 --> 00:44:15,223
总之这是款不错的游戏。

1081
00:44:15,223 --> 00:44:16,263
是的。

1082
00:44:16,263 --> 00:44:24,714
有时我会想到像俄罗斯方块这样的游戏，那些图形相当原始却能让

1083
00:44:24,714 --> 00:44:28,223
呃，让大批人感到兴奋的游戏。

1084
00:44:28,223 --> 00:44:32,363
或许正是大批人的这种兴奋感造就了游戏的非凡魅力

1085
00:44:32,363 --> 00:44:35,743
所以当，呃，当许多人一起兴奋地讨论它时

1086
00:44:35,743 --> 00:44:38,064
那种会深深印在你脑海里的东西。

1087
00:44:38,064 --> 00:44:39,984
但那可是经典游戏之一。

1088
00:44:39,984 --> 00:44:42,863
我是说，就连——就连像纸牌和扫雷这样的游戏。

1089
00:44:42,863 --> 00:44:47,044
我的意思是，有一代人可是在扫雷上打过仗的。

1090
00:44:47,044 --> 00:44:47,403
对吧？

1091
00:44:47,403 --> 00:44:53,144
原来这些程序被内置在操作系统中并非作为游戏，而是作为教育工具来帮助你学习使用鼠标。

1092
00:44:53,144 --> 00:44:54,214
哦，有意思。

1093
00:44:54,214 --> 00:44:56,484
所以纸牌游戏是为了教你如何进行拖放操作。

1094
00:44:56,484 --> 00:44:57,203
是的。

1095
00:44:57,203 --> 00:44:58,884
而扫雷大概是为了练习右键点击。

1096
00:44:58,884 --> 00:45:00,653
我觉得你放了个对的东西，一个标志或某个物品。

1097
00:45:00,653 --> 00:45:00,863
是的。

1098
00:45:00,863 --> 00:45:03,593
我不是扫雷高手，但每个游戏都能教会你一些东西。

1099
00:45:03,593 --> 00:45:04,403
扫雷高手。

1100
00:45:04,403 --> 00:45:05,644
这挺有趣的。

1101
00:45:05,644 --> 00:45:06,944
是的。

1102
00:45:06,944 --> 00:45:08,044
哇，这个我还真不知道。

1103
00:45:08,044 --> 00:45:09,084
这挺有意思的。

1104
00:45:09,084 --> 00:45:10,124
而且确实如此。

1105
00:45:10,124 --> 00:45:12,843
但我不知道在这些游戏上花了多少个小时。

1106
00:45:12,843 --> 00:45:16,064
就像无数人花费了无数时间在这些游戏上

1107
00:45:16,064 --> 00:45:19,163
我曾经在孩子学校志愿教授计算机科学课程

1108
00:45:19,163 --> 00:45:21,064
就是给三年级小朋友上的那种课

1109
00:45:21,064 --> 00:45:22,903
其实更像是教他们登录操作而非真正的计算机科学

1110
00:45:22,903 --> 00:45:27,884
但是，呃，这些孩子的老爸们都在微软上班，所以你做什么他们都不会觉得厉害

1111
00:45:27,884 --> 00:45:30,343
不过有个孩子发现我参与过《弹珠台》开发后，他们的反应就变成了

1112
00:45:30,343 --> 00:45:31,878
"哇！你做过《弹珠台》？

1113
00:45:31,878 --> 00:45:33,424
"因为那时候所有孩子都知道这个游戏

1114
00:45:33,424 --> 00:45:35,683
现在这些孩子可能已经过了那个年纪，他们不知道这事了

1115
00:45:35,683 --> 00:45:38,237
但曾经有那么一小段时间。

1116
00:45:38,237 --> 00:45:38,573
..

1117
00:45:38,573 --> 00:45:42,183
呃，你卡在 Windows 激活那一步了。

1118
00:45:42,183 --> 00:45:44,763
你说得好像这是件坏事似的。

1119
00:45:44,763 --> 00:45:48,624
嗯，一切取决于你看问题的角度。

1120
00:45:48,624 --> 00:45:49,863
那就讲讲这个故事吧。

1121
00:45:49,863 --> 00:45:51,024
什么是 Windows 激活？

1122
00:45:51,024 --> 00:45:52,604
那个...你是怎么参与进来的？

1123
00:45:52,604 --> 00:45:55,683
所以他们是在 XP 开发后期才找到我的。

1124
00:45:55,683 --> 00:45:57,163
我，我不确定测试版是否已经发布

1125
00:45:57,163 --> 00:45:58,274
我认为测试版应该还没发布

1126
00:45:58,274 --> 00:46:05,524
但他们原本计划采用 Office 的激活码机制，然后将其适配到 Windows 系统中，为 Windows 添加激活功能。

1127
00:46:05,524 --> 00:46:09,453
但负责此事的人已经多次疏忽，导致这事不可能完成了

1128
00:46:09,453 --> 00:46:12,203
因此我有了个能快速解决问题的名声

1129
00:46:12,203 --> 00:46:15,126
所以他们来找我说："你能在 XP 发布前搞定这个吗？"

1130
00:46:15,126 --> 00:46:17,495
"我不确定，但我会尽力。"

1131
00:46:17,495 --> 00:46:24,524
于是在负责 DRM 的团队和研究产品密钥数学算法的团队协助下

1132
00:46:24,524 --> 00:46:26,624
我们赶在 XP 发布前及时完成了。

1133
00:46:26,624 --> 00:46:30,743
我不知道它对收入的实际影响有多大

1134
00:46:30,743 --> 00:46:35,124
但当你开始强制执行许可证密钥时，我想影响会相当大。

1135
00:46:35,124 --> 00:46:36,183
我很好奇那到底是什么。

1136
00:46:36,183 --> 00:46:36,584
我不知道。

1137
00:46:36,584 --> 00:46:39,263
因为这也很烦人。

1138
00:46:39,263 --> 00:46:41,013
确实如此，尤其是当你必须通过电话激活时。

1139
00:46:41,013 --> 00:46:43,484
而这正是我们不得不随身携带的

1140
00:46:43,484 --> 00:46:48,064
沉重负担，必须将数据上传到清算中心

1141
00:46:48,064 --> 00:46:50,703
将批准你密钥的后端系统

1142
00:46:50,703 --> 00:46:52,763
你必须提供所有硬件参数

1143
00:46:52,763 --> 00:46:56,093
比如内存大小、硬盘空间以及硬件密钥绑定的各种参数

1144
00:46:56,093 --> 00:47:03,403
还有产品密钥，并且需要将其编码成字母数字组合，以便有人愿意通过电话读取

1145
00:47:03,403 --> 00:47:06,064
如果你觉得通过电话进行产品激活很痛苦

1146
00:47:06,064 --> 00:47:09,484
你能想象在电话那头工作的人是什么感受吗？

1147
00:47:09,484 --> 00:47:14,013
我是说，每天听 8 小时产品密钥，这工作简直让人麻木。

1148
00:47:14,013 --> 00:47:16,153
是的，这是 Windows 面临的挑战之一

1149
00:47:16,153 --> 00:47:19,234
这对我来说一直是个令人沮丧的点

1150
00:47:19,234 --> 00:47:22,343
但我从设计角度能理解，这确实非常困难

1151
00:47:22,343 --> 00:47:27,564
因为有太多不同类型的人在使用 Windows。

1152
00:47:27,564 --> 00:47:35,644
但随着时间的推移，Windows 越来越倾向于那种...（令人不适的）方向，这实在令人沮丧

1153
00:47:35,644 --> 00:47:38,163
算不上高级用户，我应该说

1154
00:47:38,163 --> 00:47:41,683
这就是为什么 Linux 一直都很棒。

1155
00:47:41,683 --> 00:47:45,823
但从激活角度或任何配置方面来看

1156
00:47:45,823 --> 00:47:49,384
它确实，确实是个让人相当头疼的问题。

1157
00:47:49,384 --> 00:47:53,153
最近我比较受欢迎的一期节目是关于为什么不能移动 Windows 任务栏的。

1158
00:47:53,153 --> 00:47:54,384
是的。

1159
00:47:54,384 --> 00:47:57,234
我原本不知道，但人们对这件事的愤怒情绪是显而易见的——确实如此。

1160
00:47:57,234 --> 00:47:57,234
.

1161
00:47:57,234 --> 00:47:57,234
.

1162
00:47:57,234 --> 00:47:59,723
你只是想把它放在左侧或顶部，但现在却不行了

1163
00:47:59,723 --> 00:48:01,444
这对他们的存在简直是一种冒犯。

1164
00:48:01,444 --> 00:48:02,874
在一定程度上我能理解这一点。

1165
00:48:02,874 --> 00:48:08,194
嗯，这是让我非常不喜欢 Wi- 其实 Windows 11 有很多方面都让我不满意

1166
00:48:08,194 --> 00:48:12,863
其中之一就是你无法像以前那样自定义任务栏的位置

1167
00:48:12,863 --> 00:48:14,663
这些本该是最基本的自定义功能。

1168
00:48:14,663 --> 00:48:16,144
我们能直接配置这些吗？

1169
00:48:16,144 --> 00:48:26,064
因为只要给高级用户这个选项，就会有一小部分人超级喜欢这个操作系统

1170
00:48:26,064 --> 00:48:28,104
这对你没有任何损失，给他们这份自由就好

1171
00:48:28,104 --> 00:48:29,394
不过，这确实是有代价的，对吧？

1172
00:48:29,394 --> 00:48:34,421
因为，呃，把开始菜单放在左边、顶部或右边的自由...

1173
00:48:34,421 --> 00:48:34,747
..

1174
00:48:34,747 --> 00:48:39,747
确实增加了渲染开始菜单、布局标签页等功能的代码复杂度

1175
00:48:39,747 --> 00:48:42,457
现在出现 bug 的可能性大大增加

1176
00:48:42,457 --> 00:48:44,727
而且需要维护的代码量也大幅上升

1177
00:48:44,727 --> 00:48:47,067
所以你很可能需要更多开发人员或再招一名开发者

1178
00:48:47,067 --> 00:48:49,328
或者占用开发者的一部分时间

1179
00:48:49,328 --> 00:49:00,707
那么问题就变成了：在什么情况下，满足一小部分用户的特殊需求仍然是值得的

1180
00:49:00,707 --> 00:49:03,328
而我...我只是...这些决定并不由我来做

1181
00:49:03,328 --> 00:49:04,727
但我能从双方的角度来看待这件事。

1182
00:49:04,727 --> 00:49:16,328
我认为就像那些制作电影的人一样，他们会插入非常微妙的细节，只有少数人会意识到这些细节的存在

1183
00:49:16,328 --> 00:49:19,127
这最终会带来丰厚的回报。

1184
00:49:19,127 --> 00:49:25,767
随着时间的推移，会建立起一种声誉，这种声誉会产生非常强大的连锁效应

1185
00:49:25,767 --> 00:49:27,368
呃，我觉得它确实有

1186
00:49:27,368 --> 00:49:34,848
它带来了诸多好处，尤其是在招聘优秀软件工程师方面。

1187
00:49:34,848 --> 00:49:40,028
就像你为这个地方营造了一种氛围

1188
00:49:40,028 --> 00:49:44,647
嗯，把爱倾注到每个细节中

1189
00:49:44,647 --> 00:49:48,828
这确实满足了高级用户的需求

1190
00:49:48,828 --> 00:49:50,528
这照顾到了开发者的需求

1191
00:49:50,528 --> 00:49:57,468
我认为微软正越来越朝着这个方向发展，通过 GitHub 平台以及收购 GitHub，专注于服务开发者群体

1192
00:49:57,468 --> 00:50:02,788
但在 Windows 用户界面方面，拜托，还差得远呢

1193
00:50:02,788 --> 00:50:03,817
一些自定义选项。

1194
00:50:03,817 --> 00:50:07,167
比如，在 VS Code 中，你可以自定义所有东西。

1195
00:50:07,167 --> 00:50:09,127
为什么，为什么我们就不能自定义开始菜单呢

1196
00:50:09,127 --> 00:50:10,227
对吧？

1197
00:50:10,227 --> 00:50:14,437
呃，那个……任务栏啊，嗯

1198
00:50:14,437 --> 00:50:17,048
还有 Windows 界面的每一个细节

1199
00:50:17,048 --> 00:50:18,253
我……我不……我不……

1200
00:50:18,253 --> 00:50:18,618
..

1201
00:50:18,618 --> 00:50:22,578
也许你说得对，可能这确实会增加代码的复杂度。

1202
00:50:22,578 --> 00:50:25,028
我怀疑事实并非如此。

1203
00:50:25,028 --> 00:50:25,558
我敢打赌就是这样。

1204
00:50:25,558 --> 00:50:28,067
我猜这是他们重写开始菜单时的一个排期决策。

1205
00:50:28,067 --> 00:50:30,707
我认为他们重写是因为它与旧任务栏不同。

1206
00:50:30,707 --> 00:50:31,408
嗯哼。

1207
00:50:31,408 --> 00:50:35,028
有人接到任务：“你必须交付这套功能集”

1208
00:50:35,028 --> 00:50:39,798
如果去掉左侧、顶部和右侧的布局，以及两行标签页等所有花哨功能

1209
00:50:39,798 --> 00:50:42,780
我就能提前四个月交付

1210
00:50:42,780 --> 00:50:44,457
" 当然这未必是正确的决策

1211
00:50:44,457 --> 00:50:47,348
但我猜这可能是推动它的原因之一。

1212
00:50:47,348 --> 00:50:49,178
而且他们现在的发布周期完全不同了。

1213
00:50:49,178 --> 00:50:50,705
以前是这样的。

1214
00:50:50,705 --> 00:50:51,437
..

1215
00:50:51,437 --> 00:50:57,768
除非有人长期负责某个组件并使其趋于稳定，否则你很难看到太多精雕细琢的工艺。

1216
00:50:57,768 --> 00:50:58,468
对吧？

1217
00:50:58,468 --> 00:51:02,287
但如果它总是频繁变动，每个版本的用户界面都在更改

1218
00:51:02,287 --> 00:51:03,888
就永远达不到那种精致程度。

1219
00:51:03,888 --> 00:51:05,268
虽然我认为这个用户界面已经相当不错了

1220
00:51:05,268 --> 00:51:05,561
但是。

1221
00:51:05,561 --> 00:51:05,698
..

1222
00:51:05,698 --> 00:51:06,433
我同意。

1223
00:51:06,433 --> 00:51:06,437
..

1224
00:51:06,437 --> 00:51:10,848
嗯，是——是挺好的，但我认为这——我觉得这——我只是不认为这是个时间安排的问题

1225
00:51:10,848 --> 00:51:15,397
我觉得这是个工艺水平的问题，就像你用一个任务管理器那样。

1226
00:51:15,397 --> 00:51:19,488
如果里面有个伙计或姑娘能真正负责起来的话

1227
00:51:19,488 --> 00:51:26,158
那些对此充满热情的人——对他们来说，这是值得骄傲的事情

1228
00:51:26,158 --> 00:51:33,687
经过一段时间，他们能够在短时间内独立创造出真正美妙的东西。

1229
00:51:33,687 --> 00:51:34,227
没错。

1230
00:51:34,227 --> 00:51:42,127
就像我-我觉得如果你有庞大的软件工程团队，带着经理和会-会议安排之类的东西

1231
00:51:42,127 --> 00:51:44,348
是啊，好吧，那-那你的论点就成立了。

1232
00:51:44,348 --> 00:51:53,968
但如果-如果你允许那些创造酷炫玩意儿的个人自由发展，让他们做自己的那种副项目

1233
00:51:53,968 --> 00:51:55,177
这方面谷歌就做得很好。

1234
00:51:55,177 --> 00:51:55,198
..

1235
00:51:55,198 --> 00:51:55,778
他们试过那个方法了，对吧？

1236
00:51:55,778 --> 00:51:56,308
谷歌，没错。

1237
00:51:56,308 --> 00:52:00,687
对，就像玩着来，搞点疯狂的操作，然后我们会整合进去。

1238
00:52:00,687 --> 00:52:03,087
我们会——我们会尝试把它整合到整个生态系统中。

1239
00:52:03,087 --> 00:52:04,187
我不知道。

1240
00:52:04,187 --> 00:52:05,718
我不知道，呃，呃，因为就像

1241
00:52:05,718 --> 00:52:16,008
对我来说，作为一个独立开发者，能创造出像开始菜单或任务栏这样的定制功能，是莫大的快乐

1242
00:52:16,008 --> 00:52:18,968
因为你知道会有数百万人使用它

1243
00:52:18,968 --> 00:52:20,647
呃，那个-那个任务栏。

1244
00:52:20,647 --> 00:52:27,997
然后你就知道可能有成千上万的开发者会用它来定制任务栏的每一个细微之处。

1245
00:52:27,997 --> 00:52:37,508
你知道这能带来多少快乐吗——让人们通过某种 JSON 配置来定制任务栏的某些功能？

1246
00:52:37,508 --> 00:52:45,328
好吧，但你怎么回应史蒂夫·乔布斯式的观点——提供定制选项意味着我们没能为你找到最佳解决方案？

1247
00:52:45,328 --> 00:52:50,218
又或许本就没有标准答案，这四个选项都同样正确

1248
00:52:50,218 --> 00:52:51,046
我对此一无所知。

1249
00:52:51,046 --> 00:52:51,397
没错。

1250
00:52:51,397 --> 00:52:54,658
呃，我一直觉得——我很高兴苹果公司存在

1251
00:52:54,658 --> 00:52:58,348
这是件美好的事，那种对设计的热爱理念非常棒

1252
00:52:58,348 --> 00:53:01,287
但我始终认为他们的——Windows 系统创造了这种反差。

1253
00:53:01,287 --> 00:53:07,247
Windows 的核心理念是成为适用于各类设备的操作系统

1254
00:53:07,247 --> 00:53:09,968
它本应——更确切地说——被设计得更加开放

1255
00:53:09,968 --> 00:53:14,127
随着 Windows 子系统的推出，微软在 Linux 兼容性方面正不断向这个方向迈进

1256
00:53:14,127 --> 00:53:18,187
这整个开发者友好型生态系统正是如此

1257
00:53:18,187 --> 00:53:21,028
这-这-界面设计应该体现那种精神

1258
00:53:21,028 --> 00:53:21,647
我认为。

1259
00:53:21,647 --> 00:53:21,828
没错。

1260
00:53:21,828 --> 00:53:26,087
但-但我确实认为这可能会带来一些安全漏洞

1261
00:53:26,087 --> 00:53:27,627
不仅仅是代码复杂性的问题

1262
00:53:27,627 --> 00:53:30,008
因为 Windows 系统正遭受持续攻击

1263
00:53:30,008 --> 00:53:30,428
是的。

1264
00:53:30,428 --> 00:53:32,048
要确保其安全性非常困难。

1265
00:53:32,048 --> 00:53:38,388
言归正传，你还为 Windows 开发了 ZIP 文件支持功能

1266
00:53:38,388 --> 00:53:42,977
就像我提到的，开发了 VisualZIP，最终演变成了我们现在所熟知的 ZIP 文件夹。

1267
00:53:42,977 --> 00:53:44,227
讲讲这段故事吧。

1268
00:53:44,227 --> 00:53:46,567
那是我在家又写的一款软件

1269
00:53:46,567 --> 00:53:50,328
然后，呃，当时我和妻子外出，我记得是个周日下午

1270
00:53:50,328 --> 00:53:53,808
我们开车转悠，那是 1993 年，我们还住在公寓里

1271
00:53:53,808 --> 00:53:56,928
就是想看看外面的房地产市场行情。

1272
00:53:56,928 --> 00:54:01,627
有个家伙，他有套漂亮的三居室房子和一辆 93 年红色克尔维特敞篷车

1273
00:54:01,627 --> 00:54:04,087
火炬红，就停在车道上，那房子正在挂牌出售

1274
00:54:04,087 --> 00:54:08,428
我记得标价大概是 30 万美元，那时候我根本不可能凑出这笔钱

1275
00:54:08,428 --> 00:54:09,758
甚至连首付都拿不出来

1276
00:54:09,758 --> 00:54:16,187
于是，我拿过传单，把房子的图片剪下来贴在了显示器上。

1277
00:54:16,187 --> 00:54:18,667
这就是我晚上坚持写作的动力

1278
00:54:18,667 --> 00:54:21,127
因为我回家后主要做两件事

1279
00:54:21,127 --> 00:54:26,268
一是宣泄工作中只能修 bug 无法释放的创作欲

1280
00:54:26,268 --> 00:54:28,457
当时我想赚点外快。

1281
00:54:28,457 --> 00:54:30,758
于是，我写了个 shell 扩展程序。

1282
00:54:30,758 --> 00:54:32,127
在我真正加入 shell 团队之前

1283
00:54:32,127 --> 00:54:38,747
我就开始了这个项目，正是基于当时 MSDN 或 MSJ 上的一个示例，激发了我加入 shell 团队的兴趣

1284
00:54:38,747 --> 00:54:41,332
我看到的关于如何操作的 MSJ 示例

1285
00:54:41,332 --> 00:54:41,514
..

1286
00:54:41,514 --> 00:54:42,484
调出一个文件夹

1287
00:54:42,484 --> 00:54:45,004
其实，当我掌握了最基本的调出文件夹模板后

1288
00:54:45,004 --> 00:54:48,804
为其添加 zip 文件支持就只是逐步完善的过程

1289
00:54:48,804 --> 00:54:50,884
于是，我就把它作为共享软件发布了。

1290
00:54:50,884 --> 00:54:51,736
我记得那时是 19。

1291
00:54:51,736 --> 00:54:52,574
95 年还是 29。

1292
00:54:52,574 --> 00:54:55,484
95 年，卖出了大概几百到几千份吧。

1293
00:54:55,484 --> 00:54:59,184
有一天，我正在准备工作时接到一个电话

1294
00:54:59,184 --> 00:55:01,144
电话那头是位女士，她问："你是戴夫·普卢默吗？"

1295
00:55:01,144 --> 00:55:02,044
我回答："是的"，她又说

1296
00:55:02,044 --> 00:55:03,984
"你就是那个开发 VisualZip 的人吗？"

1297
00:55:03,984 --> 00:55:05,544
我说：“是的，”然后她说

1298
00:55:05,544 --> 00:55:11,286
“你好，我是微软的贝琪，我们想请你过来谈谈收购的事。”

1299
00:55:11,286 --> 00:55:12,834
我说：“好的，你们在哪个楼？”

1300
00:55:12,834 --> 00:55:14,050
她回答：“什么意思？”

1301
00:55:14,050 --> 00:55:15,654
我说："那好吧，我会过来的"

1302
00:55:15,654 --> 00:55:18,644
然后她说："不行，你得先跟差旅部门谈，还得跟法务部门谈

1303
00:55:18,644 --> 00:55:19,781
这些都需要提前安排好

1304
00:55:19,781 --> 00:55:20,944
" 我就觉得："我完全搞不懂"

1305
00:55:20,944 --> 00:55:22,124
我们在同一个地方工作。

1306
00:55:22,124 --> 00:55:23,171
为什么我就不能顺便过去呢？

1307
00:55:23,171 --> 00:55:24,794
"我不确定我是不是原话这么说的——是的。

1308
00:55:24,794 --> 00:55:24,794
.

1309
00:55:24,794 --> 00:55:24,794
.

1310
00:55:24,794 --> 00:55:29,194
但经过几分钟的来回交流，我们俩都意识到她不知道我在那里工作——是的。

1311
00:55:29,194 --> 00:55:29,394
这挺有趣的。

1312
00:55:29,394 --> 00:55:29,394
.

1313
00:55:29,394 --> 00:55:29,394
.

1314
00:55:29,394 --> 00:55:32,264
他们只是冷不防地给作者打了个电话，结果发现那个人就是我。

1315
00:55:32,264 --> 00:55:32,714
是的。

1316
00:55:32,714 --> 00:55:32,794
这挺有趣的。

1317
00:55:32,794 --> 00:55:36,384
于是，他们给我开出了一个收购条件

1318
00:55:36,384 --> 00:55:38,584
这种事情就是，如果我不接受这个条件

1319
00:55:38,584 --> 00:55:42,284
那我现在的选择要么是继续卖自己的版本然后离开微软

1320
00:55:42,284 --> 00:55:45,684
或者我可以停止销售自己的版本，转而为微软工作。

1321
00:55:45,684 --> 00:55:46,694
这两种选择都不理想。

1322
00:55:46,694 --> 00:55:47,724
我是说，我当然想保住现在的工作，

1323
00:55:47,724 --> 00:55:50,524
但也希望能保留这份收入来源。

1324
00:55:50,524 --> 00:55:52,124
另一个选择是接受他们的报价

1325
00:55:52,124 --> 00:55:52,864
这正是我所做的

1326
00:55:52,864 --> 00:55:56,077
于是我买了辆 93 年的二手红色科尔维特

1327
00:55:56,077 --> 00:55:56,274
..

1328
00:55:56,274 --> 00:56:00,724
然后你们得以继续内部开发？

1329
00:56:00,724 --> 00:56:01,344
我做到了。

1330
00:56:01,344 --> 00:56:02,584
因此我们移除了许多功能

1331
00:56:02,584 --> 00:56:08,304
没错，简单来说，因为它包含加密功能以及当时压缩软件常见的一些特性

1332
00:56:08,304 --> 00:56:12,734
但这些特性可能并不适合 Windows 系统，而且在那时

1333
00:56:12,734 --> 00:56:18,444
加密技术就像军需品一样受到管制，不能随意添加到操作系统的各个部分

1334
00:56:18,444 --> 00:56:20,274
所以我们移除了这类功能。

1335
00:56:20,274 --> 00:56:23,824
我认为去掉多卷支持是为了简化操作。

1336
00:56:23,824 --> 00:56:25,344
呃，你能谈谈 zip 格式的总体情况吗

1337
00:56:25,344 --> 00:56:27,604
就是 zip 的历史背景，你知道的

1338
00:56:27,604 --> 00:56:28,664
还有压缩技术？

1339
00:56:28,664 --> 00:56:29,924
整件事。

1340
00:56:29,924 --> 00:56:31,824
是的，这其实起源于 BBS 时代

1341
00:56:31,824 --> 00:56:39,324
那时人们通过调制解调器拨号上网，从 BBS 下载试用软件和共享软件等资源

1342
00:56:39,324 --> 00:56:43,624
为了压缩这些文件，可执行文件的体积能缩小约一半。

1343
00:56:43,624 --> 00:56:50,574
其他东西压缩效果更好，但有个叫菲尔·卡斯特的人开发了名为 PKZIP 的 MS-DOS 命令行程序——嗯。

1344
00:56:50,574 --> 00:56:50,607
.

1345
00:56:50,607 --> 00:56:50,613
..

1346
00:56:50,613 --> 00:56:52,524
这个程序能够压缩软件

1347
00:56:52,524 --> 00:56:59,284
他的人生轨迹相当悲情，但这个程序在整个 PC 行业变得无处不在

1348
00:56:59,284 --> 00:57:01,484
几乎所有人都在使用它。

1349
00:57:01,484 --> 00:57:04,424
所以当 Windows 系统问世时，它无法直接打开 zip 文件

1350
00:57:04,424 --> 00:57:06,764
但人们使用这种压缩格式已有十年之久

1351
00:57:06,764 --> 00:57:11,084
这直接推动了将 zip 支持功能内置到 Windows 系统中的需求

1352
00:57:11,084 --> 00:57:15,384
确实，这也成为了延续至今的基础软件功能之一

1353
00:57:15,384 --> 00:57:16,074
嗯哼。

1354
00:57:16,074 --> 00:57:17,454
而且它还有很大的改进空间，但

1355
00:57:17,454 --> 00:57:18,924
要知道，这代码是在单核时代写的

1356
00:57:18,924 --> 00:57:23,284
所以它没有任何多线程处理能力，而你用的可是 96 核的 7995 处理器

1357
00:57:23,284 --> 00:57:26,144
结果呢，解压文件时它只用其中一个核心。

1358
00:57:26,144 --> 00:57:29,924
你在微软还参与了哪些很酷的项目？

1359
00:57:29,924 --> 00:57:32,244
还有哪些软件项目？

1360
00:57:32,244 --> 00:57:35,184
我参与了 Windows Media Center 最初的原型开发工作。

1361
00:57:35,184 --> 00:57:35,474
原来如此——我明白了。

1362
00:57:35,474 --> 00:57:35,477
.

1363
00:57:35,477 --> 00:57:35,484
..

1364
00:57:35,484 --> 00:57:37,574
我记得是在 96 年的时候

1365
00:57:37,574 --> 00:57:40,504
那时候我们还没有

1366
00:57:40,504 --> 00:57:48,634
任何资源来源，只有一张光盘，里面存着《狂暴鲁道夫》的 MPEG 视频文件，我记得还有原版的《南方公园》视频——嗯。

1367
00:57:48,634 --> 00:57:48,634
.

1368
00:57:48,634 --> 00:57:48,634
.

1369
00:57:48,634 --> 00:57:52,324
就是圣诞特辑那部，按现在的职场标准来看内容都相当不合适

1370
00:57:52,324 --> 00:57:53,534
但是，呃...

1371
00:57:53,534 --> 00:57:53,534
..

1372
00:57:53,534 --> 00:57:55,700
这就是我们当时掌握的全部内容，直到我们真正...

1373
00:57:55,700 --> 00:57:55,734
..

1374
00:57:55,734 --> 00:57:57,204
我们让他们在屋顶安装了卫星天线

1375
00:57:57,204 --> 00:57:58,924
一个 DSS 系统，就是那种 18 英寸的卫星天线

1376
00:57:58,924 --> 00:58:01,204
因为我们无法将有线电视接入大楼

1377
00:58:01,204 --> 00:58:04,384
于是我们搭建了这个最终看起来很像 Media Center 的系统

1378
00:58:04,384 --> 00:58:06,454
它是 Windows 的远程观看用户界面

1379
00:58:06,454 --> 00:58:09,744
这样你就可以坐在台式机前用遥控器操作

1380
00:58:09,744 --> 00:58:10,180
你知道的。

1381
00:58:10,180 --> 00:58:10,254
..

1382
00:58:10,254 --> 00:58:12,304
现在的开始菜单在 20 英尺外看起来效果不佳

1383
00:58:12,304 --> 00:58:12,584
所以...

1384
00:58:12,584 --> 00:58:17,004
给我讲讲那个臭名昭著的蓝屏死机的故事。

1385
00:58:17,004 --> 00:58:19,644
这种情况发生在 Windows 别无选择时

1386
00:58:19,644 --> 00:58:22,444
当内核进入发生非法操作的状态时

1387
00:58:22,444 --> 00:58:26,744
例如某个设备驱动程序试图写入不属于它的内存区域

1388
00:58:26,744 --> 00:58:29,484
或者试图重复释放同一块内存

1389
00:58:29,484 --> 00:58:32,384
这些情况根本不应该发生，而内核此时别无选择

1390
00:58:32,384 --> 00:58:35,294
它会关机以保存你的工作 - 嗯。

1391
00:58:35,294 --> 00:58:35,294
.

1392
00:58:35,294 --> 00:58:35,294
.

1393
00:58:35,294 --> 00:58:38,424
而且，准确来说不是保存，而是防止进一步损坏

1394
00:58:38,424 --> 00:58:39,964
然后它会显示蓝屏，并且

1395
00:58:39,964 --> 00:58:43,484
呃，根据你的设置打印出堆栈信息。

1396
00:58:43,484 --> 00:58:45,734
有时候只是一个悲伤的表情。

1397
00:58:45,734 --> 00:58:45,734
..

1398
00:58:45,734 --> 00:58:46,884
在当前 Windows 系统中。

1399
00:58:46,884 --> 00:58:51,594
是啊，我在想最早出现蓝屏的是哪个版本的 Windows。

1400
00:58:51,594 --> 00:58:54,784
所以，Windows 3 就有蓝屏了- 嗯。

1401
00:58:54,784 --> 00:58:54,794
.

1402
00:58:54,794 --> 00:58:54,794
..

1403
00:58:54,794 --> 00:58:57,804
但这与 Windows NT 的蓝屏完全无关。

1404
00:58:57,804 --> 00:58:59,944
而我曾与编写 Windows NT 蓝屏代码的人交谈过。

1405
00:58:59,944 --> 00:59:04,524
他叫 John Vert，呃，他选择蓝底白字的原因

1406
00:59:04,524 --> 00:59:07,584
我曾以为，一直听说是由于实验室里

1407
00:59:07,584 --> 00:59:10,194
你可以走过一个实验室，那里有 50 台电脑都在运行压力测试

1408
00:59:10,194 --> 00:59:11,464
"哦，那台蓝屏了

1409
00:59:11,464 --> 00:59:11,774
它——"嗯哼。

1410
00:59:11,774 --> 00:59:11,789
"

1411
00:59:11,789 --> 00:59:11,804
..

1412
00:59:11,804 --> 00:59:12,606
崩溃了。

1413
00:59:12,606 --> 00:59:13,594
事情没那么简单。

1414
00:59:13,594 --> 00:59:17,504
只是他构建所用的 MIPS 固件采用了蓝底白字的配色方案

1415
00:59:17,504 --> 00:59:21,404
而他使用的编辑器 Visual SlickEdit 也采用了相同的配色方案

1416
00:59:21,404 --> 00:59:24,004
所以你可以编写代码、启动系统、然后看着它崩溃

1417
00:59:24,004 --> 00:59:25,774
并重新启动，全部采用相同的配色方案。

1418
00:59:25,774 --> 00:59:33,784
为什么你认为电脑的许多问题都可以通过关机再开机来解决？

1419
00:59:33,784 --> 00:59:37,844
我认为电脑在长时间运行过程中会发生两件主要的事情。

1420
00:59:37,844 --> 00:59:40,364
一是内存被占用后未被释放。

1421
00:59:40,364 --> 00:59:40,624
是的。

1422
00:59:40,624 --> 00:59:44,124
于是这些数据就堆积在堆内存、交换文件或其他地方

1423
00:59:44,124 --> 00:59:45,204
导致系统运行变得迟缓。

1424
00:59:45,204 --> 00:59:50,724
另一个问题是，代码会进入开发者未曾预料或没有充分测试的状态。

1425
00:59:50,724 --> 00:59:51,244
嗯哼。

1426
00:59:51,244 --> 00:59:55,024
或许这种状态很罕见，但此时记事本、Word 或 Excel 已经陷入这种异常状态

1427
00:59:55,024 --> 00:59:56,084
你的系统真不靠谱。

1428
00:59:56,084 --> 00:59:58,704
所以如果你直接重启、关机或者重新启动它

1429
00:59:58,704 --> 01:00:01,204
就能得到一个全新状态，也就没有内存泄漏了

1430
01:00:01,204 --> 01:00:03,684
基本上这能掩盖很多问题。

1431
01:00:03,684 --> 01:00:18,784
而且，呃，几款处于滑稽状态的软件以复杂方式相互影响时，就会形成一种"元滑稽状态"——整个系统就开始表现得有点诡异了。

1432
01:00:18,784 --> 01:00:19,204
是的。

1433
01:00:19,204 --> 01:00:21,244
然后不知怎么的就修好了。

1434
01:00:21,244 --> 01:00:26,924
在微软的那段时间里，你见过哪些最好和最差的代码？

1435
01:00:26,924 --> 01:00:31,884
有哪些漂亮的代码和丑陋的代码让你记忆犹新？

1436
01:00:31,884 --> 01:00:34,444
说到漂亮的代码，有两段让我印象深刻。

1437
01:00:34,444 --> 01:00:38,414
一个是通用的内核部分，当你深入到 Windows 内核时——嗯。

1438
01:00:38,414 --> 01:00:38,414
.

1439
01:00:38,414 --> 01:00:38,414
.

1440
01:00:38,414 --> 01:00:42,084
在实际的 NT API 等底层接口中，代码写得非常好

1441
01:00:42,084 --> 01:00:45,284
而且其编写标准是用户层面所达不到的

1442
01:00:45,284 --> 01:00:47,507
至少在用户端并不常见。

1443
01:00:47,507 --> 01:00:47,829
..

1444
01:00:47,829 --> 01:00:56,190
在用户端，我记得见过最酷的代码是由一个叫 Bob Day 的人写的命名管道实现，它消除了对共享内存的使用。

1445
01:00:56,190 --> 01:01:01,980
Windows 95 在所有 shell 进程之间有一个大的共享段，用来存储所有 shell 共用的东西。

1446
01:01:01,980 --> 01:01:03,940
我们不想这样做。

1447
01:01:03,940 --> 01:01:07,000
在 NT 系统和工业级应用中，共享内存是个糟糕的主意

1448
01:01:07,000 --> 01:01:09,720
因此他提出了一种使用命名管道的方法

1449
01:01:09,720 --> 01:01:11,810
而且，呃，我记得当时还做了代码审查

1450
01:01:11,810 --> 01:01:15,880
走查这段代码时确实令人印象深刻

1451
01:01:15,880 --> 01:01:16,940
这就像是那种

1452
01:01:16,940 --> 01:01:19,460
"噢，要是我刻意去做可能反而做不到的事"

1453
01:01:19,460 --> 01:01:23,000
你见过最厉害的程序员是谁？

1454
01:01:23,000 --> 01:01:23,380
你知道吗？

1455
01:01:23,380 --> 01:01:24,480
我不认为有特定某个人。

1456
01:01:24,480 --> 01:01:25,900
我遇到过许多优秀的程序员。

1457
01:01:25,900 --> 01:01:27,840
但我要讲一个让我印象非常深刻的故事

1458
01:01:27,840 --> 01:01:29,450
那是在我刚进公司的时候

1459
01:01:29,450 --> 01:01:34,310
我在那里待了大概六周，正在研究我之前提到的那个 OLE Presentation Cache。

1460
01:01:34,310 --> 01:01:38,160
当时我用的是 Windows 95 系统，把 Excel 嵌入了 Word 里

1461
01:01:38,160 --> 01:01:41,540
我正用内核调试器调试时，调度程序出了些问题。

1462
01:01:41,540 --> 01:01:42,730
你知道，我当时就在现场调试

1463
01:01:42,730 --> 01:01:49,080
我几乎没写过什么 x86 代码，正盯着 Windows 调度程序试图找出我的程序死锁的原因。

1464
01:01:49,080 --> 01:01:53,940
最终我卡住了，这有点超出我的能力范围，于是我给 Windows 95 内核团队发了封邮件说

1465
01:01:53,940 --> 01:01:54,962
"能派人过来看看吗？

1466
01:01:54,962 --> 01:02:00,320
"大约十分钟后，这位开发人员悠闲地走进来，手里只拿了一根零调制解调器线缆

1467
01:02:00,320 --> 01:02:03,880
目的是将我的两台机器连接起来，以便它们能互相调试，以防我没有调试环境

1468
01:02:03,880 --> 01:02:05,640
但它已经设置好了。

1469
01:02:05,640 --> 01:02:07,720
于是他们坐下来，开始使用 WinDbg

1470
01:02:07,720 --> 01:02:09,220
这是个糟糕透顶的调试器。

1471
01:02:09,220 --> 01:02:10,640
这简直是被诅咒的。

1472
01:02:10,640 --> 01:02:24,059
但是，呃，他们对此非常非常熟练，正飞速地遍历调用栈，检查内核中的所有对象，试图找出谁在等待什么、为什么会出现死锁、哪些信号被触发而哪些没有。

1473
01:02:24,059 --> 01:02:30,710
这就像一场水银般灵动的调用栈芭蕾在我眼前飞掠而过，我看着这一切，感到相当震撼——虽然我自认是个不错的程序员，

1474
01:02:30,710 --> 01:02:34,240
但眼前这位简直是调试大师，我从未见过如此精彩的表演。

1475
01:02:34,240 --> 01:02:38,860
然后，大概过了五分钟，我听到

1476
01:02:38,860 --> 01:02:40,988
"哦，我明白了。

1477
01:02:40,988 --> 01:02:43,220
"然后他们就断开连接起身离开了。

1478
01:02:43,220 --> 01:02:46,540
那位就是后来成为微软杰出工程师的 Laura Butler。

1479
01:02:46,540 --> 01:02:47,320
我觉得她可能还在

1480
01:02:47,320 --> 01:02:48,640
我不确定她是否已经退休

1481
01:02:48,640 --> 01:02:49,346
但是。

1482
01:02:49,346 --> 01:02:49,660
..

1483
01:02:49,660 --> 01:02:52,080
所以她某种程度上为我树立了榜样

1484
01:02:52,080 --> 01:02:56,080
你知道的，就是微软开发者在调试时的样子，以及内核开发者的工作方式

1485
01:02:56,080 --> 01:02:59,440
因为我接触的女性开发者样本实在太少了，甚至不知道她们是什么样子的。

1486
01:02:59,440 --> 01:03:01,629
嗯，但标准确实非常高

1487
01:03:01,629 --> 01:03:01,962
所以...

1488
01:03:01,962 --> 01:03:02,150
..

1489
01:03:02,150 --> 01:03:06,920
生活中很少有比那些在任何领域都极其出色的人更让我欣赏的了

1490
01:03:06,920 --> 01:03:10,720
不过在工程领域，越是底层技术越让我着迷

1491
01:03:10,720 --> 01:03:14,340
例如，他们能够运营或维护基础设施

1492
01:03:14,340 --> 01:03:16,140
计算机基础设施

1493
01:03:16,140 --> 01:03:20,770
不是单台计算机，而是多台计算机协同通信与工作

1494
01:03:20,770 --> 01:03:22,849
这些人简直是魔法师。

1495
01:03:22,849 --> 01:03:23,230
没错。

1496
01:03:23,230 --> 01:03:24,527
制作过程令人振奋。

1497
01:03:24,527 --> 01:03:24,610
..

1498
01:03:24,610 --> 01:03:28,554
就像观看一位技艺精湛的木匠工作。

1499
01:03:28,554 --> 01:03:28,870
..

1500
01:03:28,870 --> 01:03:30,480
我热爱任何做到极致的事物。

1501
01:03:30,480 --> 01:03:30,940
是的。

1502
01:03:30,940 --> 01:03:31,940
看着就赏心悦目。

1503
01:03:31,940 --> 01:03:34,440
看到人类能够实现这样的成就真是美好。

1504
01:03:34,440 --> 01:03:36,880
即便是在土木工程领域，当我看到

1505
01:03:36,880 --> 01:03:41,480
比如桥梁，需要多少人齐心协力才能建成

1506
01:03:41,480 --> 01:03:44,740
而现在每天都有数百万人使用它。

1507
01:03:44,740 --> 01:03:50,940
有时，通过软件你无法直观地看到受某事物影响的具体人数。

1508
01:03:50,940 --> 01:03:56,800
所以想象一下，Linux 及其各种开源组件影响了多少人

1509
01:03:56,800 --> 01:04:00,580
这些构成了 Linux 系统的开源组件。

1510
01:04:00,580 --> 01:04:01,569
这太不可思议了。

1511
01:04:01,569 --> 01:04:04,629
而任务管理器就是这类软件的一个例子

1512
01:04:04,629 --> 01:04:09,140
这么多年来究竟有多少人使用过它，总计多少次？

1513
01:04:09,140 --> 01:04:10,080
这太疯狂了。

1514
01:04:10,080 --> 01:04:12,640
可能有——大概几十亿次使用吧，对

1515
01:04:12,640 --> 01:04:14,000
每月大约二十亿次之类的。

1516
01:04:14,000 --> 01:04:14,016
.

1517
01:04:14,016 --> 01:04:14,030
..

1518
01:04:14,030 --> 01:04:15,030
二十亿。

1519
01:04:15,030 --> 01:04:15,660
差不多那时候

1520
01:04:15,660 --> 01:04:17,060
我看过那些指标，确实很高。

1521
01:04:17,060 --> 01:04:17,770
哦。

1522
01:04:17,770 --> 01:04:19,050
觉得不可思议吗？

1523
01:04:19,050 --> 01:04:19,520
确实。

1524
01:04:19,520 --> 01:04:32,500
不过我最欣赏的是——相信你也有过这种体验——有时候设计一个软件时，它很复杂，你在脑海中构建出它的运行方式，理清所有组件如何协同工作，知道它将如何执行和流转，最终当你编写代码时，代码完美实现了你脑海中的构想。

1525
01:04:32,500 --> 01:04:32,940
嗯哼。

1526
01:04:32,940 --> 01:04:39,460
而现在，我脑海中的那个想法已有数十亿份拷贝，运行在数百万乃至数十亿人和机器上

1527
01:04:39,460 --> 01:04:42,010
这本身对我来说就非常酷。

1528
01:04:42,010 --> 01:04:43,700
与其说是虚荣心作祟

1529
01:04:43,700 --> 01:04:46,560
不如说，呃，我对此感到惊叹吧。

1530
01:04:46,560 --> 01:04:50,400
呃，这些年来你的编程方式有什么变化吗？

1531
01:04:50,400 --> 01:04:54,720
现在我更注重代码的严谨性和复杂度了。

1532
01:04:54,720 --> 01:04:57,040
以前的做法就是一直写代码，

1533
01:04:57,040 --> 01:04:59,160
不停地写，直到某个时候才回头去整理优化。

1534
01:04:59,160 --> 01:05:00,600
现在，我换了一种方式来写代码。

1535
01:05:00,600 --> 01:05:15,720
我尝试先写出非常清晰的基础框架代码，然后再逐步完善，因为我参与过太多自己或他人负责的项目，那些项目的代码最终变得一团糟，根本无法修复。

1536
01:05:15,720 --> 01:05:18,269
所以有时候前期投入的工作最终会带来回报

1537
01:05:18,269 --> 01:05:18,890
你明白吗？

1538
01:05:18,890 --> 01:05:21,290
这些年来你用过哪些编程语言？

1539
01:05:21,290 --> 01:05:22,890
你主要用哪些技术？

1540
01:05:22,890 --> 01:05:25,480
对我来说，主要是 C++和汇编语言。

1541
01:05:25,480 --> 01:05:28,540
直到现在，C++还是你的主力语言吗？

1542
01:05:28,540 --> 01:05:30,810
是的，目前我完全专注于 Lua 和 Python

1543
01:05:30,810 --> 01:05:32,950
但这只是我正在做的副业项目

1544
01:05:32,950 --> 01:05:33,232
所以...

1545
01:05:33,232 --> 01:05:33,360
..

1546
01:05:33,360 --> 01:05:37,420
能聊聊你转向 Lua 和 Python 的经历吗

1547
01:05:37,420 --> 01:05:40,310
还有，呃，你最喜欢 C++的哪些方面？

1548
01:05:40,310 --> 01:05:43,940
我正在做的是想开发一个能玩《暴风》游戏的 AI。

1549
01:05:43,940 --> 01:05:45,540
就是那个古老的雅达利游戏，《暴风》。

1550
01:05:45,540 --> 01:05:48,730
而且，呃，这款游戏其实我保持着世界纪录。

1551
01:05:48,730 --> 01:05:49,516
然后，呃。

1552
01:05:49,516 --> 01:05:49,700
..

1553
01:05:49,700 --> 01:05:51,040
你能带我去玩这个雅达利游戏吗

1554
01:05:51,040 --> 01:05:51,440
《暴风雨》？

1555
01:05:51,440 --> 01:05:53,920
好的，雅达利《暴风雨》。

1556
01:05:53,920 --> 01:05:54,950
这是什么类型的游戏？

1557
01:05:54,950 --> 01:05:59,720
这是 1980 年的一款 3D 矢量游戏。

1558
01:05:59,720 --> 01:05:59,760
好的。

1559
01:05:59,760 --> 01:06:00,840
而且这是一款非常复杂的游戏。

1560
01:06:00,840 --> 01:06:02,500
你可以实现 360 度全方位移动。

1561
01:06:02,500 --> 01:06:03,740
屏幕上共有八发子弹。

1562
01:06:03,740 --> 01:06:04,830
大概有 11 个敌人。

1563
01:06:04,830 --> 01:06:05,980
还有尖刺陷阱。

1564
01:06:05,980 --> 01:06:07,060
所以这是个相当复杂的游戏。

1565
01:06:07,060 --> 01:06:08,500
不像那种...你懂的

1566
01:06:08,500 --> 01:06:09,560
做个《Pong》之类的游戏。

1567
01:06:09,560 --> 01:06:10,900
好的。

1568
01:06:10,900 --> 01:06:15,640
而最终我所做的，首先是取出机器里的 ROM 并逆向工程那段代码。

1569
01:06:15,640 --> 01:06:19,500
于是我了解了《Tempest》中所有代码的位置及其功能，

1570
01:06:19,500 --> 01:06:21,590
包括零页变量的位置以及各部分的存储位置。

1571
01:06:21,590 --> 01:06:21,840
嗯哼。

1572
01:06:21,840 --> 01:06:23,450
是的，有一个。

1573
01:06:23,450 --> 01:06:24,620
所以什——哦，哇。

1574
01:06:24,620 --> 01:06:26,560
这几何感很强啊。

1575
01:06:26,560 --> 01:06:26,840
..

1576
01:06:26,840 --> 01:06:28,710
好的，那个——呃，你能给我讲讲玩法吗？

1577
01:06:28,710 --> 01:06:30,240
看，那正是我在玩游戏呢。

1578
01:06:30,240 --> 01:06:31,440
这真的是你在玩吗？

1579
01:06:31,440 --> 01:06:31,820
就是我本人。

1580
01:06:31,820 --> 01:06:32,940
Dave 是最高分保持者，你马上就能看到了

1581
01:06:32,940 --> 01:06:35,020
就在顶部中央那里。

1582
01:06:35,020 --> 01:06:36,580
能-能给我解释一下我看到的是什么吗？

1583
01:06:36,580 --> 01:06:38,720
嗯，这是一个 3D 几何世界。

1584
01:06:38,720 --> 01:06:44,140
本质上就是把 3D 太空侵略者游戏融入了一个形状中

1585
01:06:44,140 --> 01:06:47,760
敌人从管道的中心向外围下降

1586
01:06:47,760 --> 01:06:49,706
它们各自有不同的行为模式

1587
01:06:49,706 --> 01:06:50,020
..

1588
01:06:50,020 --> 01:06:50,940
哇。

1589
01:06:50,940 --> 01:06:54,283
简而言之，这是一款相当复杂、难以精通的游戏

1590
01:06:54,283 --> 01:06:54,629
..

1591
01:06:54,629 --> 01:06:56,652
而我想看看能否让 AI 来玩这个游戏

1592
01:06:56,652 --> 01:07:00,732
于是，当我找出游戏中所有有趣部分在内存中的位置后

1593
01:07:00,732 --> 01:07:07,112
我将它们添加为参数，并构建了一个 Lua 应用程序，用于在游戏运行时从内存中提取所有内容

1594
01:07:07,112 --> 01:07:10,582
将它们整合为参数，通过套接字发送到 Python 端

1595
01:07:10,582 --> 01:07:12,542
然后 Python 端进行强化学习训练。

1596
01:07:12,542 --> 01:07:15,712
我在使用一个双重 DQN（Dueling Deep-Q Network），我觉得——嗯。

1597
01:07:15,712 --> 01:07:15,722
.

1598
01:07:15,722 --> 01:07:15,722
..

1599
01:07:15,722 --> 01:07:18,372
两个，呃，一个头一个尾的双重结构

1600
01:07:18,372 --> 01:07:22,292
它们会互相追逐，现在能达到约 36 关的水平

1601
01:07:22,292 --> 01:07:25,532
这已经远超大多数人类玩家了，但目标是要打通 96 关

1602
01:07:25,532 --> 01:07:26,752
所以它还有很长的路要走

1603
01:07:26,752 --> 01:07:27,411
但是。

1604
01:07:27,411 --> 01:07:27,722
..

1605
01:07:27,722 --> 01:07:29,842
嗯，你是那个红色射击物吗？

1606
01:07:29,842 --> 01:07:30,292
是的。

1607
01:07:30,292 --> 01:07:32,392
你在控制那个红色射击物吗？

1608
01:07:32,392 --> 01:07:32,972
好的。

1609
01:07:32,972 --> 01:07:33,762
有哪些选项？

1610
01:07:33,762 --> 01:07:38,032
你只需要顺时针或逆时针转动就能射击了？

1611
01:07:38,032 --> 01:07:38,301
是的。

1612
01:07:38,301 --> 01:07:40,012
所以你有一个旋转旋钮——嗯哼。

1613
01:07:40,012 --> 01:07:40,022
.

1614
01:07:40,022 --> 01:07:40,022
..

1615
01:07:40,022 --> 01:07:43,892
这是个光学旋转控制器，配有开火按钮和紧急情况下使用的超级电击器

1616
01:07:43,892 --> 01:07:44,912
不过，呃，就这样了。

1617
01:07:44,912 --> 01:07:46,632
开火并旋转，基本上就是这样。

1618
01:07:46,632 --> 01:07:48,492
好了，让我们回到你最爱的 C++。

1619
01:07:48,492 --> 01:07:49,792
你最喜欢 C++的哪些方面？

1620
01:07:49,792 --> 01:07:51,932
为什么这些年来你一直坚持使用它？

1621
01:07:51,932 --> 01:07:55,352
因为它能让我把最爱的 C 代码封装进类里。

1622
01:07:55,352 --> 01:07:56,945
我不是很...

1623
01:07:56,945 --> 01:07:57,182
..

1624
01:07:57,182 --> 01:07:58,652
好吧，其实——你真是个 C 语言高手。

1625
01:07:58,652 --> 01:07:59,232
明白了，懂了。

1626
01:07:59,232 --> 01:08:00,072
是啊，我确实是个 C 语言程序员。

1627
01:08:00,072 --> 01:08:00,092
好的。

1628
01:08:00,092 --> 01:08:02,212
虽然我写两种风格的 C++代码。

1629
01:08:02,212 --> 01:08:06,692
我写的是完全不使用指针的现代 C++20

1630
01:08:06,692 --> 01:08:09,482
也不用字符串，或者说不用字符数组

1631
01:08:09,482 --> 01:08:09,892
所以就是这样。

1632
01:08:09,892 --> 01:08:09,942
..

1633
01:08:09,942 --> 01:08:12,672
在我看来，它基本上和 Rust 一样安全。

1634
01:08:12,672 --> 01:08:12,942
嗯哼。

1635
01:08:12,942 --> 01:08:16,752
或者我用带类的 C 语言编写，这是标准的 C 语言，但

1636
01:08:16,752 --> 01:08:21,352
你知道的，加上多态性和封装性，这就是我大部分代码的样子。

1637
01:08:21,352 --> 01:08:23,252
但是，呃，我尝试兼顾两者。

1638
01:08:23,252 --> 01:08:26,432
让我问问你关于我们之前跳过的那段漫长时期。

1639
01:08:26,432 --> 01:08:29,372
呃，你在离开微软后这些年开发了很多软件

1640
01:08:29,372 --> 01:08:32,171
包括在微软期间兼职做的和离职后开发的

1641
01:08:32,171 --> 01:08:34,572
呃，很多成功的软件。

1642
01:08:34,572 --> 01:08:38,671
呃，你旗下有家公司叫 Software Online

1643
01:08:38,671 --> 01:08:43,051
因为过度骚扰用户升级而惹上了麻烦

1644
01:08:43,051 --> 01:08:44,232
我想——没错。

1645
01:08:44,232 --> 01:08:44,245
.

1646
01:08:44,245 --> 01:08:44,252
..

1647
01:08:44,252 --> 01:08:45,032
就是升级这事。

1648
01:08:45,032 --> 01:08:46,091
我看到的就是这些。

1649
01:08:46,091 --> 01:08:48,091
这一切是怎么回事，呃，

1650
01:08:48,091 --> 01:08:49,852
你从那次经历中学到了什么？

1651
01:08:49,852 --> 01:08:50,392
就是这样。

1652
01:08:50,392 --> 01:08:50,522
..

1653
01:08:50,522 --> 01:08:52,292
除了，比如说，家人健康方面的担忧，你知道的

1654
01:08:52,292 --> 01:08:54,912
当孩子们生病时，那是我生命中最可怕的时刻

1655
01:08:54,912 --> 01:09:01,091
而在此之前的那段时期却是最令人振奋和激动的，因为当时我在微软工作期间

1656
01:09:01,091 --> 01:09:04,152
我编写了所有这些共享软件工具，并私下里出售它们

1657
01:09:04,152 --> 01:09:06,051
卖了一个给微软，就像我们之前聊的那样

1658
01:09:06,051 --> 01:09:08,272
然后他们开始做得非常出色

1659
01:09:08,272 --> 01:09:12,872
接着我发现了网上的横幅广告，于是我用信用卡在一个网站上注册了账号

1660
01:09:12,872 --> 01:09:14,572
我记得那个网站叫 FastClick，你可以说

1661
01:09:14,572 --> 01:09:17,532
"我愿意为每次横幅广告展示支付这么多钱。"

1662
01:09:17,532 --> 01:09:18,221
这是我的横幅广告。

1663
01:09:18,221 --> 01:09:20,452
"然后系统就会轮播展示它。"

1664
01:09:20,452 --> 01:09:22,011
而且我没有设置上限。

1665
01:09:22,011 --> 01:09:24,736
我周一回来时发现已经花了差不多 1 万美元

1666
01:09:24,736 --> 01:09:26,551
在横幅广告上。

1667
01:09:26,551 --> 01:09:29,072
我当时就想："天啊，这要怎么跟我老婆解释？

1668
01:09:29,072 --> 01:09:30,352
这是个程序漏洞，是个错误

1669
01:09:30,352 --> 01:09:31,524
是我的错。

1670
01:09:31,524 --> 01:09:31,640
"是的。"

1671
01:09:31,640 --> 01:09:33,794
我查看了销售额，发现已经达到了约 38 美元

1672
01:09:33,794 --> 01:09:36,692
的销售额，我当时就想

1673
01:09:36,692 --> 01:09:40,492
"天啊，那我只需要在某个时候扩大规模就行了"

1674
01:09:40,492 --> 01:09:44,292
接下来的几年里，我基本上都在做这件事。

1675
01:09:44,292 --> 01:09:48,112
我们之所以陷入麻烦，是因为司法部长介入调查，他们掌握了...

1676
01:09:48,112 --> 01:09:48,402
..

1677
01:09:48,402 --> 01:09:54,062
说实话我震惊了，因为他们提出了 12 项诉讼主张，其中 10 项简直荒谬至极

1678
01:09:54,062 --> 01:09:56,141
作为一个自闭症患者，在我看来...

1679
01:09:56,141 --> 01:09:57,202
我无法认同。

1680
01:09:57,202 --> 01:09:59,422
就好像，我明明知道这十件事绝对不可能是真的。

1681
01:09:59,422 --> 01:10:00,702
我们为什么还要在这里讨论它们？

1682
01:10:00,702 --> 01:10:03,272
而他们只关心那两件可能是真的事

1683
01:10:03,272 --> 01:10:08,732
可能属实的两种情况是：它是个 30 天试用版，30 天到期后

1684
01:10:08,732 --> 01:10:11,592
如果你继续使用而不购买或卸载

1685
01:10:11,592 --> 01:10:14,132
它会每天提醒你一次，而不是每十分钟就弹窗

1686
01:10:14,132 --> 01:10:16,032
但每天只提醒一次，或者每次启动电脑时提示

1687
01:10:16,032 --> 01:10:18,192
每天最多一次。

1688
01:10:18,192 --> 01:10:20,532
而总检察长认为这太频繁了

1689
01:10:20,532 --> 01:10:21,492
相当于垃圾信息。

1690
01:10:21,492 --> 01:10:22,132
嗯哼。

1691
01:10:22,132 --> 01:10:24,892
因此我们同意将其限制为每周一次

1692
01:10:24,892 --> 01:10:26,232
我相信。

1693
01:10:26,232 --> 01:10:29,172
而且，你知道的，必须得有一个一键卸载的按钮。

1694
01:10:29,172 --> 01:10:30,532
所以我们做了这类事情。

1695
01:10:30,532 --> 01:10:34,032
另一个是，在那个年代，当有人购买一款软件时

1696
01:10:34,032 --> 01:10:36,112
即使他们在线购买的是数字下载版

1697
01:10:36,112 --> 01:10:39,012
他们仍然满心期待实物光盘会寄到家中

1698
01:10:39,012 --> 01:10:41,372
所以在 2001 年——准确说是 2003 年

1699
01:10:41,372 --> 01:10:44,812
那时候如果你购买软件

1700
01:10:44,812 --> 01:10:46,872
人们预期会收到一张光盘

1701
01:10:46,872 --> 01:10:50,412
因此我们将默认设置为通过光盘交付，数量是 3 张

1702
01:10:50,412 --> 01:10:51,142
95 或 4

1703
01:10:51,142 --> 01:10:56,772
95 张额外光盘，而且很明显这是个复选框选项，且默认勾选为将光盘邮寄到您家中

1704
01:10:56,772 --> 01:10:57,892
因为我们发现如果不这样做

1705
01:10:57,892 --> 01:10:59,532
就会接到大量电话，人们会一直等待

1706
01:10:59,532 --> 01:11:01,823
他们下单后，两周后打电话问："我的光盘在哪？"

1707
01:11:01,823 --> 01:11:03,335
而我们只能回答："听着，我们根本没订过光盘。"

1708
01:11:03,335 --> 01:11:04,552
"好吧，全部取消吧。"

1709
01:11:04,552 --> 01:11:06,544
我不想要了，因为我等不及了。

1710
01:11:06,544 --> 01:11:10,272
"于是我们收到了大量退货，而且我们最初没有附送光盘，后来决定还是把光盘加进去"

1711
01:11:10,272 --> 01:11:18,162
但这在华盛顿州属于先验性违反否定确认账单原则的行为，因为你实际上默认给了他们更高的购买价格

1712
01:11:18,162 --> 01:11:26,492
在软件用户关系方面如何？

1713
01:11:26,492 --> 01:11:33,312
这很有趣，比如，多久用一件事来打扰用户才合适。

1714
01:11:33,312 --> 01:11:33,632
对吧？

1715
01:11:33,632 --> 01:11:40,832
如果你从不提及任何功能，用户可能永远发现不了他们真正想要的东西。

1716
01:11:40,832 --> 01:11:41,022
没错。

1717
01:11:41,022 --> 01:11:46,501
但如果提及得太频繁，又可能会惹恼他们。

1718
01:11:46,501 --> 01:11:46,702
是的。

1719
01:11:46,702 --> 01:11:51,082
你不想让他们不得不去处理或购买什么，或者采取某些措施来摆脱它。

1720
01:11:51,082 --> 01:11:53,492
这是让我感到困扰的事情之一

1721
01:11:53,492 --> 01:11:54,222
嗯。

1722
01:11:54,222 --> 01:11:54,602
..

1723
01:11:54,602 --> 01:11:58,082
我认为 Windows 至今仍在一定程度上这样做

1724
01:11:58,082 --> 01:12:02,172
它会通过询问某些问题来打扰我

1725
01:12:02,172 --> 01:12:03,137
比如，“你想要这个吗？”

1726
01:12:03,137 --> 01:12:04,514
“就像，嗯，它。”

1727
01:12:04,514 --> 01:12:04,582
..

1728
01:12:04,582 --> 01:12:09,732
例如，我真的不喜欢用我的微软账户登录 Windows。

1729
01:12:09,732 --> 01:12:10,332
没错。

1730
01:12:10,332 --> 01:12:12,672
我觉得现在这基本上是强制要求了。

1731
01:12:12,672 --> 01:12:15,412
我觉得这实在是没办法。

1732
01:12:15,412 --> 01:12:20,032
但问题是，他们搞得好像不这么做就特别难。

1733
01:12:20,032 --> 01:12:25,333
简直就像他们觉得能糊弄我似的。

1734
01:12:25,333 --> 01:12:25,662
..

1735
01:12:25,662 --> 01:12:32,592
真的感觉像是被耍了，没法按自己意愿行事。

1736
01:12:32,592 --> 01:12:32,852
没错。

1737
01:12:32,852 --> 01:12:33,386
喜欢这样。

1738
01:12:33,386 --> 01:12:33,582
..

1739
01:12:33,582 --> 01:12:36,935
我得想，“好吧，我得点击跳过”

1740
01:12:36,935 --> 01:12:40,263
然后它会问，“确定吗？”

1741
01:12:40,263 --> 01:12:43,912
就像我得费很大脑筋才能做这件我本不——

1742
01:12:43,912 --> 01:12:46,072
你知道，作为一个...作为一个界面

1743
01:12:46,072 --> 01:12:47,632
你明白我想做什么

1744
01:12:47,632 --> 01:12:51,942
你是想诱导我不去做我想做的事

1745
01:12:51,942 --> 01:12:54,625
而我讨厌的是...

1746
01:12:54,625 --> 01:12:55,078
..

1747
01:12:55,078 --> 01:12:55,531
..

1748
01:12:55,531 --> 01:12:59,188
. 这种方法可能在转化用户方面确实有效

1749
01:12:59,188 --> 01:13:06,428
但从长远来看，它实际上并不利于维护用户的利益

1750
01:13:06,428 --> 01:13:10,418
最让我反感的是那个"使用推荐设置"选项

1751
01:13:10,418 --> 01:13:12,148
我刚完成 Windows 升级，一步步操作时

1752
01:13:12,148 --> 01:13:14,398
我正在浏览这个新的对话框或向导

1753
01:13:14,398 --> 01:13:16,098
并使用推荐设置

1754
01:13:16,098 --> 01:13:19,448
听起来像是你应该做的事，但我很确定这会让你重新使用 Edge 浏览器

1755
01:13:19,448 --> 01:13:20,078
而且-没错

1756
01:13:20,078 --> 01:13:20,078
.

1757
01:13:20,078 --> 01:13:20,078
.

1758
01:13:20,078 --> 01:13:20,868
其他这些东西。

1759
01:13:20,868 --> 01:13:23,688
所以，虽然他们推荐了，但并不适合我

1760
01:13:23,688 --> 01:13:25,288
这就是难点所在。

1761
01:13:25,288 --> 01:13:26,528
这确实是个很好的例子。

1762
01:13:26,528 --> 01:13:32,828
你觉得把默认浏览器重置为 Edge 会有怎样的效果？

1763
01:13:32,828 --> 01:13:40,408
你认为这样做真的能赢得用户的忠诚度吗？

1764
01:13:40,408 --> 01:13:42,468
难道不觉得实际上你正在...

1765
01:13:42,468 --> 01:13:48,368
你将要创造的，不过是从某些用户群体中获得的被动忠诚罢了。

1766
01:13:48,368 --> 01:13:53,108
从数据指标来看，这可能会让你误以为 Edge 用户数量确实增加了

1767
01:13:53,108 --> 01:13:56,808
但实际上，这是长期积累的声誉损害

1768
01:13:56,808 --> 01:14:01,668
最终形成"Edge 就是那个你无法完全信任的浏览器"的认知

1769
01:14:01,668 --> 01:14:01,848
没错。

1770
01:14:01,848 --> 01:14:05,308
虽然这并不公平，因为我认为 Edge 确实是一款非常优秀的浏览器

1771
01:14:05,308 --> 01:14:08,668
但这种不愉快的感觉，仅此而已。

1772
01:14:08,668 --> 01:14:10,558
我不知道那是什么，而且呃——

1773
01:14:10,558 --> 01:14:11,788
你总不希望自己的操作系统

1774
01:14:11,788 --> 01:14:13,618
变成对手吧，对吧？

1775
01:14:13,618 --> 01:14:13,618
是的。

1776
01:14:13,618 --> 01:14:15,728
有时，Windows 给人的感觉就像是在与你作对。

1777
01:14:15,728 --> 01:14:18,748
仿佛它并非真心为你着想

1778
01:14:18,748 --> 01:14:20,448
这在一定程度上让我感到困扰。

1779
01:14:20,448 --> 01:14:27,638
我的意思是，我们都有这种感觉——当有人对你过分热情，实际上却是在推销什么时，我们总会本能地产生怀疑。

1780
01:14:27,638 --> 01:14:31,438
那种互动方式确实有种独特的氛围。

1781
01:14:31,438 --> 01:14:33,878
当一个操作系统以这种方式与你互动时，

1782
01:14:33,878 --> 01:14:36,043
感觉就像...

1783
01:14:36,043 --> 01:14:36,458
..

1784
01:14:36,458 --> 01:14:39,828
是的，我宁愿每年支付 199 美元购买 Windows 专业版

1785
01:14:39,828 --> 01:14:42,348
每月 20 美元或其他收费标准

1786
01:14:42,348 --> 01:14:46,348
且不会被追加销售，我的数据也不会被货币化或类似操作

1787
01:14:46,348 --> 01:14:47,068
所以...

1788
01:14:47,068 --> 01:14:47,508
..

1789
01:14:47,508 --> 01:14:50,988
你从中学会了如何找到平衡点吗？

1790
01:14:50,988 --> 01:14:53,018
是的，我现在——我是说，我现在自我意识强多了。

1791
01:14:53,018 --> 01:14:54,788
有些事情我会以完全不同的方式去做

1792
01:14:54,788 --> 01:14:56,308
特别是在广告宣传方面

1793
01:14:56,308 --> 01:14:58,888
我一直记得有个叫大卫·奥格威的人

1794
01:14:58,888 --> 01:15:01,948
他很久以前为大众甲壳虫做过一则广告

1795
01:15:01,948 --> 01:15:03,028
那里有一张甲虫的图片

1796
01:15:03,028 --> 01:15:04,208
黑白的，上面只写着

1797
01:15:04,208 --> 01:15:05,170
"柠檬。"

1798
01:15:05,170 --> 01:15:06,988
下面还有一段文字。

1799
01:15:06,988 --> 01:15:12,408
所以它是先吸引眼球再提供信息，我一直努力遵循这个模式

1800
01:15:12,408 --> 01:15:14,368
但我觉得销售产品有三种方式

1801
01:15:14,368 --> 01:15:16,388
你可以利用性、恐惧或贪婪

1802
01:15:16,388 --> 01:15:18,928
而性对软件销售效果并不理想

1803
01:15:18,928 --> 01:15:24,908
杀毒软件用恐惧营销很有效，但对系统优化和提速工具就不太适用了

1804
01:15:24,908 --> 01:15:28,168
所以我始终专注于挖掘用户的贪婪心理

1805
01:15:28,168 --> 01:15:29,628
比如宣传"让电脑运行更快"

1806
01:15:29,628 --> 01:15:33,068
"释放更多可用内存"之类的价值主张

1807
01:15:33,068 --> 01:15:37,028
但现在我意识到，我是以自己的认知来看待这件事的

1808
01:15:37,028 --> 01:15:43,557
作为一名自闭症患者，我现在能理解他人会基于自身背景知识得出不同结论

1809
01:15:43,557 --> 01:15:47,548
我可能无意中吓到了别人，而本意只是想激发他们的贪婪本能作为激励手段

1810
01:15:47,548 --> 01:15:50,608
所以如今我会对这类表达更加谨慎

1811
01:15:50,608 --> 01:15:52,728
这问题可能有点傻，但你觉得...

1812
01:15:52,728 --> 01:15:57,268
呃，Windows 操作系统中排名前三的是...

1813
01:15:57,268 --> 01:15:59,088
不同版本有哪些？

1814
01:15:59,088 --> 01:16:01,008
我个人是 Windows 2000 服务器的粉丝。

1815
01:16:01,008 --> 01:16:02,158
等等，什么？

1816
01:16:02,158 --> 01:16:03,208
真的吗？

1817
01:16:03,208 --> 01:16:03,628
是的。

1818
01:16:03,628 --> 01:16:04,188
好的。

1819
01:16:04,188 --> 01:16:06,638
等等，等等，什——我就是靠这个经营我的生意，还有我兄弟的生意。

1820
01:16:06,638 --> 01:16:11,654
我们建立了多家沙龙，全部通过 VPN 互联并使用 SQL Server 和。

1821
01:16:11,654 --> 01:16:11,897
..

1822
01:16:11,897 --> 01:16:14,748
我不知道自己是否曾体验过 Windows 2000 服务器版

1823
01:16:14,748 --> 01:16:16,888
那么 XP 是什么时候发布的？

1824
01:16:16,888 --> 01:16:18,088
2001 年。

1825
01:16:18,088 --> 01:16:20,148
XP 之前是什么系统？

1826
01:16:20,148 --> 01:16:21,208
2000 年。

1827
01:16:21,208 --> 01:16:22,228
2000 年。

1828
01:16:22,228 --> 01:16:23,048
那还不错吧？

1829
01:16:23,048 --> 01:16:24,048
是的，我喜欢。

1830
01:16:24,048 --> 01:16:26,208
我是说，它没有 XP 那种视觉上的炫目效果

1831
01:16:26,208 --> 01:16:28,548
但作为一个系统，尤其是作为服务器操作系统

1832
01:16:28,548 --> 01:16:29,628
在当时它已经非常出色了。

1833
01:16:29,628 --> 01:16:38,068
不过 XP 嘛，嗯...从完整性、影响力以及持续时间的角度来看

1834
01:16:38,068 --> 01:16:42,138
它可能是最伟大的 Windows 系统

1835
01:16:42,138 --> 01:16:44,628
对于消费者来说，这个操作系统

1836
01:16:44,628 --> 01:16:45,177
我也这么认为

1837
01:16:45,177 --> 01:16:46,478
它确实经久不衰

1838
01:16:46,478 --> 01:16:46,478
是的。

1839
01:16:46,478 --> 01:16:47,528
还有人仍在运行它。

1840
01:16:47,528 --> 01:16:52,108
我的意思是，如果还能获得安全更新的话，我仍然会在某些设备上运行它，因为它能满足我对 Windows 需求的 98%

1841
01:16:52,108 --> 01:16:52,334
但是。

1842
01:16:52,334 --> 01:16:52,438
..

1843
01:16:52,438 --> 01:16:53,608
确实，那太不可思议了。

1844
01:16:53,608 --> 01:16:58,648
我是说，九——所以 Windows 95，我可能会把 Windows XP 排在我的第一位

1845
01:16:58,648 --> 01:17:01,148
然后 Windows 95 排第二。

1846
01:17:01,148 --> 01:17:02,288
你的评判标准是什么？

1847
01:17:02,288 --> 01:17:04,898
个人偏好或行业影响

1848
01:17:04,898 --> 01:17:05,158
..

1849
01:17:05,158 --> 01:17:10,108
行业影响、稳定性，就在那里，存在某些类似

1850
01:17:10,108 --> 01:17:12,248
就像编程中存在代码异味一样

1851
01:17:12,248 --> 01:17:17,138
就像所有功能被协调——协调得多么完美一样

1852
01:17:17,138 --> 01:17:23,498
有一种贯穿始终且保持一致的设计理念

1853
01:17:23,498 --> 01:17:26,648
功能不多不少，既不过分简化

1854
01:17:26,648 --> 01:17:27,528
没错。

1855
01:17:27,528 --> 01:17:32,338
呃，但也不过度复杂，比如蓝屏死机的频率

1856
01:17:32,338 --> 01:17:33,758
所有这些方面

1857
01:17:33,758 --> 01:17:35,078
我不确定这是否算得上一个非常正式的应用描述

1858
01:17:35,078 --> 01:17:36,748
但我觉得它简洁明了

1859
01:17:36,748 --> 01:17:38,008
所以没有太多粗糙的边缘感

1860
01:17:38,008 --> 01:17:39,701
它功能明确，响应迅速

1861
01:17:39,701 --> 01:17:39,778
..

1862
01:17:39,778 --> 01:17:40,068
是的。

1863
01:17:40,068 --> 01:17:43,698
你说你玩老虎机，

1864
01:17:43,698 --> 01:17:46,608
呃，考虑到你既喜欢硬件又喜欢软件，

1865
01:17:46,608 --> 01:17:48,828
你是最合适的人选，呃，

1866
01:17:48,828 --> 01:17:50,368
老虎机是怎么运作的？

1867
01:17:50,368 --> 01:17:52,148
我很乐意帮你打破这些幻想。

1868
01:17:52,148 --> 01:17:52,548
好的。

1869
01:17:52,548 --> 01:17:54,118
所以——

1870
01:17:54,118 --> 01:17:54,118
..

1871
01:17:54,118 --> 01:17:57,558
我觉得有点讽刺的是，我明明知道玩老虎机总体上是个必输的赌局

1872
01:17:57,558 --> 01:18:02,008
但那里有让我着迷的多巴胺盛宴，还有我喜欢的炫目灯光和高对比度色彩。

1873
01:18:02,008 --> 01:18:03,388
所以我确实会玩它们。

1874
01:18:03,388 --> 01:18:12,028
但实际上内部有一个黑箱机制，它所做的无非就是生成下一个随机数，并决定结果在

1875
01:18:12,028 --> 01:18:13,948
呃，概率和赔付方面的表现。

1876
01:18:13,948 --> 01:18:16,916
然后游戏就会说："我得编个剧情来配合这个结果。"

1877
01:18:16,916 --> 01:18:18,728
"也许是三条杠或其他什么图案

1878
01:18:18,728 --> 01:18:19,828
但它们之间毫无关联。

1879
01:18:19,828 --> 01:18:24,028
这并非转动卷轴看它们停在哪里，然后查表确定你赢得了什么。

1880
01:18:24,028 --> 01:18:25,368
完全是相反的逻辑。

1881
01:18:25,368 --> 01:18:27,208
它判断你是否获胜

1882
01:18:27,208 --> 01:18:29,868
然后编造些内容来适应那个场景

1883
01:18:29,868 --> 01:18:31,818
这确实是在破坏所有人的体验

1884
01:18:31,818 --> 01:18:32,468
有一点儿

1885
01:18:32,468 --> 01:18:35,768
呃，运行它们的是什么代码？

1886
01:18:35,768 --> 01:18:36,448
我也不太清楚。

1887
01:18:36,448 --> 01:18:39,968
我试过深入调查并获取内部访问权限

1888
01:18:39,968 --> 01:18:41,528
结果发现非常困难。

1889
01:18:41,528 --> 01:18:42,818
他们不想透露太多相关信息

1890
01:18:42,818 --> 01:18:44,858
我敢肯定这算不上什么重大机密

1891
01:18:44,858 --> 01:18:45,388
但是。

1892
01:18:45,388 --> 01:18:45,638
..

1893
01:18:45,638 --> 01:18:46,418
是的。

1894
01:18:46,418 --> 01:18:53,688
因为这些本质上都是普通 Windows 电脑，只不过运行在某种我了解不多的超安全加密飞地架构上

1895
01:18:53,688 --> 01:18:55,718
没错，它的安全级别必须严苛到极致

1896
01:18:55,718 --> 01:18:56,178
对吧？

1897
01:18:56,178 --> 01:18:56,573
是的。

1898
01:18:56,573 --> 01:18:59,407
在 70 或 80 年代，拉斯维加斯曾有一项技术

1899
01:18:59,407 --> 01:19:02,751
他四处走动，正在为老虎机烧录自己的 ROM。

1900
01:19:02,751 --> 01:19:02,817
..

1901
01:19:02,817 --> 01:19:05,107
呃，这些设备里留有后门，所以当他维修机器时

1902
01:19:05,107 --> 01:19:06,098
他会直接把他的 ROM 放进去——不错。

1903
01:19:06,098 --> 01:19:06,098
.

1904
01:19:06,098 --> 01:19:06,098
.

1905
01:19:06,098 --> 01:19:08,388
六个月后他回来了，然后——不错。

1906
01:19:08,388 --> 01:19:08,397
.

1907
01:19:08,397 --> 01:19:08,397
..

1908
01:19:08,397 --> 01:19:09,378
调用后门程序。

1909
01:19:09,378 --> 01:19:11,468
兄弟，我太爱你了。

1910
01:19:11,468 --> 01:19:13,128
呃，话说回来，你还有没有，有没有其他的

1911
01:19:13,128 --> 01:19:15,248
你还喜欢其他类似的系统吗？

1912
01:19:15,248 --> 01:19:16,487
我很喜欢各种老式硬件设备。

1913
01:19:16,487 --> 01:19:20,027
我从事汽车修复工作，经常修理 20 世纪 60 年代的美式肌肉车

1914
01:19:20,027 --> 01:19:20,748
包括轿车和卡车。

1915
01:19:20,748 --> 01:19:21,268
不错。

1916
01:19:21,268 --> 01:19:25,407
而且，呃，那些老式电脑，所以我专门修复 PDP-11。

1917
01:19:25,407 --> 01:19:28,668
这大约是我过去六个月以来的痴迷和特殊兴趣所在

1918
01:19:28,668 --> 01:19:30,768
我已经组装了好几台这种古董机。

1919
01:19:30,768 --> 01:19:32,418
嗯，你，呃，我——我看到过

1920
01:19:32,418 --> 01:19:34,987
就是，你发布，呃，关于它的视频

1921
01:19:34,987 --> 01:19:37,407
那台 PDP-11/83。

1922
01:19:37,407 --> 01:19:40,968
呃，整——整个项目是什么情况？

1923
01:19:40,968 --> 01:19:45,728
简单来说，事情是这样的：我之前组装过好几台 PDP-11，这些年来

1924
01:19:45,728 --> 01:19:48,647
我收集了所有这些零件，于是决定

1925
01:19:48,647 --> 01:19:51,147
"不如我来组装一台能造出的最好的 PDP-11 吧"

1926
01:19:51,147 --> 01:19:51,788
嗯。

1927
01:19:51,788 --> 01:19:53,428
这就像是一场追求完美的探索

1928
01:19:53,428 --> 01:19:55,647
就像你会想榨干一台电脑的全部性能

1929
01:19:55,647 --> 01:19:57,107
我曾试图榨干一台 PDP-11 的全部性能

1930
01:19:57,107 --> 01:19:59,848
所以它配备了 4 兆内存，在当时算是巨量了

1931
01:19:59,848 --> 01:20:00,777
对，就是那边那台

1932
01:20:00,777 --> 01:20:01,928
嗯哼。

1933
01:20:01,928 --> 01:20:05,768
它有很多闪烁的灯，我还得重写 BSD 内核才能让这些灯正常工作。

1934
01:20:05,768 --> 01:20:05,938
..

1935
01:20:05,938 --> 01:20:07,258
我们在这里看到的是什么？

1936
01:20:07,258 --> 01:20:08,989
什么是，那个什么。

1937
01:20:08,989 --> 01:20:09,338
..

1938
01:20:09,338 --> 01:20:11,968
最顶部是一台 PDP-11/70 的控制面板

1939
01:20:11,968 --> 01:20:15,228
我们可以基本忽略这部分，然后下面还有两个底盘。

1940
01:20:15,228 --> 01:20:16,808
其中一个有——呃——这些不同的旋钮是干什么用的？

1941
01:20:16,808 --> 01:20:18,668
抱歉问了这么蠢的问题。

1942
01:20:18,668 --> 01:20:19,918
呃，这些旋钮——

1943
01:20:19,918 --> 01:20:19,918
..

1944
01:20:19,918 --> 01:20:22,348
他们，呃，控制着你看到的 LED 显示画面。

1945
01:20:22,348 --> 01:20:22,968
哦。

1946
01:20:22,968 --> 01:20:26,348
通常来说，你能看到数据总线和地址总线

1947
01:20:26,348 --> 01:20:29,288
你可以暂停机器运行，还能编辑总线上的地址

1948
01:20:29,288 --> 01:20:31,447
并且能用开关向内存中存入数据。

1949
01:20:31,447 --> 01:20:36,647
这触感，再加上 LED 灯效。

1950
01:20:36,647 --> 01:20:39,048
这就是你心目中电脑该有的样子。

1951
01:20:39,048 --> 01:20:39,228
是的。

1952
01:20:39,228 --> 01:20:40,468
太酷了。

1953
01:20:40,468 --> 01:20:41,268
简直太棒了。

1954
01:20:41,268 --> 01:20:42,088
那这些是什么？

1955
01:20:42,088 --> 01:20:42,848
这些是什么东西？

1956
01:20:42,848 --> 01:20:45,788
是 DU-1、DU-2 吗？

1957
01:20:45,788 --> 01:20:46,728
对，这是个奇怪的软驱。

1958
01:20:46,728 --> 01:20:49,588
这是一个使用单个步进电机的双软驱

1959
01:20:49,588 --> 01:20:52,607
因此两个磁头会像连体双胞胎一样同步寻道

1960
01:20:52,607 --> 01:20:55,008
好吧，那么，你拿这个在做什么呢？

1961
01:20:55,008 --> 01:20:57,088
你是想——呃——打算修复它们吗？

1962
01:20:57,088 --> 01:20:59,228
是的，所以我恢复了它们——它真的能运行吗？

1963
01:20:59,228 --> 01:20:59,958
是的。

1964
01:20:59,958 --> 01:21:01,768
哦，那些闪烁的灯都是真的？

1965
01:21:01,768 --> 01:21:03,388
没错，全都是真实的。

1966
01:21:03,388 --> 01:21:04,498
哇。

1967
01:21:04,498 --> 01:21:05,978
然后我还得重新编译内核之类的

1968
01:21:05,978 --> 01:21:07,308
所以我不得不学习 BSD 内核。

1969
01:21:07,308 --> 01:21:10,848
现在我对它已经相当熟悉了

1970
01:21:10,848 --> 01:21:12,327
因为你不能直接添加设备驱动

1971
01:21:12,327 --> 01:21:12,496
对吧？

1972
01:21:12,496 --> 01:21:15,067
必须重新编译内核才能添加对新设备的支持

1973
01:21:15,067 --> 01:21:16,788
所以你添加了一个新的磁盘控制器。

1974
01:21:16,788 --> 01:21:17,128
嗯哼。

1975
01:21:17,128 --> 01:21:20,314
是时候构建内核了，你得去找源代码和代码。

1976
01:21:20,314 --> 01:21:20,478
..

1977
01:21:20,478 --> 01:21:21,907
你能在这上面运行代码吗？

1978
01:21:21,907 --> 01:21:23,407
是的。

1979
01:21:23,407 --> 01:21:25,748
呃，你写过几本关于自闭症的书。

1980
01:21:25,748 --> 01:21:28,487
作为一个自闭症患者，我想知道你是否能告诉我

1981
01:21:28,487 --> 01:21:32,768
比如说，自闭症患者与神经典型个体

1982
01:21:32,768 --> 01:21:34,748
在思维方式上存在哪些根本性差异

1983
01:21:34,748 --> 01:21:38,348
关于自闭症思维的基础理论被称为"单轨思维"

1984
01:21:38,348 --> 01:21:41,947
这意味着我的大脑一次只专注于一件事

1985
01:21:41,947 --> 01:21:44,117
它会非常专注地完成这件事，完成后

1986
01:21:44,117 --> 01:21:45,656
我才能继续去做下一件事

1987
01:21:45,656 --> 01:21:48,077
我不是多任务处理者，而是一个连续的单任务执行者

1988
01:21:48,077 --> 01:21:49,688
无论如何。

1989
01:21:49,688 --> 01:21:55,697
嗯，自闭症通常伴随着感官敏感和重复行为

1990
01:21:55,697 --> 01:22:03,188
行为问题会使其加剧，如果严重到个人无法调节或适应这些问题的程度

1991
01:22:03,188 --> 01:22:08,147
就会成为一种障碍，这种情况可能占人口的 1%到 2%。

1992
01:22:08,147 --> 01:22:11,088
自闭症生活中最大的好处是什么？

1993
01:22:11,088 --> 01:22:16,907
嗯，我能对特定任务付出难以置信的专注力和投入。

1994
01:22:16,907 --> 01:22:17,446
前提是。

1995
01:22:17,446 --> 01:22:17,598
..

1996
01:22:17,598 --> 01:22:18,947
必须是我热爱的事情

1997
01:22:18,947 --> 01:22:21,567
这必须是有回报的事情，必须是我能不断取得进展的事情

1998
01:22:21,567 --> 01:22:24,268
而且所有这些条件都必须满足

1999
01:22:24,268 --> 01:22:26,567
就像小孩子玩火车玩具那样纯粹

2000
01:22:26,567 --> 01:22:27,888
我也能感受到同样的快乐

2001
01:22:27,888 --> 01:22:31,567
话说回来，你也提到过自己深受

2002
01:22:31,567 --> 01:22:33,067
呃，多动症的困扰。

2003
01:22:33,067 --> 01:22:33,848
是啊，还挺严重的。

2004
01:22:33,848 --> 01:22:36,168
所以这也是其中的一部分因素，就像

2005
01:22:36,168 --> 01:22:38,748
保持专注

2006
01:22:38,748 --> 01:22:41,168
Y-或者说真正获得专注才是问题所在

2007
01:22:41,168 --> 01:22:46,117
所以我很容易分心，戴着降噪耳机也能睡着，或者根本无法入睡

2008
01:22:46,117 --> 01:22:47,367
类似这样的事情。

2009
01:22:47,367 --> 01:22:50,548
但一旦我进入专注状态，就很难被打扰

2010
01:22:50,548 --> 01:22:52,628
这有点矛盾。

2011
01:22:52,628 --> 01:22:53,487
哦，这真有意思。

2012
01:22:53,487 --> 01:22:54,688
很难进入那种状态。

2013
01:22:54,688 --> 01:22:58,027
好的，拥有自闭症思维最大的生活挑战是什么？

2014
01:22:58,027 --> 01:22:59,958
我不知道别人在想什么。

2015
01:22:59,958 --> 01:23:04,928
所以我站在你的立场，以你的身份来思考这次互动会有什么想法。

2016
01:23:04,928 --> 01:23:05,468
是的。

2017
01:23:05,468 --> 01:23:09,248
这就是我能做的最好的推测，但我想大多数神经典型性人群都会有这种感觉：

2018
01:23:09,248 --> 01:23:14,009
"哦，Lex 可能有这样的感受，因为他这样表现，他的反应是这样，他的面部表情说明..."

2019
01:23:14,009 --> 01:23:15,746
这些对我来说都完全不知所云

2020
01:23:15,746 --> 01:23:20,027
所以我为每个打交道的人都运行一个小小的代理 NPC 游戏

2021
01:23:20,027 --> 01:23:22,668
所以我想这让社交互动变得有点复杂

2022
01:23:22,668 --> 01:23:23,367
确实可能会这样

2023
01:23:23,367 --> 01:23:26,668
电话交流尤其困难，因为我需要依赖很多其他线索

2024
01:23:26,668 --> 01:23:30,088
当对方仅通过电话交流时，我只能听到他们的声音

2025
01:23:30,088 --> 01:23:33,867
人与人之间许多隐含的信息我都无法捕捉

2026
01:23:33,867 --> 01:23:37,848
因此我在 FaceTime 上表现要好得多，当有人开玩笑时

2027
01:23:37,848 --> 01:23:38,897
他们可能会事后微笑——是的。

2028
01:23:38,897 --> 01:23:38,897
.

2029
01:23:38,897 --> 01:23:38,897
.

2030
01:23:38,897 --> 01:23:42,248
在电话里，我分不清你是在讽刺还是认真的，诸如此类

2031
01:23:42,248 --> 01:23:42,928
所以...

2032
01:23:42,928 --> 01:23:45,567
所以这可能让你这些年惹上了一些麻烦。

2033
01:23:45,567 --> 01:23:47,907
是啊，和我妻子之间也经常这样

2034
01:23:47,907 --> 01:23:51,947
在自闭症中，确实存在某种字面化的思维方式。

2035
01:23:51,947 --> 01:23:52,228
确实。

2036
01:23:52,228 --> 01:23:54,288
多年来，每当她说什么，我就会...

2037
01:23:54,288 --> 01:23:55,164
“但这说不通啊。

2038
01:23:55,164 --> 01:23:56,542
” 然后她说：“你懂我意思吧。

2039
01:23:56,542 --> 01:23:57,748
” 我就回：“不，我清楚你说了什么

2040
01:23:57,748 --> 01:24:00,277
而且我并不是在故意抬杠。”

2041
01:24:00,277 --> 01:24:04,388
我确实只知道你所说的内容，"但我并不具备那个。

2042
01:24:04,388 --> 01:24:07,327
而且，呃，我记得我们曾与一些人开会时

2043
01:24:07,327 --> 01:24:09,728
呃，你知道的，会议中有三四个人

2044
01:24:09,728 --> 01:24:14,038
而我是唯一一个自闭症患者，我会指出他们形成了这种沟通循环，而我不得不

2045
01:24:14,038 --> 01:24:16,008
比如，“你们得告诉我发生了什么”

2046
01:24:16,008 --> 01:24:19,091
“因为我真的听不懂这里在说什么”

2047
01:24:19,091 --> 01:24:19,867
“所以”

2048
01:24:19,867 --> 01:24:21,527
你告诉我与此相关的是

2049
01:24:21,527 --> 01:24:25,527
早期与比尔·盖茨有过一次略显尴尬的相遇。

2050
01:24:25,527 --> 01:24:28,338
呃，你能分享一下这个故事吗

2051
01:24:28,338 --> 01:24:32,668
呃，那次互动以及自闭症在这其中起了什么作用？

2052
01:24:32,668 --> 01:24:35,428
是的，那是我在微软实习的第一个夏天

2053
01:24:35,428 --> 01:24:37,468
比尔邀请了，呃，所有实习生过来。

2054
01:24:37,468 --> 01:24:39,737
我记得大概有 20 或者 25 个人——对。

2055
01:24:39,737 --> 01:24:39,990
.

2056
01:24:39,990 --> 01:24:39,998
..

2057
01:24:39,998 --> 01:24:45,688
呃，就是那年被录用的我们，去他家吃汉堡喝啤酒，就在后院闲聊。

2058
01:24:45,688 --> 01:24:47,588
而且，呃，那当然还是比尔·盖茨

2059
01:24:47,588 --> 01:24:50,657
而且那时候他已经是个大人物了，让你有点紧张。

2060
01:24:50,657 --> 01:24:55,128
当时我的经理本算是我的导师

2061
01:24:55,128 --> 01:24:57,548
他带我过去介绍给比尔认识，因为他们之前就相识

2062
01:24:57,548 --> 01:24:59,897
本介绍道："这是戴夫，我们来自加拿大的实习生"

2063
01:24:59,897 --> 01:25:03,385
在短短四个月内，他就完成了这个功能以及 Disc Copy 和 Smart Drive

2064
01:25:03,385 --> 01:25:05,077
"然后他列举了我正在做的所有事情。

2065
01:25:05,077 --> 01:25:06,723
但我停了下来，因为我心想——

2066
01:25:06,723 --> 01:25:06,948
..

2067
01:25:06,948 --> 01:25:09,146
"其实准确来说是三个月。"

2068
01:25:09,146 --> 01:25:11,458
我不得不打断他们，而且他们俩都有点...

2069
01:25:11,458 --> 01:25:11,810
“什么？

2070
01:25:11,810 --> 01:25:16,328
他们对视了一眼，我意识到那不是个合适的时机去...

2071
01:25:16,328 --> 01:25:16,328
..

2072
01:25:16,328 --> 01:25:17,258
纠正那家伙。

2073
01:25:17,258 --> 01:25:19,278
不过，呃...是的，所以你就...

2074
01:25:19,278 --> 01:25:20,298
小差错？

2075
01:25:20,298 --> 01:25:21,218
哦，真让我抓狂。

2076
01:25:21,218 --> 01:25:22,538
是的。

2077
01:25:22,538 --> 01:25:26,945
然后，你当然不会。

2078
01:25:26,945 --> 01:25:27,388
..

2079
01:25:27,388 --> 01:25:30,478
这，这可能带来的影响

2080
01:25:30,478 --> 01:25:36,558
在随意的社交互动中，对你来说并非小事

2081
01:25:36,558 --> 01:25:38,118
呃，注意到了。

2082
01:25:38,118 --> 01:25:39,958
我现在比以前好多了。

2083
01:25:39,958 --> 01:25:47,598
以前我不明白，也不知道毫无意义地在对话中插入纠正会如何影响对方、让对方产生怎样的感受。

2084
01:25:47,598 --> 01:25:48,598
现在我更清楚这一点了

2085
01:25:48,598 --> 01:25:48,918
但是。

2086
01:25:48,918 --> 01:25:49,068
..

2087
01:25:49,068 --> 01:25:55,538
对于拥有自闭思维的人，你有什么建议能帮助他们在世界上蓬勃发展？

2088
01:25:55,538 --> 01:26:02,658
在繁荣和财务方面，我能说的最重要的一点是：推销你能做的事，而不是你自己。

2089
01:26:02,658 --> 01:26:07,118
因为如果你去参加求职面试，试图用你的个性和你有多出色来打动他们

2090
01:26:07,118 --> 01:26:10,498
结果可能有好有坏，但如果你能带着作品集去展示

2091
01:26:10,498 --> 01:26:13,818
"看，这是我的 GitHub 贡献记录，这些是我参与过的出色项目

2092
01:26:13,818 --> 01:26:17,750
这是我实际编写的算法，这就是我的能力

2093
01:26:17,750 --> 01:26:19,398
" 我认为这样会让你走得更远

2094
01:26:19,398 --> 01:26:21,898
所以无论你是弹钢琴还是写代码。

2095
01:26:21,898 --> 01:26:25,898
话虽如此，在大型团队中进行软件工程

2096
01:26:25,898 --> 01:26:29,088
很大程度上具有社交属性

2097
01:26:29,088 --> 01:26:29,798
对吧？

2098
01:26:29,798 --> 01:26:31,848
确实如此，而这曾是我的一个弱点。

2099
01:26:31,848 --> 01:26:32,724
你怎么做，你怎么做。

2100
01:26:32,724 --> 01:26:32,728
..

2101
01:26:32,728 --> 01:26:36,178
我是说，关于如何解决那个小难题，你学到了什么？

2102
01:26:36,178 --> 01:26:43,728
我认为对我来说最大的不足是当我开始管理人的时候，因为现在你要关心他们的希望

2103
01:26:43,728 --> 01:26:46,238
梦想、抱负，以及是什么激励着他们。

2104
01:26:46,238 --> 01:26:53,838
他们的生活对我来说多少是个谜，因为我总以为他们和我一样渴望被激励、被领导、被鼓励并获得相应的回报

2105
01:26:53,838 --> 01:26:55,028
但事实并非总是如此。

2106
01:26:55,028 --> 01:26:57,378
有些人需要更多肯定，有些人只想要钱

2107
01:26:57,378 --> 01:27:00,238
还有些人则渴望参与重要会议并拥有决策权。

2108
01:27:00,238 --> 01:27:08,298
但我当时对此几乎毫无察觉，最终才明白每个你管理的人都有自己的一套动机和优先事项

2109
01:27:08,298 --> 01:27:11,518
而这些与我原先设想的可能完全不同。

2110
01:27:11,518 --> 01:27:16,018
所以我想，你可以把事情说得更明白些，通过更好的沟通方式

2111
01:27:16,018 --> 01:27:19,198
比如直接询问他们关心的是什么。

2112
01:27:19,198 --> 01:27:24,347
是的，这就是我开始直接询问的原因，因为对我来说很难委婉地推动别人到那个点。

2113
01:27:24,347 --> 01:27:26,978
我不擅长那种社交舞蹈

2114
01:27:26,978 --> 01:27:27,828
所以...

2115
01:27:27,828 --> 01:27:30,378
是的，这种社交舞蹈的一部分在于有很多

2116
01:27:30,378 --> 01:27:31,498
呃，未言明的东西。

2117
01:27:31,498 --> 01:27:31,918
嗯哼。

2118
01:27:31,918 --> 01:27:35,338
你可以大概理解，能读懂他人。

2119
01:27:35,338 --> 01:27:37,199
但如果...

2120
01:27:37,199 --> 01:27:37,308
..

2121
01:27:37,308 --> 01:27:41,398
你知道的，对于自闭症患者来说，这可能有点困难

2122
01:27:41,398 --> 01:27:44,058
所以你需要把事情说得更明白些。

2123
01:27:44,058 --> 01:27:47,398
另外，像讽刺、挖苦和幽默可能比较难把握。

2124
01:27:47,398 --> 01:27:48,378
是的。

2125
01:27:48,378 --> 01:27:52,708
我真想当个旁观者，看看你早期和微软打交道时的情形。

2126
01:27:52,708 --> 01:27:57,438
呃，我是说，一些最优秀的工程师就有这样的思维方式

2127
01:27:57,438 --> 01:27:58,138
所以...

2128
01:27:58,138 --> 01:27:59,808
是啊，我还遇到过有人朝我扔笔记本电脑之类的事

2129
01:27:59,808 --> 01:28:00,858
我确信那是我的错

2130
01:28:00,858 --> 01:28:01,778
所以...

2131
01:28:01,778 --> 01:28:04,178
呃，你提到了那个 10 秒钟的自闭症测试。

2132
01:28:04,178 --> 01:28:05,838
你能解释一下这个测试是如何进行的吗？

2133
01:28:05,838 --> 01:28:06,058
是的。

2134
01:28:06,058 --> 01:28:09,038
要知道，任何只有两个选项的测试当然都会有很高的误差率

2135
01:28:09,038 --> 01:28:09,560
但是，呃...

2136
01:28:09,560 --> 01:28:09,708
..

2137
01:28:09,708 --> 01:28:12,898
对整个人类社会而言，什么才是来自民众最重要的品质？

2138
01:28:12,898 --> 01:28:14,838
是合作还是创造力？

2139
01:28:14,838 --> 01:28:17,838
如果必须二选一，哪一个最为关键？

2140
01:28:17,838 --> 01:28:20,938
大多数神经典型性人群通常会倾向于选择合作

2141
01:28:20,938 --> 01:28:26,418
而自闭谱系人群则往往更倾向于将创造力视为独立解决问题的能力。

2142
01:28:26,418 --> 01:28:28,558
当然，这里存在一定的误差率。

2143
01:28:28,558 --> 01:28:30,178
所以如果你想将精确度提高一倍

2144
01:28:30,178 --> 01:28:32,058
你可以使用第二种测试方法，即通过询问

2145
01:28:32,058 --> 01:28:36,278
房间里放着 10 把椅子，有六个人进来坐下了。

2146
01:28:36,278 --> 01:28:38,546
还剩下多少把椅子？

2147
01:28:38,546 --> 01:28:40,118
现在有人会说

2148
01:28:40,118 --> 01:28:43,578
"四把"，但我要说"十把"，因为椅子总数还是那么多。

2149
01:28:43,578 --> 01:28:45,038
字面上确实如此。

2150
01:28:45,038 --> 01:28:47,658
我并非故意刁难，也不是要搞复杂化

2151
01:28:47,658 --> 01:28:49,218
但这就是我的思维方式。

2152
01:28:49,218 --> 01:28:49,358
是的。

2153
01:28:49,358 --> 01:28:52,538
所以当我看到那个问题时，答案取决于你如何作答。

2154
01:28:52,538 --> 01:28:57,758
所以你有多按字面意思理解事物？

2155
01:28:57,758 --> 01:28:58,398
是的。

2156
01:28:58,398 --> 01:29:00,418
对我来说，一切都很字面化。

2157
01:29:00,418 --> 01:29:05,498
我记得小时候，祖父在厨房里为妈妈搭建一个花盆架

2158
01:29:05,498 --> 01:29:08,198
他用了些大角铁支架，我当时觉得有点小题大做

2159
01:29:08,198 --> 01:29:10,495
我说："你觉得这个够大能放下那株植物吗？"

2160
01:29:10,495 --> 01:29:12,752
他说："这都能装下一匹马了。"

2161
01:29:12,752 --> 01:29:15,418
那时我才五岁，但实在想不明白

2162
01:29:15,418 --> 01:29:17,278
第一，为什么有人会把马牵进厨房

2163
01:29:17,278 --> 01:29:19,028
你为什么要把马放在花盆上

2164
01:29:19,028 --> 01:29:19,768
以及所有这些事情。

2165
01:29:19,768 --> 01:29:22,228
这对我来说完全说不通，显然这是个比喻说法

2166
01:29:22,228 --> 01:29:25,498
但在我的大半生里，我都把比喻当成字面意思来理解

2167
01:29:25,498 --> 01:29:26,487
所以...

2168
01:29:26,487 --> 01:29:35,658
呃，你提到过用情感后处理作为替代社交互动的策略，这样就可以逆向推演出

2169
01:29:35,658 --> 01:29:38,118
帮助你理解普通人的世界。

2170
01:29:38,118 --> 01:29:38,584
可以。

2171
01:29:38,584 --> 01:29:38,788
..

2172
01:29:38,788 --> 01:29:40,558
我认为这对很多人都会很有用

2173
01:29:40,558 --> 01:29:42,178
比如，呃，这具体包含哪些内容？

2174
01:29:42,178 --> 01:29:43,338
这有什么帮助呢？

2175
01:29:43,338 --> 01:29:46,678
所以当我遇到某人，尤其是初次见面或刚开始打交道时

2176
01:29:46,678 --> 01:29:54,698
比如今天和你见面后，我回家后会重新回想所有需要做选择的时刻。

2177
01:29:54,698 --> 01:30:00,578
通常会先回想最尴尬的场景，找出自己当时哪里做得不对。

2178
01:30:00,578 --> 01:30:01,418
我错过了什么？

2179
01:30:01,418 --> 01:30:03,158
对方当时是怎么想的？

2180
01:30:03,158 --> 01:30:05,448
下次遇到这种情况我该如何改进

2181
01:30:05,448 --> 01:30:07,308
我需要去补救或打个电话吗

2182
01:30:07,308 --> 01:30:08,448
那种糟糕的情况，你知道的

2183
01:30:08,448 --> 01:30:10,358
在极端情况下。

2184
01:30:10,358 --> 01:30:11,300
但是，呃。

2185
01:30:11,300 --> 01:30:11,688
..

2186
01:30:11,688 --> 01:30:13,378
我人生中已经发生过几次这种情况了。

2187
01:30:13,378 --> 01:30:16,838
就像我有一辆父亲在 69 年买的新车，后来我把它修复了。

2188
01:30:16,838 --> 01:30:18,778
这辆车我现在还留着，算起来我们已经拥有它 50 年了

2189
01:30:18,778 --> 01:30:20,598
大约 20 年前，我找人把它彻底翻新了一遍

2190
01:30:20,598 --> 01:30:25,458
整个修复过程持续了三年，工匠们在这辆车上投入了数千小时的精心工作。

2191
01:30:25,458 --> 01:30:30,878
我出去取车时仔细检查，对修复工作非常满意，不停地说

2192
01:30:30,878 --> 01:30:31,923
"这真不错，太棒了"

2193
01:30:31,923 --> 01:30:37,078
之类的话。然后我飞回家开了支票，车就被送来了。

2194
01:30:37,078 --> 01:30:40,168
直到大约十年后我才意识到

2195
01:30:40,168 --> 01:30:43,398
我有一群工匠为我的车工作了整整三年

2196
01:30:43,398 --> 01:30:46,518
或许我本应该对他们大加赞赏，说他们干得多么出色

2197
01:30:46,518 --> 01:30:49,358
但我始终没这么做，因为那并非我当时所需所求

2198
01:30:49,358 --> 01:30:51,358
而我对这一切浑然不觉。

2199
01:30:51,358 --> 01:30:55,018
于是我给经理或店主发了封邮件

2200
01:30:55,018 --> 01:30:56,548
我说："不知道您是否还记得

2201
01:30:56,548 --> 01:30:59,558
但十年前我来取车时，可能表现得不太满意

2202
01:30:59,558 --> 01:31:02,743
但我想让您知道，其实我对所有细节、品质等都非常认可。"

2203
01:31:02,743 --> 01:31:05,629
他回信说："我经常想起那一刻。"

2204
01:31:05,629 --> 01:31:08,845
所以我心想："现在我很高兴我提起了这件事。"

2205
01:31:08,845 --> 01:31:13,418
是的，人类互动中有一些微妙的细节对人们意义重大

2206
01:31:13,418 --> 01:31:16,160
但如果你直接询问，他们可能无法表达出来。

2207
01:31:16,160 --> 01:31:16,295
..

2208
01:31:16,295 --> 01:31:16,430
..

2209
01:31:16,430 --> 01:31:19,788
虽然难以准确表达，但这确实很重要，而当它缺失时

2210
01:31:19,788 --> 01:31:22,228
当某些东西不对劲时，这会让他们感到困扰

2211
01:31:22,228 --> 01:31:23,008
没错。

2212
01:31:23,008 --> 01:31:26,248
但要逆向分析、找出原因

2213
01:31:26,248 --> 01:31:31,748
对于一个可能察觉不到人际交往中这些微妙细节的人来说

2214
01:31:31,748 --> 01:31:32,968
这很难。

2215
01:31:32,968 --> 01:31:39,488
关于同理心，这也是个很好的切入点，因为社区中存在一种看法，认为自闭症患者缺乏同理心

2216
01:31:39,488 --> 01:31:41,328
而我完全不这么认为

2217
01:31:41,328 --> 01:31:43,348
呃，我只能代表我自己说

2218
01:31:43,348 --> 01:31:45,018
我相当感同身受。

2219
01:31:45,018 --> 01:31:48,428
但我认为问题出在沟通上，而且是双向的

2220
01:31:48,428 --> 01:31:55,708
然而，我不知道你的感受，所以在你向我传达你的经历之前，我很难对此产生共情。

2221
01:31:55,708 --> 01:31:59,168
而一旦我了解了，嗯，一旦我明白你内心的想法

2222
01:31:59,168 --> 01:32:01,630
我能对你深感同情，但其他人...

2223
01:32:01,630 --> 01:32:01,718
..

2224
01:32:01,718 --> 01:32:04,908
在此之前，我会假设你能像我处在你的位置时那样处理它

2225
01:32:04,908 --> 01:32:06,668
以我现在所知的情况来看

2226
01:32:06,668 --> 01:32:10,348
对于处在另一立场的人们，你会给出什么建议？

2227
01:32:10,348 --> 01:32:15,708
他们如何帮助你成为更好的朋友、更好的伴侣或更好的同事

2228
01:32:15,708 --> 01:32:17,738
比如他们应该如何与你沟通来提供帮助

2229
01:32:17,738 --> 01:32:18,868
比如提供更多信息？

2230
01:32:18,868 --> 01:32:25,518
是的，要非常具体，不要假设我能领会那些细微的暗示和潜台词。

2231
01:32:25,518 --> 01:32:28,068
所以如果你想引导我采取某种特定行为

2232
01:32:28,068 --> 01:32:29,428
你最好直接说"戴夫

2233
01:32:29,428 --> 01:32:30,953
你需要这样做"

2234
01:32:30,953 --> 01:32:32,928
"我今天有哪里做得不够好吗？"

2235
01:32:32,928 --> 01:32:33,628
还没有。

2236
01:32:33,628 --> 01:32:33,918
好的。

2237
01:32:33,918 --> 01:32:40,088
你——你——你会给我打几分？满分是十分的话。

2238
01:32:40,088 --> 01:32:41,568
我是六分吗？

2239
01:32:41,568 --> 01:32:43,108
七分？

2240
01:32:43,108 --> 01:32:45,253
在通信方面 - 7.

2241
01:32:45,253 --> 01:32:45,938
5.

2242
01:32:45,938 --> 01:32:45,938
.

2243
01:32:45,938 --> 01:32:45,938
.

2244
01:32:45,938 --> 01:32:45,938
.

2245
01:32:45,938 --> 01:32:45,938
.

2246
01:32:45,938 --> 01:32:47,088
浮点数。

2247
01:32:47,088 --> 01:32:47,908
不错。

2248
01:32:47,908 --> 01:32:49,928
呃，伪装，你得告诉我这是什么意思

2249
01:32:49,928 --> 01:32:54,298
呃，这对许多自闭症谱系人士来说是一种重要体验

2250
01:32:54,298 --> 01:32:55,278
什么是伪装行为？

2251
01:32:55,278 --> 01:33:00,228
还有，能跟我聊聊你自己关于伪装的经历吗？

2252
01:33:00,228 --> 01:33:02,948
掩饰行为，或许这样描述并不准确

2253
01:33:02,948 --> 01:33:05,008
但它本质上就是表现得像常人一样

2254
01:33:05,008 --> 01:33:05,128
嗯哼。

2255
01:33:05,128 --> 01:33:11,908
也就是说，我如何在社交场合中表现得像那些神经典型人群

2256
01:33:11,908 --> 01:33:14,168
或者说像其他神经典型人士那样行事

2257
01:33:14,168 --> 01:33:18,388
会以正确的方式接收和接受它吗？

2258
01:33:18,388 --> 01:33:18,748
嗯哼。

2259
01:33:18,748 --> 01:33:26,828
你在社交互动中所做的一切，从挥手到做面部表情，再到说话的语调

2260
01:33:26,828 --> 01:33:32,848
再到姿态，都是精心设计的，需要付出努力。

2261
01:33:32,848 --> 01:33:33,208
是的。

2262
01:33:33,208 --> 01:33:35,258
对大多数人来说这很自然，他们只是顺其而为

2263
01:33:35,258 --> 01:33:41,218
而酷酷的人做得很自然，但对自闭症谱系的人来说，你得全程假装。

2264
01:33:41,218 --> 01:33:44,357
呃，对，就是装正常。

2265
01:33:44,357 --> 01:33:46,238
Rush 乐队有首歌你知道吗？

2266
01:33:46,238 --> 01:33:46,798
是的。

2267
01:33:46,798 --> 01:33:47,998
呃，《聚光灯》——对。

2268
01:33:47,998 --> 01:33:48,001
.

2269
01:33:48,001 --> 01:33:48,008
..

2270
01:33:48,008 --> 01:33:53,888
这是由尼尔·佩尔特所写，而我——我只对那些已故之人进行推测，所以我感觉他可能属于自闭症谱系

2271
01:33:53,888 --> 01:33:56,118
嗯，但歌词大意是

2272
01:33:56,118 --> 01:33:58,828
"整个世界确实是个舞台，而我们只是演员

2273
01:33:58,828 --> 01:34:01,636
表演者和扮演者，彼此互为观众。"

2274
01:34:01,636 --> 01:34:03,648
他在歌中长篇大论地谈到

2275
01:34:03,648 --> 01:34:08,428
你知道的，无法把陌生人当朋友对待，还要强装出一副样子之类的

2276
01:34:08,428 --> 01:34:11,128
所以看起来他在歌中为伪装自己而苦苦挣扎

2277
01:34:11,128 --> 01:34:13,248
虽然我不确定，但这就是我的理解。

2278
01:34:13,248 --> 01:34:14,148
是的。

2279
01:34:14,148 --> 01:34:18,968
你将崩溃描述为一种难以承受的经历，能具体描述一下崩溃是什么感觉吗？

2280
01:34:18,968 --> 01:34:22,148
通常——通常是什么引发了崩溃？

2281
01:34:22,148 --> 01:34:28,197
一般来说，就是当你情绪上不堪重负，以至于无法再控制自己的行为

2282
01:34:28,197 --> 01:34:33,448
就像电影《雨人》里演的那样，当他试图登机却被强行阻拦时，就开始情绪失控

2283
01:34:33,448 --> 01:34:34,958
这是一次崩溃。

2284
01:34:34,958 --> 01:34:37,898
或者，我在某个节目上看到过，他们确实有点...

2285
01:34:37,898 --> 01:34:37,908
..

2286
01:34:37,908 --> 01:34:40,518
实际上，可能是我在媒体上见过的最佳描绘是

2287
01:34:40,518 --> 01:34:43,948
呃，那部主角是自闭症医生的电视剧叫什么来着？

2288
01:34:43,948 --> 01:34:44,663
他是个。

2289
01:34:44,663 --> 01:34:45,158
..

2290
01:34:45,158 --> 01:34:55,868
总之，有部电视剧讲一个自闭症医生，他是外科医生，最终因为自闭症被禁止做手术，而他一直梦想成为外科医生，结果彻底崩溃了，这个电视刻画得相当不错

2291
01:34:55,868 --> 01:34:56,038
所以...

2292
01:34:56,038 --> 01:34:57,808
实际情况是怎样的？

2293
01:34:57,808 --> 01:35:00,778
就像存在一个临界点，一旦越过就——没错

2294
01:35:00,778 --> 01:35:01,948
然后开关就切换了。

2295
01:35:01,948 --> 01:35:01,958
.

2296
01:35:01,958 --> 01:35:01,958
..

2297
01:35:01,958 --> 01:35:05,458
基本上就像蓝屏一样——是的

2298
01:35:05,458 --> 01:35:05,908
差不多吧。

2299
01:35:05,908 --> 01:35:05,917
.

2300
01:35:05,917 --> 01:35:05,917
..

2301
01:35:05,917 --> 01:35:07,108
对于大脑算法来说。

2302
01:35:07,108 --> 01:35:09,168
于是开关一拨，你就进入了原始脑模式

2303
01:35:09,168 --> 01:35:11,158
你的前额皮质会在一定程度上关闭

2304
01:35:11,158 --> 01:35:15,588
我想，这样你就失去了决策和过滤的能力

2305
01:35:15,588 --> 01:35:20,508
在这种状态下你会变得非常爬虫脑化，这实际上是一种恐慌状态

2306
01:35:20,508 --> 01:35:33,068
因此，这是一种恐慌和战斗或逃跑反应，源于无法忍受当前的现实，也许情况已经令人非常沮丧，或者你一直处于混乱状态，或者经历了糟糕的旅行日，或工作中的争吵等等

2307
01:35:33,068 --> 01:35:41,848
这些累积到了临界点，某些事情终于触发你，导致大脑失去了适当调节行为的能力。

2308
01:35:41,848 --> 01:35:43,568
呃，那爱情和人际关系呢？

2309
01:35:43,568 --> 01:35:45,458
这方面有哪些挑战？

2310
01:35:45,458 --> 01:35:47,788
我知道有个节目叫《自闭症也有爱》——我听说过。

2311
01:35:47,788 --> 01:35:49,128
我没看过，但我听说过。

2312
01:35:49,128 --> 01:35:49,138
.

2313
01:35:49,138 --> 01:35:49,138
..

2314
01:35:49,138 --> 01:35:52,948
因为，呃，某些方面比如对事物的字面理解

2315
01:35:52,948 --> 01:36:00,808
恰恰让关系的复杂性，尤其是恋爱关系的复杂性更加明显了

2316
01:36:00,808 --> 01:36:01,908
在那个背景下。

2317
01:36:01,908 --> 01:36:05,837
你知道，我已经结婚 31 年，在一起 37 年了，

2318
01:36:05,837 --> 01:36:11,108
那是一段很长的历史，我们第一次意识到彼此非常不同是在

2319
01:36:11,108 --> 01:36:22,388
某个夜晚，我们坐在屋前的车里，天已经黑了，街对面有栋漂亮的房子，房子周围是用锚链连接的大砖柱，形成院子周围的围栏。

2320
01:36:22,388 --> 01:36:26,308
我看着这些东西，因为它们大约两英尺见方，还带着顶石，我心里想着

2321
01:36:26,308 --> 01:36:28,318
"我在想，它们是空心的还是后面填了东西

2322
01:36:28,318 --> 01:36:30,258
是灌了混凝土还是别的什么？

2323
01:36:30,258 --> 01:36:32,528
"这时我现在的妻子看着我，她的表情好像在说

2324
01:36:32,528 --> 01:36:34,080
"你怎么了？"

2325
01:36:34,080 --> 01:36:36,836
" "你脑子里怎么会有在意那种事的想法？"

2326
01:36:36,836 --> 01:36:37,718
"是的。"

2327
01:36:37,718 --> 01:36:37,718
太好了。

2328
01:36:37,718 --> 01:36:45,448
就在那一刻我们都明白了——我正热切地关注着这件事，而她却在困惑你为什么要为那种事操心。

2329
01:36:45,448 --> 01:36:47,248
我们知道自己截然不同，所以。

2330
01:36:47,248 --> 01:36:51,928
是啊，那些看似无关紧要的细节却非常具体。

2331
01:36:51,928 --> 01:36:53,811
但是，呃...

2332
01:36:53,811 --> 01:36:53,818
..

2333
01:36:53,818 --> 01:36:56,292
我向来不擅长与人相处。

2334
01:36:56,292 --> 01:36:56,688
..

2335
01:36:56,688 --> 01:36:58,348
当别人喜欢我时，我总是无法理解

2336
01:36:58,348 --> 01:36:59,908
我猜对了，所以我得到了。

2337
01:36:59,908 --> 01:36:59,958
..

2338
01:36:59,958 --> 01:37:01,621
我儿子也是这样，因为他们都是如此。

2339
01:37:01,621 --> 01:37:01,718
..

2340
01:37:01,718 --> 01:37:04,408
他们果然一脉相承，我还给他买了件 T 恤，上面写着

2341
01:37:04,408 --> 01:37:07,652
"如果你想追我，请明确告诉我，因为我完全不懂暗示。"

2342
01:37:07,652 --> 01:37:09,788
对我来说也是如此

2343
01:37:09,788 --> 01:37:21,928
我的意思是，我不得不长期存在并慢慢赢得人们的喜爱，因为我缺乏社交技巧，无法参与那些社交场合所需的舞蹈之类的活动，所以我唯一的选择就是做真实的自己，而这确实对某些人有效。

2344
01:37:21,928 --> 01:37:23,494
你是否能够说出类似"我不..."这样的话。

2345
01:37:23,494 --> 01:37:23,572
..

2346
01:37:23,572 --> 01:37:23,651
"

2347
01:37:23,651 --> 01:37:23,730
..

2348
01:37:23,730 --> 01:37:26,140
像是“我爱你”之类的话。

2349
01:37:26,140 --> 01:37:26,740
是的。

2350
01:37:26,740 --> 01:37:30,080
呃，我是说，她家人在表达这方面比我家人开放多了。

2351
01:37:30,080 --> 01:37:30,130
是的。

2352
01:37:30,130 --> 01:37:32,000
所以那段时间对我来说是成长阶段。

2353
01:37:32,000 --> 01:37:33,880
不过现在这对我来说完全不是问题。

2354
01:37:33,880 --> 01:37:34,840
好的。

2355
01:37:34,840 --> 01:37:35,820
好的。

2356
01:37:35,820 --> 01:37:38,130
但是，但这似乎并不重要，呃

2357
01:37:38,130 --> 01:37:40,320
这实际上能实现什么呢？

2358
01:37:40,320 --> 01:37:44,559
现在我们要做很多确认和检查工作。

2359
01:37:44,559 --> 01:37:46,000
比如，在过去几年里

2360
01:37:46,000 --> 01:37:47,340
我们之间有个默契，她会突然来一句

2361
01:37:47,340 --> 01:37:47,875
“你还好吗？”

2362
01:37:47,875 --> 01:37:48,955
我就回：“嗯。”

2363
01:37:48,955 --> 01:37:50,180
这背后其实有两层含义。

2364
01:37:50,180 --> 01:37:50,996
有那种“你还好吗？”的问候

2365
01:37:50,996 --> 01:37:52,160
然后就是我的回应

2366
01:37:52,160 --> 01:37:55,420
因为如果我回答“嗯...”她就能察觉不对劲

2367
01:37:55,420 --> 01:37:55,760
是的。

2368
01:37:55,760 --> 01:38:01,300
所以——这种来回试探总是存在，毕竟没法光靠看就读懂别人的心思

2369
01:38:01,300 --> 01:38:03,500
所以我们有这个明确的检查机制，我认为

2370
01:38:03,500 --> 01:38:04,380
我们——是的。

2371
01:38:04,380 --> 01:38:04,390
.

2372
01:38:04,390 --> 01:38:04,390
..

2373
01:38:04,390 --> 01:38:05,760
开发那个。

2374
01:38:05,760 --> 01:38:09,070
所以在"是的"和"嗯"之间存在着巨大的鸿沟。

2375
01:38:09,070 --> 01:38:09,700
嗯哼。

2376
01:38:09,700 --> 01:38:14,000
人类交流中那种微妙的感受又来了。

2377
01:38:14,000 --> 01:38:17,080
呃，你曾经写过那种体验

2378
01:38:17,080 --> 01:38:21,400
就是人们常说的那种感觉

2379
01:38:21,400 --> 01:38:23,407
"有点自闭症倾向"。

2380
01:38:23,407 --> 01:38:25,480
你能详细阐述一下这个概念吗？

2381
01:38:25,480 --> 01:38:26,980
是的，我认为很多人

2382
01:38:26,980 --> 01:38:30,500
大约 10%到 20%的人口，在某种程度上属于自闭症谱系

2383
01:38:30,500 --> 01:38:33,850
但受影响程度尚未达到障碍的标准。

2384
01:38:33,850 --> 01:38:37,600
但他们仍具有许多源于自闭症的特征。

2385
01:38:37,600 --> 01:38:42,780
我认为如果他们能够以最佳方式理解、识别并管理其中一些行为

2386
01:38:42,780 --> 01:38:49,240
他们就能既利用这些特征发挥某些技能优势，又能调解随之而来的缺陷和问题。

2387
01:38:49,240 --> 01:38:52,130
而我写这本书主要是为了我的孩子们，因为他们中没有人

2388
01:38:52,130 --> 01:38:54,200
据我所知，患有自闭症谱系障碍

2389
01:38:54,200 --> 01:38:58,500
但他们的某些行为特征与我特别相似

2390
01:38:58,500 --> 01:39:02,200
所以我想为他们写个小指南

2391
01:39:02,200 --> 01:39:02,230
嗯。

2392
01:39:02,230 --> 01:39:05,230
为什么你认为这么多程序员，比如优秀的

2393
01:39:05,230 --> 01:39:08,880
比如伟大的程序员和工程师，都属于自闭症谱系？

2394
01:39:08,880 --> 01:39:16,200
我认为是那种一心一意的专注力、将问题简化的能力，以及对事物本质永无止境的好奇心。

2395
01:39:16,200 --> 01:39:18,380
这已成为我毕生的执念

2396
01:39:18,380 --> 01:39:18,960
里面有什么。

2397
01:39:18,960 --> 01:39:22,740
我得把我妈妈的烤箱拆开，因为我想知道翻转时钟是怎么工作的。

2398
01:39:22,740 --> 01:39:26,960
嗯，我觉得如果你想成为一名程序员，这是个好习惯。

2399
01:39:26,960 --> 01:39:29,960
而且愿意、甚至兴奋地去深入了解细节。

2400
01:39:29,960 --> 01:39:30,460
是的。

2401
01:39:30,460 --> 01:39:31,340
是的。

2402
01:39:31,340 --> 01:39:32,710
呃，你有什么很酷的东西可以，呃

2403
01:39:32,710 --> 01:39:34,640
今年希望编程实现什么项目？

2404
01:39:34,640 --> 01:39:35,240
你在忙什么？

2405
01:39:35,240 --> 01:39:39,700
所以我们让强化学习算法学会了玩《暴风》游戏。

2406
01:39:39,700 --> 01:39:40,880
呃，顺便问一下，你那边进展到什么程度了？

2407
01:39:40,880 --> 01:39:45,240
比如到了哪个阶段，预计什么时候能成功并占据主导地位？

2408
01:39:45,240 --> 01:39:47,800
是说胜利在望吗？

2409
01:39:47,800 --> 01:39:49,340
嗯，已经非常接近成功了。

2410
01:39:49,340 --> 01:39:54,700
呃，我觉得现在是在调整模型大小和层数之类的参数，让它能突破那个学习阈值。

2411
01:39:54,700 --> 01:39:59,820
不过你知道的，这几千行 Lua 代码和几千行 Python 代码相互配合，运行得都挺好。

2412
01:39:59,820 --> 01:40:01,760
所以现在 95%的工作已经完成了

2413
01:40:01,760 --> 01:40:04,660
主要就是在调超参数，然后祈祷能有最好的效果。

2414
01:40:04,660 --> 01:40:06,200
从某种意义上说，这已经算是成功了

2415
01:40:06,200 --> 01:40:08,820
但现在的问题是，它究竟能走多远？

2416
01:40:08,820 --> 01:40:11,080
是的，我的目标是让它能够打败我。

2417
01:40:11,080 --> 01:40:13,242
这确实是个艰巨的挑战。

2418
01:40:13,242 --> 01:40:13,490
..

2419
01:40:13,490 --> 01:40:15,360
因为-确实如此，但现在很多游戏

2420
01:40:15,360 --> 01:40:17,220
你知道的，AI 玩得比人类还好

2421
01:40:17,220 --> 01:40:19,100
但可能还没达到这种复杂度的游戏

2422
01:40:19,100 --> 01:40:20,960
呃，你还在研究什么其他很酷的东西吗？

2423
01:40:20,960 --> 01:40:22,240
你今年希望打造些什么？

2424
01:40:22,240 --> 01:40:23,700
呃，PDP-11 相关的东西。

2425
01:40:23,700 --> 01:40:26,120
我正在尝试获取一个叫做 RA82 的驱动器。

2426
01:40:26,120 --> 01:40:28,700
就是那个 14 英寸的大家伙，转速能达到 3

2427
01:40:28,700 --> 01:40:30,530
600 转每分钟，听起来像台洗衣机。

2428
01:40:30,530 --> 01:40:35,930
然后我会找到控制器卡，编写代码，集成到驱动程序中，并尝试让这一切正常运行。

2429
01:40:35,930 --> 01:40:38,090
呃，你想在上面运行什么样的代码？

2430
01:40:38,090 --> 01:40:40,700
我得让驱动堆栈正常工作

2431
01:40:40,700 --> 01:40:43,220
所以我需要将其驱动程序集成到内核中。

2432
01:40:43,220 --> 01:40:46,700
你最近组装了一台内存高达 1TB 的机器。

2433
01:40:46,700 --> 01:40:52,160
呃，这是怎么做到的？为什么要这么配置？

2434
01:40:52,160 --> 01:40:54,580
呃...我们有个叫 GitHub Primes 的项目。

2435
01:40:54,580 --> 01:40:56,010
如果你直接搜索 GitHub Primes，你会

2436
01:40:56,010 --> 01:40:57,780
找到它，它就是 GitHub Primes。

2437
01:40:57,780 --> 01:40:57,790
.

2438
01:40:57,790 --> 01:40:57,790
..

2439
01:40:57,790 --> 01:41:03,300
这是一套用大约 100 种不同语言实现的素数算法集合。

2440
01:41:03,300 --> 01:41:07,580
所以这是完全相同的算法，我们要求你遵守特定规则以保证公平性。

2441
01:41:07,580 --> 01:41:08,000
嗯哼。

2442
01:41:08,000 --> 01:41:12,320
然后你尽己所能地用选择的语言来表达这个算法。

2443
01:41:12,320 --> 01:41:16,820
我们每晚都进行基准测试，汇总结果并找出哪些语言运行最快。

2444
01:41:16,820 --> 01:41:17,540
是这个吗？

2445
01:41:17,540 --> 01:41:18,300
是的。

2446
01:41:18,300 --> 01:41:19,760
哦，所以这个，呃，对的

2447
01:41:19,760 --> 01:41:20,425
明白了。

2448
01:41:20,425 --> 01:41:20,670
..

2449
01:41:20,670 --> 01:41:23,559
你正在用这个做什么？

2450
01:41:23,559 --> 01:41:24,820
是的。

2451
01:41:24,820 --> 01:41:25,710
哦，所以-所以-

2452
01:41:25,710 --> 01:41:25,710
..

2453
01:41:25,710 --> 01:41:28,040
这台机器运行那些测试吗？

2454
01:41:28,040 --> 01:41:28,980
是的。

2455
01:41:28,980 --> 01:41:29,220
好的。

2456
01:41:29,220 --> 01:41:30,440
你得跟我讲讲这个项目。

2457
01:41:30,440 --> 01:41:31,530
这是一个史诗级的项目。

2458
01:41:31,530 --> 01:41:34,150
所以你是在比较不同编程语言的性能。

2459
01:41:34,150 --> 01:41:34,960
在所有这些语言中。

2460
01:41:34,960 --> 01:41:37,200
它们都被构建到独立的 Docker 容器中

2461
01:41:37,200 --> 01:41:38,370
然后它们就都运行起来了。

2462
01:41:38,370 --> 01:41:40,220
这——这真是个了不起的项目。

2463
01:41:40,220 --> 01:41:41,720
这真的非常非常酷。

2464
01:41:41,720 --> 01:41:44,180
它实际上是在测量不同语言的性能表现。

2465
01:41:44,180 --> 01:41:46,780
那又怎样，你了解到哪些编程语言了？

2466
01:41:46,780 --> 01:41:51,300
呃，比如谁，哪种语言通常会胜出？

2467
01:41:51,300 --> 01:41:52,640
Zig，我觉得目前是它。

2468
01:41:52,640 --> 01:41:53,000
Zig。

2469
01:41:53,000 --> 01:41:54,000
确实，情况会变化。

2470
01:41:54,000 --> 01:41:55,769
人们会对 C++进行改进

2471
01:41:55,769 --> 01:41:59,180
然后会平静一段时间，接着 Zig 的支持者们会不满并卷土重来，让它变得更快。

2472
01:41:59,180 --> 01:42:02,840
那么 Zig、Rust、C++、C 的排序是？

2473
01:42:02,840 --> 01:42:03,360
是的。

2474
01:42:03,360 --> 01:42:05,220
运行的是哪种代码？

2475
01:42:05,220 --> 01:42:10,500
他们试图运行哪段代码来测量性能？

2476
01:42:10,500 --> 01:42:17,220
他们的做法是在一个五秒循环内，尽可能多次地求解一亿以内的质数。

2477
01:42:17,220 --> 01:42:18,280
所以这是一个循环。

2478
01:42:18,280 --> 01:42:18,630
明白了。

2479
01:42:18,630 --> 01:42:19,690
一遍又一遍，反复不停。

2480
01:42:19,690 --> 01:42:21,070
是的，所有核心都是。

2481
01:42:21,070 --> 01:42:22,540
所以呢？所有 CPU 上都是。

2482
01:42:22,540 --> 01:42:22,562
.

2483
01:42:22,562 --> 01:42:22,570
..

2484
01:42:22,570 --> 01:42:25,000
这个程序是怎么编写的呢？

2485
01:42:25,000 --> 01:42:25,960
编写方式会有不同吗？

2486
01:42:25,960 --> 01:42:26,260
不算。

2487
01:42:26,260 --> 01:42:29,019
你可以自由实现，但必须是个素数筛算法。

2488
01:42:29,019 --> 01:42:31,580
最多允许每个整数使用一个比特位。

2489
01:42:31,580 --> 01:42:33,380
所以你无法使用更便宜且更简单的字节。

2490
01:42:33,380 --> 01:42:34,000
嗯哼。

2491
01:42:34,000 --> 01:42:38,220
嗯，有一系列这样的规则要求你必须在定时循环内分配内存。

2492
01:42:38,220 --> 01:42:40,600
因此我们有一套规则，同时也有

2493
01:42:40,600 --> 01:42:45,400
呃，一些不遵循规则的解决方案，比如 6502 处理器，因为它只有 64K 内存。

2494
01:42:45,400 --> 01:42:47,220
你无法完成 1 亿次筛选。

2495
01:42:47,220 --> 01:42:50,640
因此，我们有很多这样的解决方案作为展示项目运行。

2496
01:42:50,640 --> 01:42:53,200
但在主要语言中，它们都遵循相同的规则。

2497
01:42:53,200 --> 01:42:57,820
所以实际上应该只是算法在该语言中的表达方式。

2498
01:42:57,820 --> 01:42:59,920
它们中的许多使用相同的后端编译器

2499
01:42:59,920 --> 01:43:04,160
所以这实际上取决于你如何表达以及该语言的限制或优势。

2500
01:43:04,160 --> 01:43:07,019
呃，每种语言允许多次提交吗？

2501
01:43:07,019 --> 01:43:07,220
是的。

2502
01:43:07,220 --> 01:43:07,660
是的。

2503
01:43:07,660 --> 01:43:08,920
所以如果你查看 C 语言的

2504
01:43:08,920 --> 01:43:10,280
大概有五个吧，我想。

2505
01:43:10,280 --> 01:43:10,980
好的。

2506
01:43:10,980 --> 01:43:14,460
它们...它们中有些可能使用不同的编译器吧？

2507
01:43:14,460 --> 01:43:14,690
是的。

2508
01:43:14,690 --> 01:43:17,100
有的是 GCC，有的是 Clang，LLVM。

2509
01:43:17,100 --> 01:43:19,170
我正在看几年前的快照数据。

2510
01:43:19,170 --> 01:43:20,549
Zig 位居榜首，其次是 Rust

2511
01:43:20,549 --> 01:43:21,800
然后是 Nim 和 Haskell

2512
01:43:21,800 --> 01:43:26,180
哦不，这个排序并不是

2513
01:43:26,180 --> 01:43:27,600
呃，按速度慢来排的？还是说就是？

2514
01:43:27,600 --> 01:43:28,220
是的。

2515
01:43:28,220 --> 01:43:29,400
这样 C 就等于 1。

2516
01:43:29,400 --> 01:43:31,461
比 Zig 长 5 倍。

2517
01:43:31,461 --> 01:43:32,742
哇。

2518
01:43:32,742 --> 01:43:34,332
好的，真有意思。

2519
01:43:34,332 --> 01:43:36,172
这是个非常棒的项目。

2520
01:43:36,172 --> 01:43:38,212
是啊，我们还有像 PowerShell 这种疯狂的语言。

2521
01:43:38,212 --> 01:43:40,712
有 PowerShell 的版本之类的工具

2522
01:43:40,712 --> 01:43:40,990
所以...

2523
01:43:40,990 --> 01:43:41,122
..

2524
01:43:41,122 --> 01:43:43,912
所以这个流程是自动化的，比如在组织管理方面

2525
01:43:43,912 --> 01:43:45,242
像是提交操作的处理方式

2526
01:43:45,242 --> 01:43:46,312
它是有结构的。

2527
01:43:46,312 --> 01:43:47,192
这很酷。

2528
01:43:47,192 --> 01:43:49,292
是的，有两个人在那边，呃

2529
01:43:49,292 --> 01:43:52,472
欧洲那边，呃，Rucker 和 Tudor，现在基本上拥有这个。

2530
01:43:52,472 --> 01:43:53,962
最初我只支持三种语言。

2531
01:43:53,962 --> 01:43:56,692
我实现了 Python、C#和 C++的版本。

2532
01:43:56,692 --> 01:43:58,632
我提交了代码并发布了这一集。

2533
01:43:58,632 --> 01:44:01,042
随后人们开始提交更多解决方案

2534
01:44:01,042 --> 01:44:02,032
结果事情就失控了。

2535
01:44:02,032 --> 01:44:03,332
所以我不得不找人专门管理那个项目

2536
01:44:03,332 --> 01:44:05,732
他们帮我做得非常出色。

2537
01:44:05,732 --> 01:44:09,152
编程和构建项目时，最让你感到快乐的时刻是什么？

2538
01:44:09,152 --> 01:44:11,072
你最喜欢什么？

2539
01:44:11,072 --> 01:44:15,892
对我来说，最有意思的是当我构建了一个复杂的东西，并且已经想好了它应该如何运作

2540
01:44:15,892 --> 01:44:18,892
然后我运行它，它确实按照预期工作了。

2541
01:44:18,892 --> 01:44:19,202
嗯哼。

2542
01:44:19,202 --> 01:44:22,152
这带来了极大的满足感。

2543
01:44:22,152 --> 01:44:26,412
看到结果如我所计划的那样呈现并成功运行

2544
01:44:26,412 --> 01:44:28,258
因为这很少能一次就成功，但是。

2545
01:44:28,258 --> 01:44:28,462
..

2546
01:44:28,462 --> 01:44:29,362
是的。

2547
01:44:29,362 --> 01:44:32,262
或者说如果真的一次就成功了——不，我从不相信这种情况。

2548
01:44:32,262 --> 01:44:33,942
我总觉得自己遗漏了什么。

2549
01:44:33,942 --> 01:44:35,512
确实如此。

2550
01:44:35,512 --> 01:44:38,712
呃，但是，你知道，对于像

2551
01:44:38,712 --> 01:44:40,932
嗯，呃，C++ 这样的编译型语言，这种感觉总是挺好的。

2552
01:44:40,932 --> 01:44:43,002
你写一大堆代码然后编译

2553
01:44:43,002 --> 01:44:45,772
所有代码都能无警告、无错误地编译通过。

2554
01:44:45,772 --> 01:44:47,512
这种感觉很棒。

2555
01:44:47,512 --> 01:44:50,912
嗯，你-你认为编程的未来会是什么样子？

2556
01:44:50,912 --> 01:44:55,632
所以现在，我不知道你实际体验了多少这种影响

2557
01:44:55,632 --> 01:44:59,472
嗯，具备代码生成能力的 LLMs

2558
01:44:59,472 --> 01:45:01,072
你经常用 Cursor 吗？或者说用过很多次吗？

2559
01:45:01,072 --> 01:45:05,492
Cursor VS Code，那个，呃，带-带-带代码生成功能的？

2560
01:45:05,492 --> 01:45:06,852
是啊，这方面我做过大量实践

2561
01:45:06,852 --> 01:45:09,982
呃，Python 方面，因为我对 Python 不太在行，算是刚入门。

2562
01:45:09,982 --> 01:45:16,612
所以，嗯，我觉得它非常有用，因为通过观察它生成的代码，我学到了很多——尤其是当我不懂如何实现某些功能时。

2563
01:45:16,612 --> 01:45:18,252
因为如果让我从零开始写 Python 代码

2564
01:45:18,252 --> 01:45:21,732
写出来的长度大概是 AI 生成代码的四倍

2565
01:45:21,732 --> 01:45:24,012
因为如果你精通 Python 的话，代码可以写得很简洁。

2566
01:45:24,012 --> 01:45:24,452
哦，那很酷啊。

2567
01:45:24,452 --> 01:45:27,912
所以你是专门为这个项目学的 Python？

2568
01:45:27,912 --> 01:45:28,062
是的。

2569
01:45:28,062 --> 01:45:31,402
这真是个不错的案例研究，展示了

2570
01:45:31,402 --> 01:45:36,592
就像一位优秀的 C++程序员，能快速掌握一门新语言。

2571
01:45:36,592 --> 01:45:37,992
是啊，我正在凭感觉摸索着写代码

2572
01:45:37,992 --> 01:45:38,122
我想是吧。

2573
01:45:38,122 --> 01:45:40,572
靠感觉摸索着写代码。

2574
01:45:40,572 --> 01:45:43,661
我是说，这确实是学习语言的绝佳应用场景

2575
01:45:43,661 --> 01:45:46,382
如果你已经是个不错的程序员，可以通过这种方式学习

2576
01:45:46,382 --> 01:45:49,712
呃，一门新语言或者一种新

2577
01:45:49,712 --> 01:45:52,582
呃，通过生成代码来解决问题的思路

2578
01:45:52,582 --> 01:45:53,256
因为你已经。

2579
01:45:53,256 --> 01:45:53,342
..

2580
01:45:53,342 --> 01:45:55,372
你大概能看懂它生成的 Python 代码。

2581
01:45:55,372 --> 01:45:56,322
是的。

2582
01:45:56,322 --> 01:45:58,982
比如，不用真的去查任何语法。

2583
01:45:58,982 --> 01:46:00,832
是啊，一旦看到就都一目了然了。

2584
01:46:00,832 --> 01:46:02,952
不过，你知道的，从零开始创造还是有些不同的

2585
01:46:02,952 --> 01:46:03,396
所以...

2586
01:46:03,396 --> 01:46:03,652
..

2587
01:46:03,652 --> 01:46:08,772
是啊，呃，但要想那样使用它，你还是得学会怎么编程才行

2588
01:46:08,772 --> 01:46:11,472
哦，还要能读懂代码，知道接下来该让它做什么之类的

2589
01:46:11,472 --> 01:46:12,082
是的。

2590
01:46:12,082 --> 01:46:15,932
我觉得如果你是个完全没编过程序的新手，光靠感觉是写不出代码的

2591
01:46:15,932 --> 01:46:19,412
但如果你是个优秀的程序员，AI 能让你变得无比强大。

2592
01:46:19,412 --> 01:46:20,781
你认为编程的未来会怎样

2593
01:46:20,781 --> 01:46:22,682
比如 5 年、10 年、20 年后

2594
01:46:22,682 --> 01:46:24,312
这整个发展过程？

2595
01:46:24,312 --> 01:46:29,996
N-现在，"氛围编程"更像是个有趣的梗，因为你终究还是得...

2596
01:46:29,996 --> 01:46:30,572
..

2597
01:46:30,572 --> 01:46:37,242
呃，那些不懂编程却只搞氛围编程的人，几乎全都在开发无法投入生产环境的系统。

2598
01:46:37,242 --> 01:46:37,592
他们确实不行。

2599
01:46:37,592 --> 01:46:37,682
..

2600
01:46:37,682 --> 01:46:37,989
你做不到的。

2601
01:46:37,989 --> 01:46:38,042
..

2602
01:46:38,042 --> 01:46:38,362
这非常——没错。

2603
01:46:38,362 --> 01:46:38,362
.

2604
01:46:38,362 --> 01:46:38,362
.

2605
01:46:38,362 --> 01:46:40,552
要开发一个产——呃，产品确实很难。

2606
01:46:40,552 --> 01:46:46,692
呃，那些已经是优秀程序员的人基本上能凭直觉写出符合你需求的代码。

2607
01:46:46,692 --> 01:46:47,930
他们基本上就是这样的。

2608
01:46:47,930 --> 01:46:48,142
..

2609
01:46:48,142 --> 01:46:51,952
这不过是个花哨的自动补全功能，最终还得手动编辑

2610
01:46:51,952 --> 01:46:56,462
或者是学习新 API、新语言或其他新东西的一种方式

2611
01:46:56,462 --> 01:46:59,532
嗯，一个针对特定用途的新用例，可能是

2612
01:46:59,532 --> 01:47:03,492
某种不同的图形界面组件之类的东西

2613
01:47:03,492 --> 01:47:07,212
但随着它们变得越来越智能，我们不知道上限在哪里。

2614
01:47:07,212 --> 01:47:10,272
这可能会改变程序员这一职业的本质。

2615
01:47:10,272 --> 01:47:12,392
那么，呃，你有考虑过这个问题吗？

2616
01:47:12,392 --> 01:47:12,832
我同意。

2617
01:47:12,832 --> 01:47:13,593
我认为。

2618
01:47:13,593 --> 01:47:13,781
..

2619
01:47:13,781 --> 01:47:19,752
我不想说是提示词工程师，但我觉得未来可能会类似这种情况——就像如果你是建造桥梁的建筑师

2620
01:47:19,752 --> 01:47:22,492
曾经，工人们需要在现场焊接钢梁

2621
01:47:22,492 --> 01:47:27,332
但现在你只需在 AutoCAD 中拖拽元素，用预制的大型构件进行组装

2622
01:47:27,332 --> 01:47:28,912
我认为编程也会变成这样

2623
01:47:28,912 --> 01:47:31,412
你不再需要逐行编写代码

2624
01:47:31,412 --> 01:47:38,722
你将通过移动组件和界面，并向 AI 描述这些交互应该如何进行

2625
01:47:38,722 --> 01:47:40,672
然后让它来构建这些组件。

2626
01:47:40,672 --> 01:47:44,809
但我认为距离它能完全自主生成还有相当长的路要走。

2627
01:47:44,809 --> 01:47:44,942
..

2628
01:47:44,942 --> 01:47:47,350
你无法直接说："给我一个与 Linux 兼容的 Linux 内核"。

2629
01:47:47,350 --> 01:47:49,252
终有一天，我们能够做到，而且会高效实现

2630
01:47:49,252 --> 01:47:51,152
但目前还未能达到

2631
01:47:51,152 --> 01:47:55,812
我们如此快速地攀升抽象层级，这让你感到失落吗？

2632
01:47:55,812 --> 01:47:59,492
就像你，一个曾经编写机器码和汇编语言的人

2633
01:47:59,492 --> 01:48:07,352
然后到了 C 和 C++，我们正逐渐达到能用自然语言进行直觉编码的阶段。

2634
01:48:07,352 --> 01:48:09,832
是的，我算是赶上了特别幸运的时代

2635
01:48:09,832 --> 01:48:15,252
我想这是因为我必须经历 30 到 40 年技术发展的全过程。

2636
01:48:15,252 --> 01:48:19,272
所以我既懂 TTL 逻辑电路，也能用 AI 来编写代码

2637
01:48:19,272 --> 01:48:21,062
而且我大概知道中间的各个环节。

2638
01:48:21,062 --> 01:48:23,082
我的知识中确实存在一些空白。

2639
01:48:23,082 --> 01:48:29,092
但我认为，要获得那种程度的知识或完整的图景，唯一的方法就是长期沉浸其中。

2640
01:48:29,092 --> 01:48:29,632
是的。

2641
01:48:29,632 --> 01:48:32,592
对于现在刚开始的人来说，要复制这种经验将会很困难。

2642
01:48:32,592 --> 01:48:34,072
你觉得这一切的意义是什么

2643
01:48:34,072 --> 01:48:41,912
呃，关于生命的存在，关于这里发生的一切？

2644
01:48:41,912 --> 01:48:46,812
创造很酷的东西。

2645
01:48:46,812 --> 01:48:53,252
我想，从根本上说，我在乎的是能够创造出对他人有用的复杂事物

2646
01:48:53,252 --> 01:49:02,572
《沉浸式翻译》充分发挥了我的能力，让我能够以创造性的方式开发出可供他人使用的工具。这种创作自由度，若仅限于绘画或雕塑等传统艺术形式，是难以企及的

2647
01:49:02,572 --> 01:49:05,152
在古典艺术方面，我毫无天赋。

2648
01:49:05,152 --> 01:49:10,412
对我来说，这就是生命真正的意义。

2649
01:49:10,412 --> 01:49:14,122
然后，也许你培养了几个优秀的孩子来传递接力棒。

2650
01:49:14,122 --> 01:49:16,152
是的。

2651
01:49:16,152 --> 01:49:21,352
而你这一生创造了不少很酷的东西

2652
01:49:21,352 --> 01:49:25,662
影响了数百万人，甚至可能是数十亿人。

2653
01:49:25,662 --> 01:49:28,340
如今你正在激励着更多人。

2654
01:49:28,340 --> 01:49:28,442
..

2655
01:49:28,442 --> 01:49:34,212
你在 YouTube 上创作精彩内容供大家观赏，正以这种方式激励着人们。

2656
01:49:34,212 --> 01:49:37,592
因此，对你过去所做的一切以及现在正在做的一切

2657
01:49:37,592 --> 01:49:38,972
我非- 我是你的超级粉丝。

2658
01:49:38,972 --> 01:49:40,202
我真的很感激- 太棒了。

2659
01:49:40,202 --> 01:49:40,275
.

2660
01:49:40,275 --> 01:49:40,282
..

2661
01:49:40,282 --> 01:49:44,222
感谢你所做的一切，也很高兴我们今天有机会交流。

2662
01:49:44,222 --> 01:49:44,872
谢谢你，兄弟。

2663
01:49:44,872 --> 01:49:46,752
谢谢。

2664
01:49:46,752 --> 01:49:49,192
感谢收听与 Dave Plummer 的这次对话。

2665
01:49:49,192 --> 01:49:52,612
如需支持本播客，请查看简介中的赞助商信息。

2666
01:49:52,612 --> 01:49:57,192
现在，让我用 C++之父比雅尼·斯特劳斯特鲁普的话作为结束

2667
01:49:57,192 --> 01:50:00,452
顺便说一句，这位正是

2668
01:50:00,452 --> 01:50:04,072
我在很久很久以前采访过的人物

2669
01:50:04,072 --> 01:50:07,592
播客第 48 期的嘉宾。

2670
01:50:07,592 --> 01:50:16,602
他说："世界上只有两种语言：一种是被人抱怨的，另一种是没人使用的。"

2671
01:50:16,602 --> 01:50:23,212
"感谢您的聆听，期待下次再见。"

