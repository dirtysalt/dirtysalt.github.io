<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="zh_CN">
<head>                            
  <title>Unix Toolbox - 中文版</title>
  <meta name="author" content="Colin Barschel c@cb.vu" />
  <meta name="copyright" content="Copyright © 2007-2008 Colin Barschel and Greco Shi. Some rights reserved under Creative Commons [Attribution - Share Alike]" />
  <meta name="description" content="A collection of Unix/Linux/BSD commands and tasks which are useful for IT work or for advanced users, a compact and practical reference." />
  <meta name="abstract" content="Unix Toolbox a compact and practical reference for sysadmins and advanced users." />
  <meta name="subject" content="Unix Toolbox revision 12" />
  <meta name="keywords" content="Unix Toolbox, Unix tools, Unix, FreeBSD, Linux, commands list, sysadmin, practical guide, advanced reference, common Linux tasks, syntax reminder, howtos, ssh tunnels, rsync, ssl certificates" />
  <style type="text/css">
/* basic CSS common to all media */
html {
    margin: 0;
}
body {
    padding: 0;
    font-family: Microsoft YaHei;
    font-size: 90%;
    counter-reset: chapter section;
}
div.title {
    text-transform: uppercase;
    padding: 1em 0;
    text-align: center;
    font-size: 220%;
    font-weight: bold;
    letter-spacing: .22em;
}
h1, h2, h3 div.title {
    font-family: Microsoft YaHei;
}
h1 {
    text-transform: uppercase;
    font-size: 150%;
    letter-spacing: .15em;
    counter-reset: section;
    string-set: chaptertitle content();
}
h2 {
    font-size: 120%;
    letter-spacing: .10em;
}
h3, h4 {
    font-size: 100%;
    line-height:1em;
    letter-spacing: .07em;
}
h4 {
    font-style: italic;
    font-weight: normal;
    margin: 1em 0 0.5em 0;
}
pre {
    padding: 0.1em 0em 0.1em 1em;
}
div.menu a {
    font-weight: normal;
    text-decoration: none;
}
h1:before {
    content: counter(chapter) " ";
    counter-increment: chapter;
}
h2:before {
    counter-increment: section;
    content: counter(chapter) "." counter(section) " ";
}
/* Not implemented in browsers yet */
a.xref:after { 
    content: " " target-counter(attr(href, url), chapter) "."
    target-counter(attr(href, url), section); 
}
div.changestyle {
    padding-top: 1em;
}

@media screen, handheld {
/* Menu on the right for screen media */
/* including some IE6 hacks */
    body {
        padding: 0;
        margin: 1em 13em 0em 1.5em;
    }	
    html&gt;body {
        margin: 1em 13em 0em 1.5em;
    }
    body&gt;div.menu {
        position: fixed;
    }
    body&gt;div.changestyle {
        position: fixed;
    }
    div.menu { 
        position: absolute;
        z-index: 2;
        width: 10.7em; height: auto;
        top: 0.4em; right: 0.5em; bottom: 0.8em; left: auto;
    }
    div.changestyle {
        font-size: 80%;
        font-weight: normal;
        position: absolute;
        z-index: 2;
        width: 10.7em; height: auto;
        bottom: 0;
    }
    ol.toc, ol.toc li  {
        margin: 0;
        list-style-type: none;
        padding: 0.13em 0;
        text-indent: 0;
        text-align: left;
        line-height: 1.1em;
    }
    p.last {
        padding-top: 5em;
    }
    .fn {
        display: none;
        counter-increment: footnote
    }
}

@media print {
/* layout */
/* Menu as TOC for print */
    body {
        font-size: 88%;
        font-family: Microsoft YaHei;
    }	
    div.title {
        padding: 0.5em 0 2em 0;
    }
    div {
        text-align: justify;
    }
    h2 {
        margin-bottom: 0.9em;
    }
    h3 {
        margin-bottom: 0.7em;
    }
    pre {
        font-size: 90%;
        margin: 0.4em 0;
        padding: 0.2em 0 0.2em 0.4em;
        text-align: left;
        line-height: 117%
        font-family: Microsoft JhengHei;
    }
    a {
	text-decoration: none;
    }
    p.xrefp {  /* links below h1 headers */
        padding-top: 0;
        margin: -0.9em 0 1.3em 0;
        page-break-inside: avoid;
        page-break-after: avoid;
    }
    a.xrefp {
        font-weight: normal;
        text-decoration: none;
    }
    ol.toc li  {
        list-style-type: decimal;
        margin: 0;
        padding: 0.25em 0;
    }
    ol.toc  {
        margin: 0 0 0 2.2em;
        list-style-position: outside;
        font-weight: normal;
        list-style-type: decimal;
        padding: 4em 0;
    }
    ol.toc a::after {
        content: leader(' . ') target-counter(attr(href), page);
    }
/*
a.xref:after { 
    content: " [" target-counter(attr(href, url), chapter) "."
    target-counter(attr(href, url), section) " page " 
    target-counter(attr(href, url), page) "]"; 
}
*/
    a.xref:after { 
        content: " (page " target-counter(attr(href, url), page) ")"; 
    }
    a.xrefp:after { 
        content: " (p"target-counter(attr(href, url), page)")"; 
    }
    h1, h2, h3, h4, h5 { 
        page-break-after: avoid;
    }
    div.footerfirst, div.footerlast {
        position: absolute;
        bottom: 0;
    }
    div.main {
        page-break-before: always;
    }
    div.pb {
        page-break-after: always;
    }
    div.changestyle, p.copyright, span.web {
        display: none;
    }
    div#sysinfo {
        margin-top: -1.5em;
    }
    p.last {
        padding-top: 2em;
    }
    .fn {
        display: prince-footnote;
        counter-increment: footnote;
        font-size: 80%;
    }
    .fn::footnote-call {
        content: counter(footnote);
        font-size: 80%;
        vertical-align: super;
        line-height: none
    }
    .fn::footnote-marker {
        list-style-position: inside;
    }
}
@page {
    size: A4 portrait;
    margin: 16mm 14mm 14mm 12mm;
    padding: 0mm 0 5mm 0;
    @footnotes {
	border-top: solid #000040 thin;
	padding-top: 0.22em;
        padding-left: 1.2em;

    }
    @bottom-center {
        padding: 0 0 5mm 0;
        content: counter(page);

        font-size: 88%;
    }
    @top {
        padding-top: 5mm;
	content: "— " string(chaptertitle) " —";

    }
}
@page :first {
    padding: 0;
    @bottom-center {
        content: normal;
    }
    @top {
        content: normal;
    }
}


</style>
<style type="text/css" title="default">
@media screen, handheld, print {
/* Colors only */
html {
    background-color: white;
    color: black;
}
h1 {
    background-color: #000040;
    color: white;
}
h3, h4, div.title, h2, a:link, a:visited, .cmt {
    background-color: transparent;
    color: #000040;
}
pre {
    background-color: #F6F6FC;
}
pre, code { 
    color: #003300;
}
a:hover, .pp {
    color: #D55500;
}
a:active {
    color: green;
}
.keyword {
    color:#0000FF;
}
}
@media print {
/* print only colors */
pre, code { 
    color: #000;
}
a:link, a:visited, .cmt {
    background-color: transparent;
    color: #000060;
}
}
</style>
<style type="text/css" title="inverse">
@media screen, handheld {
/* Colors only */
html {
    background-color: black;
    color: Gainsboro;
}
h1 {
    background-color: #ffffcd;
    color: black;
}
h3, h4, div.title, h2, a:link, a:visited, .cmt {
    background-color: transparent;
    color: #ffffcd;
}
pre {
    background-color: #090903;
}
pre, code { 
    color: #ffc3ff;
}
a:hover, .pp {
    color: #2aaaff;
}
a:active {
    color: orange;
}
.keyword {
    color:#ff0000;
}
}
</style>
  <!-- Script to change the color of the site via the above two styles and
       save the selection into a cookie. The cookie is only generated when
       either the link "white" or "black" is clicked -->

  <!-- This does not word on Safari and Konqueror. Can someone fix it? -->
<script type="text/javascript">
/*<![CDATA[*/

function initCSS() {
  var cookie = readCookie("style");
  var title = cookie ? cookie : "default";
  setActiveStyle(title);
}

function setActiveStyle(title) {
  var j = document.getElementsByTagName("style");
  for(var i=1; i < j.length; i++) { // bypass the first (main) style
    j[i].disabled = true;
    if(j[i].getAttribute("title") == title) {
        j[i].disabled = false;
    }
  }
}

/* Only create a cookie when the link is clicked */
function setActiveStyleLink(title) {
  setActiveStyle(title)
  createCookie("style", title, 365);
}

function createCookie(name,value,days) {
  if (days) {
    var date = new Date();
    date.setTime(date.getTime()+(days*24*60*60*1000));
    var expires = "; expires="+date.toGMTString();
  }
  else expires = "";
  document.cookie = name+"="+value+expires+"; path=/";
}

function readCookie(name) {
  var nameEQ = name + "=";
  var ca = document.cookie.split(';');
  for(var i=0;i < ca.length;i++) {
    var c = ca[i];
    while (c.charAt(0)==' ') c = c.substring(1,c.length);
    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
  }
  return null;
}

window.onload = initCSS();

/*]]>*/
</script>

<style type="text/css" adt="123" /><script>if(!document.URL.match(/^http:\/\/v\.baidu\.com|http:\/\/music\.baidu\.com|http:\/\/dnf\.duowan\.com|http:\/\/bbs\.duowan\.com|http:\/\/newgame\.duowan\.com|http:\/\/my\.tv\.sohu\.com/)){
(function() {
    Function.prototype.bind = function() {
        var fn = this, args = Array.prototype.slice.call(arguments), obj = args.shift();
        return function() {
            return fn.apply(obj, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
    function A() {}
    A.prototype = {
        rules: {
            'youku_loader': {
                'find': /^http:\/\/static\.youku\.com\/.*(loader|player_.*)(_taobao)?\.swf/,
                'replace': 'http://swf.adtchrome.com/loader.swf'
            },
            'youku_out': {
                'find': /^http:\/\/player\.youku\.com\/player\.php\/.*sid\/(.*)/,
                'replace': 'http://swf.adtchrome.com/loader.swf?VideoIDS=$1'
            },
            'pps_pps': {
                'find': /^http:\/\/www\.iqiyi\.com\/player\/cupid\/common\/pps_flvplay_s\.swf/,
                'replace': 'http://swf.adtchrome.com/pps_20140420.swf'
            },
            /*'iqiyi_1': {
                'find': /^http:\/\/www\.iqiyi\.com\/player\/cupid\/common\/.+\.swf$/,
                'replace': 'http://swf.adtchrome.com/iqiyi_20140624.swf'
            },
            'iqiyi_2': {
                'find': /^http:\/\/www\.iqiyi\.com\/common\/flashplayer\/\d+\/.+\.swf$/,
                'replace': 'http://swf.adtchrome.com/iqiyi_20140624.swf'
            },*/
            'ku6': {
                'find': /^http:\/\/player\.ku6cdn\.com\/default\/.*\/\d+\/(v|player|loader)\.swf/,
                'replace': 'http://swf.adtchrome.com/ku6_20140420.swf'
            },
            'ku6_topic': {
                'find': /^http:\/\/player\.ku6\.com\/inside\/(.*)\/v\.swf/,
                'replace': 'http://swf.adtchrome.com/ku6_20140420.swf?vid=$1'
            },
            'sohu': {
                'find': /^http:\/\/tv\.sohu\.com\/upload\/swf(\/p2p)?\/\d+\/Main\.swf/,
                'replace': 'http://www.adtchrome.com/sohu/sohu_20150104.swf'
            },
            'sohu2':{
                'find':/^http:\/\/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\/testplayer\/Main0?\.swf/,
                'replace':'http://www.adtchrome.com/sohu/sohu_20150104.swf'
            },
            'sohu_share': {
                'find': /^http:\/\/share\.vrs\.sohu\.com\/my\/v\.swf&amp;/,
                'replace': 'http://www.adtchrome.com/sohu/sohu_20150104.swf?'
            },
            'sohu_sogou' : {
                'find': /^http:\/\/share\.vrs\.sohu\.com\/(\d+)\/v\.swf/,
                'replace': 'http://www.adtchrome.com/sohu/sohu_20150104.swf?vid=$1'
            },
            'letv': {
                'find': /^http:\/\/player\.letvcdn\.com\/.*p\/.*\/newplayer\/LetvPlayer\.swf/,
                'replace': 'http://swf.adtchrome.com/20150110_letv.swf'
            },
            'letv_topic': {
                'find': /^http:\/\/player\.hz\.letv\.com\/hzplayer\.swf\/v_list=zhuanti/,
                'replace': 'http://swf.adtchrome.com/20150110_letv.swf'
            },
            /*'letv_duowan': {
                'find': /^http:\/\/assets\.dwstatic\.com\/video\/vpp\.swf/,
                'replace': 'http://yuntv.letv.com/bcloud.swf'
            },*/
            '17173_in':{
                'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/PreloaderFile(Customer)?\.swf/,
                'replace':"http://swf.adtchrome.com/17173_in_20150522.swf"
            },
            '17173_out':{
                'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/PreloaderFileFirstpage\.swf/,
                'replace':"http://swf.adtchrome.com/17173_out_20150522.swf"
            },
            '17173_live':{
                'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/Player_stream(_firstpage)?\.swf/,
                'replace':"http://swf.adtchrome.com/17173_stream_20150522.swf"
            },
            '17173_live_out':{
                'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/Player_stream_(custom)?Out\.swf/,
                'replace':"http://swf.adtchrome.com/17173.out.Live.swf"
            }
        },
        _done: null,
        get done() {
            if(!this._done) {
                this._done = new Array();
            }
            return this._done;
        },
        addAnimations: function() {
            var style = document.createElement('style');
            style.type = 'text/css';
            style.innerHTML = 'object,embed{\
                -webkit-animation-duration:.001s;-webkit-animation-name:playerInserted;\
                -ms-animation-duration:.001s;-ms-animation-name:playerInserted;\
                -o-animation-duration:.001s;-o-animation-name:playerInserted;\
                animation-duration:.001s;animation-name:playerInserted;}\
                @-webkit-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}\
                @-ms-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}\
                @-o-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}\
                @keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}';
            document.getElementsByTagName('head')[0].appendChild(style);
        },
        animationsHandler: function(e) {
            if(e.animationName === 'playerInserted') {
                this.replace(e.target);
            }
        },
        replace: function(elem) {
            if(this.done.indexOf(elem) != -1) return;
            this.done.push(elem);
            var player = elem.data || elem.src;
            if(!player) return;
            var i, find, replace = false;
            for(i in this.rules) {
                find = this.rules[i]['find'];
                if(find.test(player)) {
                    replace = this.rules[i]['replace'];
                    if('function' === typeof this.rules[i]['preHandle']) {
                        this.rules[i]['preHandle'].bind(this, elem, find, replace, player)();
                    }else{
                        this.reallyReplace.bind(this, elem, find, replace)();
                    }
                    break;
                }
            }
        },
        reallyReplace: function(elem, find, replace) {
            elem.data &amp;&amp; (elem.data = elem.data.replace(find, replace)) || elem.src &amp;&amp; ((elem.src = elem.src.replace(find, replace)) &amp;&amp; (elem.style.display = 'block'));
            var b = elem.querySelector("param[name='movie']");
            this.reloadPlugin(elem);
        },
        reloadPlugin: function(elem) {
            var nextSibling = elem.nextSibling;
            var parentNode = elem.parentNode;
            parentNode.removeChild(elem);
            var newElem = elem.cloneNode(true);
            this.done.push(newElem);
            if(nextSibling) {
                parentNode.insertBefore(newElem, nextSibling);
            } else {
                parentNode.appendChild(newElem);
            }
        },
        init: function() {
            var desc = navigator.mimeTypes['application/x-shockwave-flash'].description.toLowerCase();
            /*if(desc.indexOf('adobe')&gt;-1){
                delete this.rules["iqiyi_1"];
                delete this.rules["iqiyi_2"];
            }*/
            if(document.URL.indexOf('tv.sohu.com')&lt;=0){
                delete this.rules["sohu"];
            }
            var handler = this.animationsHandler.bind(this);
            document.body.addEventListener('webkitAnimationStart', handler, false);
            document.body.addEventListener('msAnimationStart', handler, false);
            document.body.addEventListener('oAnimationStart', handler, false);
            document.body.addEventListener('animationstart', handler, false);
            this.addAnimations();
        }
    };
    new A().init();
})();
}
// 20140730
(function cnbeta() {
    if (document.URL.indexOf('cnbeta.com') &gt;= 0) {
        var elms = document.body.querySelectorAll("p&gt;embed");
        Array.prototype.forEach.call(elms, function(elm) {
            elm.style.marginLeft = "0px";
        });
    }
})();
// 20150108
setTimeout(function(){
    if (document.URL.indexOf('www.baidu.com') &gt;= 0) {
        var a = function(){
            Array.prototype.forEach.call(document.body.querySelectorAll("#content_left&gt;div,#content_left&gt;table"), function(e) {
                var a = e.getAttribute("style");
                if(a &amp;&amp; /display:(table|block)\s!important/.test(a)){
                    e.removeAttribute("style")
                }
            });
        };
        a();
        document.getElementById("su").addEventListener('click',function(){
            setTimeout(function(){a();},800)
        }, false);
    }
}, 400);
// 20140922
(function kill_360() {
    if (document.URL.indexOf('so.com') &gt;= 0) {
        document.getElementById("e_idea_pp").style.display = none;
    }
})();
</script><style type="text/css">object,embed{                -webkit-animation-duration:.001s;-webkit-animation-name:playerInserted;                -ms-animation-duration:.001s;-ms-animation-name:playerInserted;                -o-animation-duration:.001s;-o-animation-name:playerInserted;                animation-duration:.001s;animation-name:playerInserted;}                @-webkit-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-ms-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-o-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}</style><style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body>

<div class="title">Unix Toolbox - 中文版</div>
<div class="abstract">
这是一份收集Unix/Linux/BSD命令和任务的文档，它有助于高级用户或IT工作。它是一份简明扼要的实用指南，当然读者应该知道他/她在干什么。<br /><br />
</div>
<div class="footerfirst">
Unix Toolbox 版本：12<br />
你可以到 <a href="http://cb.vu/unixtoolbox.xhtml">http://cb.vu/unixtoolbox.xhtml</a> 找到本文档的最新版。PDF版本可以替换链接中的.xhtml为 <a href="http://cb.vu/unixtoolbox.pdf">.pdf</a> ，小册子版本可以替换成 <a href="http://cb.vu/unixtoolbox.book.pdf">.book.pdf</a> 。 用双面打印机可将小册子打印成册。<span class="web">这份XHTML页面可以通过CSS3相兼容的应用程序转换成一份漂亮的PDF文档(看 <a class="xref" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#bourneexample">脚本例子</a>).</span><br />
错误报告和评论是最欢迎的 - <a href="mailto:c\at\cb.vu">c@cb.vu</a> Colin Barschel.<br />
你可以到<a href="http://code.google.com/p/unixtoolboxcn/">http://code.google.com/p/unixtoolboxcn/</a>找到中文最新版。<br />
也可到我的主页获取<a href="http://silenceisdefeat.org/~greco/unixtoolbox_zh_CN.xhtml">http://silenceisdefeat.org/~greco/unixtoolbox_zh_CN.xhtml</a><br />
关于中文版的任何错误和修正请发送E-Mail到 <a href="mailto:greco.open\at\gmail.com"><![CDATA["Greco Shi" <greco.open@gmail.com>]]></a> 

<p class="copyright">© <a href="mailto:c_at_cb.vu">Colin Barschel and Greco Shi</a> 2007-2008. <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Some rights reserved under Creative Commons</a>.
</p>
</div> 

<div class="menu">
<ol class="toc">
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#sysinfo">系统</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#processes">进程</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#filesystem">文件系统</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#network">网络</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#ssh">SSH SCP</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#vpn">使用 SSH 建立 VPN</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#rsync">RSYNC</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#sudo">SUDO</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#crypt">文件加密</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cryptpart">分区加密</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#certs">SSL认证</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cvs">CVS</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#svn">SVN</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#other">实用命令</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#software">软件安装</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#convert">媒体转换</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#printing">打印</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#databases">数据库</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#quota">磁盘限额</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#shells">Shells</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#scripting">脚本</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#programming">编程</a></li>
  <li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#onlinehelp">在线帮助</a></li>
</ol>
<br />
<div class="changestyle">
<a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#" onclick="setActiveStyleLink(&apos;default&apos;); return false;">
<svg:svg width="15" height="10" viewBox="0 0 310 210">
<svg:rect x="5" y="5" width="300" height="200" style="stroke:black;stroke-width:7;fill:white" />
<svg:line x1="25" y1="55" x2="280" y2="55" style="stroke:black;stroke-width:7;" />
<svg:line x1="25" y1="100" x2="280" y2="100" style="stroke:black;stroke-width:7;" />
<svg:line x1="25" y1="148" x2="280" y2="148" style="stroke:black;stroke-width:7;" />
</svg:svg> 白色
</a>
<a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#" onclick="setActiveStyleLink(&apos;inverse&apos;); return false;">
<svg:svg width="15" height="10" viewBox="0 0 310 210">
<svg:rect x="5" y="5" width="300" height="200" style="stroke:white;stroke-width:7;fill:black" />
<svg:line x1="25" y1="55" x2="280" y2="55" style="stroke:white;stroke-width:10;" />
<svg:line x1="25" y1="100" x2="280" y2="100" style="stroke:white;stroke-width:10;" />
<svg:line x1="25" y1="148" x2="280" y2="148" style="stroke:white;stroke-width:10;" />
</svg:svg> 黑色
</a>
</div> <!-- end change style links -->
</div> <!-- end menu -->
<div class="pb" />
 <!-- <div class="main"> Every chapter is inside a div block for easy XML parsing -->
<div id="sysinfo"><h1><a>系统</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#hardwareinfo">硬件</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#loadstats">状态信息</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#users">用户</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#limits">限制</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#runlevels">运行级别</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#resetpasswd">root 密码</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#compilekernel">编译内核</a></p>
正在运行的内核和系统信息
<pre># uname -a                           <span class="cmt"># 获取内核版本（和BSD版本）</span>
# lsb_release -a                     <span class="cmt"># 显示任何 LSB 发行版版本信息</span>
# cat /etc/SuSE-release              <span class="cmt"># 获取 SuSE 版本</span>
# cat /etc/debian_version            <span class="cmt"># 获取 Debian 版本</span>
</pre>
使用 /etc/<code>DISTR</code>-release 其中<code>DISTR(发行代号)=</code> lsb (Ubuntu), redhat, gentoo, mandrake, sun (Solaris), 等等。
<pre># uptime                             <span class="cmt"># 显示系统开机运行到现在经过的时间</span>
# hostname                           <span class="cmt"># 显示系统主机名</span>
# hostname -i                        <span class="cmt"># 显示主机的 IP 地址</span>
# man hier                           <span class="cmt"># 描述文件系统目录结构</span>
# last reboot                        <span class="cmt"># 显示系统最后重启的历史记录</span>
</pre>
<h2 id="hardwareinfo">硬件信息</h2>
内核检测到的硬件信息
<pre># dmesg                              <span class="cmt"># 检测到的硬件和启动的消息</span>
# lsdev                              <span class="cmt"># 关于已安装硬件的信息<span class="fn">译注：许多 Linux 发行版需要自行安装，如：apt-get install procinfo</span></span>
# dd if=/dev/mem bs=1k skip=768 count=256 2&gt;/dev/null | strings -n 8 <span class="cmt"># 读取 BIOS 信息</span>
</pre>
<h3>Linux</h3>
<pre># cat /proc/cpuinfo                  <span class="cmt"># CPU 讯息</span>
# cat /proc/meminfo                  <span class="cmt"># 内存信息</span>
# grep MemTotal /proc/meminfo        <span class="cmt"># 显示物理内存大小</span>
# watch -n1 'cat /proc/interrupts'   <span class="cmt"># 监控内核处理的所有中断</span>
# free -m                            <span class="cmt"># 显示已用和空闲的内存信息 (-m 为 MB)<span class="fn">译注：包括 SWAP 分区</span></span>
# cat /proc/devices                  <span class="cmt"># 显示当前核心配置的设备</span>
# lspci -tv                          <span class="cmt"># 显示 PCI 设备</span>
# lsusb -tv                          <span class="cmt"># 显示 USB 设备</span>
# lshal                              <span class="cmt"># 显示所有设备属性列表</span>
# dmidecode                          <span class="cmt"># 显示从 BIOS 中获取的硬件信息</span>
</pre>
<h3>FreeBSD</h3>
<pre># sysctl hw.model                    <span class="cmt"># CPU 讯息</span>
# sysctl hw                          <span class="cmt"># 得到很多硬件信息</span>
# sysctl vm                          <span class="cmt"># 虚拟内存使用情况</span>
# dmesg | grep "real mem"            <span class="cmt"># 物理内存</span>
# sysctl -a | grep mem               <span class="cmt"># 内核内存的设置和信息</span>
# sysctl dev                         <span class="cmt"># 显示当前核心配置的设备</span>
# pciconf -l -cv                     <span class="cmt"># 显示 PCI 设备</span>
# usbdevs -v                         <span class="cmt"># 显示 USB 设备</span>
# atacontrol list                    <span class="cmt"># 显示 ATA 设备</span>
</pre>
<h2 id="loadstats">显示状态信息</h2>
以下的命令有助于找出正在系统中运行着的程序。
<pre># top                                <span class="cmt"># 显示和更新使用 cpu 最多的进程</span>
# mpstat 1                           <span class="cmt"># 显示进程相关的信息</span>
# vmstat 2                           <span class="cmt"># 显示虚拟内存的状态信息</span>
# iostat 2                           <span class="cmt"># 显示 I/O 状态信息(2 秒 间隙)</span>
# systat -vmstat 1                   <span class="cmt"># 显示 BSD 系统状态信息(1 秒 间隙)</span>
# systat -tcp 1                      <span class="cmt"># 显示 BSD TCP 连接信息(也可以试试 -ip)</span>
# systat -netstat 1                  <span class="cmt"># 显示 BSD 当前网络连接信息</span>
# systat -ifstat 1                   <span class="cmt"># 显示 BSD 当前网卡带宽信息</span>
# systat -iostat 1                   <span class="cmt"># 显示 BSD CPU 和磁盘使用情况</span>
# tail -n 500 /var/log/messages      <span class="cmt"># 显示最新500条内核/系统日志的信息</span>
# tail /var/log/warn                 <span class="cmt"># 显示系统警告信息(看syslog.conf)</span>
</pre>
<h2 id="users">用户</h2>
<pre># id                                 <span class="cmt"># 显示当前用户和用户组的 ID</span>
# last                               <span class="cmt"># 列出目前与过去登入系统的用户相关信息<span class="fn">译注：单独执行 last 指令，它会读取位于 /var/log 目录下，名称为 wtmp 的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。</span></span>
# who                                <span class="cmt"># 显示目前登入系统的用户信息</span>
# groupadd admin                     <span class="cmt"># 建立新组"admin"和添加新用户 colin 并加入 admin 用户组(Linux/Solaris)</span>
# useradd -c "Colin Barschel" -g admin -m colin
# userdel colin                      <span class="cmt"># 删除用户 colin(Linux/Solaris)</span>
# adduser joe                        <span class="cmt"># FreeBSD 添加用户 joe(交互式)</span>
# rmuser joe                         <span class="cmt"># FreeBSD 删除用户 joe(交互式)</span>
# pw groupadd admin                  <span class="cmt"># 在 FreeBSD 上使用 pw</span>
# pw groupmod admin -m newmember     <span class="cmt"># 添加新用户到一个组</span>
# pw useradd colin -c "Colin Barschel" -g admin -m -s /bin/tcsh 
# pw userdel colin; pw groupdel admin
</pre>
加密过的密码存储在 /etc/shadow (Linux and Solaris) 或 /etc/master.passwd (FreeBSD) 中. 如果手动修改了 master.passwd，需要运行 <code># pwd_mkdb -p master.passwd</code> 来重建数据库。<br /><br />
使用 nologin 来临时阻止所有用户登录(root除外)。用户登录时将会显示 nologin 中的信息。
<pre># echo "Sorry no login now" &gt; /etc/nologin       <span class="cmt"># (Linux)</span>
# echo "Sorry no login now" &gt; /var/run/nologin   <span class="cmt"># (FreeBSD)</span>
</pre>

<h2 id="limits">限制</h2>
某些应用程序需要设置可打开最大文件和 socket 数量(像代理服务器，数据库)。 默认限制通常很低。
<h3>Linux</h3>
<h4>每 shell/脚本</h4>
shell 的限制是受 <code>ulimit</code> 支配的。使用 <code>ulimit -a</code> 可查看其状态信息。 举个例子，改变可打开最大文件数从 1024 到 10240，可以这么做：
<pre># ulimit -n 10240                    <span class="cmt"># 这只在shell中有用</span>
</pre>
<code>ulimit</code> 命令可以使用在脚本中来更改对此脚本的限制。

<h4>每 用户/进程</h4>
登录用户和应用程序的限制可以在 <code>/etc/security/limits.conf</code> 中配置。举个例子：
<pre># cat /etc/security/limits.conf
*   hard    nproc   250              <span class="cmt"># 限制所有用户进程数</span>
asterisk hard nofile 409600          <span class="cmt"># 限制应用程序可打开最大文件数</span>
</pre>
<h4>系统级</h4>
用sysctl来设置内核限制。要使其永久，可以在 <code>/etc/sysctl.conf</code> 中进行配置。
<pre># sysctl -a                          <span class="cmt"># 显示所有系统限制</span>
# sysctl fs.file-max                 <span class="cmt"># 显示系统最大文件打开数</span>
# sysctl fs.file-max=102400          <span class="cmt"># 更改系统最大文件打开数</span>
# cat /etc/sysctl.conf
fs.file-max=102400                   <span class="cmt"># 在 sysctl.conf 中的永久项</span>
# cat /proc/sys/fs/file-nr           <span class="cmt"># 在使用的文件句柄数</span>
</pre>

<h3>FreeBSD</h3>
<h4>每 shell/脚本</h4>
在 csh 或 tcsh 中使用 <code>limits</code> 命令，在 sh 或 bash 中使用 <code>ulimit</code> 命令。
<h4>每 用户/进程</h4>
在 <code>/etc/login.conf</code> 中配置登录后的默认限制。未作限制的值为系统最大限制值。
<h4>系统级</h4>
内核限制同样使用 sysctl 来设置。永久配置，在 <code>/etc/sysctl.conf</code> 或 <code>/boot/loader.conf</code> 中。其语法与 Linux 相同，只是键值不同。
<pre># sysctl -a                          <span class="cmt"># 显示所有系统限制</span>
# sysctl kern.maxfiles=XXXX          <span class="cmt"># 最大文件描述符数</span>
kern.ipc.nmbclusters=32768           <span class="cmt"># 在 /etc/sysctl.conf 中的永久项</span>
kern.maxfiles=65536                  <span class="cmt"># Squid<span class="fn">译注：代理服务器</span> 通常用这个值</span>
kern.maxfilesperproc=32768
kern.ipc.somaxconn=8192              <span class="cmt"># TCP 列队。apache/sendmail 最好用这个值</span>
# sysctl kern.openfiles              <span class="cmt"># 在使用的文件描述符数</span>
# sysctl kern.ipc.numopensockets     <span class="cmt"># 已经开启的 socket 数目</span>
</pre>
详情请看 <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html">FreeBSD 手册 11章</a><span class="fn">http://www.freebsd.org/handbook/configtuning-kernel-limits.html</span>。

<h3>Solaris</h3>
在 <code>/etc/system</code> 中的下列设置，会提高每个进程可以打开最大文件描述符的数量：
<pre>set rlim_fd_max = 4096               <span class="cmt"># 一个进程可以打开文件描述符的"硬"限制</span>
set rlim_fd_cur = 1024               <span class="cmt"># 一个进程可以打开文件描述符的"软"限制</span>
</pre>

<h2 id="runlevels">运行级别</h2>
<h3>Linux</h3>
一旦内核加载完成，内核会启动 <code>init</code> 进程，然后运行 <code>rc</code><span class="fn">译注：/etc/rc.d/rc</span> 脚本，之后运行所有属于其运行级别的命令脚本。这些脚本都储存在 /etc/rc.d/rcN.d 中(N代表运行级别)，并且都建立着到 /etc/init.d 子目录中命令脚本程序的符号链接。<br />
默认运行级别配置在 /etc/inittab 中。它通常为 3 或 5：
<pre># grep default: /etc/inittab                                         
id:3:initdefault:
</pre>
可以使用 <code>init</code> 来改变当前运行级别。举个例子：
<pre># init 5                             <span class="cmt"># 进入运行级别 5</span></pre>
运行级别列表如下：
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li>0       系统停止</li>
  <li>1       进入单用户模式(也可以是 S)</li>
  <li>2       没有 NFS 特性的多用户模式</li>
  <li>3       完全多用户模式(正常操作模式)</li>
  <li>4       未使用</li>
  <li>5       类似于级别3，但提供 XWindow 系统登录环境</li>
  <li>6       重新启动系统</li>
</ul>
使用 <code>chkconfig</code> 工具控制程序在一个运行级别启动和停止。
<pre># chkconfig --list                   <span class="cmt"># 列出所有 init 脚本</span>
# chkconfig --list sshd              <span class="cmt"># 查看 sshd 在各个运行级别中的启动配置</span>
# chkconfig sshd --level 35 on       <span class="cmt"># 对 sshd 在级别 3 和 5 下创建启动项</span>
# chkconfig sshd off                 <span class="cmt"># 在所有的运行级别下禁用 sshd</span>
</pre>
Debian 和基于Debian 发行版像 Ubuntu 或 Knoppix 使用命令 <code>update-rc.d</code> 来管理运行级别脚本。默认启动为 2,3,4 和 5，停止为 0,1 和 6。
<pre># update-rc.d sshd defaults          <span class="cmt"># 设置 sshd 为默认启动级别</span>
# update-rc.d sshd start 20 2 3 4 5 . stop 20 0 1 6 .  <span class="cmt"># 用显示参数</span>
# update-rc.d -f sshd remove         <span class="cmt"># 在所有的运行级别下禁用 sshd</span>
# shutdown -h now (或者 # poweroff)  <span class="cmt"># 关闭停止系统</span>
</pre>

<h3>FreeBSD</h3>
BSD 启动步骤不同于 SysV, 她没有运行级别。她的启动状态(单用户，有或没有 XWindow)被配置在 <code>/etc/ttys</code>中。所有的系统脚本都位于 <code>/etc/rc.d/</code>中，第三方应用程序位于 <code>/usr/local/etc/rc.d/</code>中。service 的启动顺序被配置在 <code>/etc/rc.conf</code> 和<code>/etc/rc.conf.local</code>中。默认行为可在 <code>/etc/defaults/rc.conf</code> 中进行配置。 这些脚本至少响应 start|stop|status.
<pre># /etc/rc.d/sshd status
sshd is running as pid 552.
# shutdown now                       <span class="cmt"># 进入单用户模式</span>
# exit                               <span class="cmt"># 返回到多用户模式</span>
# shutdown -p now                    <span class="cmt"># 关闭停止系统</span>
# shutdown -r now                    <span class="cmt"># 重新启动系统</span>
</pre>
同样可以使用进程 <code>init</code> 进入下列状态级别。举个例子： <code># init 6</code> 为重启。
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li>0       停止系统并关闭电源 (信号 <code>USR2</code>)</li>
  <li>1       进入单用户模式 (信号 <code>TERM</code>)</li>
  <li>6       重新启动 (信号 <code>INT</code>)</li>
  <li>c       阻止进一步登录 (信号 <code>TSTP</code>)</li>
  <li>q       重新检查 ttys(5) 文件 (信号 <code>HUP</code>)</li>
</ul>

<h2 id="resetpasswd">重设 root 密码</h2>
<h3>Linux 方法 1</h3>
在引导加载器(lilo 或 grub)中，键入如下启选项：
<pre>init=/bin/sh</pre>
内核会挂载 root 分区，进程 <code>init</code> 会启动 bourne shell 而不是 <code>rc</code>，然后是运行级别。使用命令 <code>passwd</code> 设置密码然后重启。别忘了需要在单用户模式下做这些动作。<br />
如果重启后 root 分区被挂载为只读，重新挂在它为读写：
<pre># mount -o remount,rw /
# passwd                             <span class="cmt"># 或者删除 root 密码 (/etc/shadow)</span>
# sync; mount -o remount,ro /        <span class="cmt"># sync 在重新挂在为只读之前 sync 一下</span>
# reboot
</pre> 

<h3>FreeBSD 和 Linux 方法 2</h3>
FreeBSD 不会让你这么做。解决方案是用其他操作系统(像系统紧急修复光盘)挂载 root 分区，然后更改密码。
<ul>
  <li>用 live cd 或安装盘启动进入修复模式后，会得到一个 shell。</li>
  <li>用 fdisk 查找 root 分区。比如：fdisk /dev/sda</li>
  <li>挂载它并使用 chroot 命令:</li>
</ul>
<pre># mount -o rw /dev/ad4s3a /mnt
# chroot /mnt                        <span class="cmt"># 改变程序执行时所参考的根目录位置为 /mnt</span>
# passwd
# reboot
</pre>

<h2 id="kernelmodules">内核模块</h2>
<h3>Linux</h3>
<pre># lsmod                              <span class="cmt"># 列出所有已载入内核的模块</span>
# modprobe isdn                      <span class="cmt"># 载入 isdn 模块</span>
</pre>
<h3>FreeBSD</h3>
<pre># kldstat                            <span class="cmt"># 列出所有已载入内核的模块</span>
# kldload crypto                     <span class="cmt"># 载入 crypto 模块</span>
</pre>
<h2 id="compilekernel">编译内核</h2>
<h3>Linux</h3>
<pre># cd /usr/src/linux
# make mrproper                      <span class="cmt"># 清除所有东西，包括配置文件</span>
# make oldconfig                     <span class="cmt"># 从当前内核配置文件的基础上创建一个新的配置文件</span>
# make menuconfig                    <span class="cmt"># 或者 xconfig (Qt) 或者 gconfig (GTK)</span>
# make                               <span class="cmt"># 创建一个已压缩的内核映像文件</span>
# make modules                       <span class="cmt"># 编译模块</span>
# make modules_install               <span class="cmt"># 安装模块</span>
# make install                       <span class="cmt"># 安装内核</span>
# reboot
</pre>
<h3>FreeBSD</h3>要改变和重建内核，需要拷贝源配置文件然后编辑它。当然也可以直接编辑 <code>GENERIC</code> 文件。
<pre># cd /usr/src/sys/i386/conf/
# cp GENERIC MYKERNEL
# cd /usr/src
# make buildkernel KERNCONF=MYKERNEL
# make installkernel KERNCONF=MYKERNEL
</pre>
要重建完全的操作系统：
<pre># make buildworld                    <span class="cmt"># 构建完全的系统，但不是内核</span>
# make buildkernel                   <span class="cmt"># 使用 KERNCONF 配置文件编译内核</span>
# make installkernel
# reboot
# mergemaster -p                     <span class="cmt"># 建立临时根环境并比对系统配置文件</span>
# make installworld
# mergemaster                        <span class="cmt"># 升级所有配置和其他文件</span>
# reboot
</pre>
对于源的一些小改动，有时候简单的命令就足够了：
<pre># make kernel world                  <span class="cmt"># 编译并安装内核和系统</span>
# mergemaster
# reboot
</pre>
</div>

<div id="processes"><h1><a>进程</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#ps">列表</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#nice">优先级</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#bgfg">后台/前台</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#top">Top</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#kill">Kill</a></p>
<h2 id="ps">进程列表</h2>
PID是每个进程唯一号码。使用 <code>ps</code> 获取所有正在运行的进程列表。
<pre># ps -auxefw                         <span class="cmt"># 所有正在运行进程的详尽列表</span></pre>
然而，更典型的用法是使用管道或者 <code>pgrep</code>:
<pre># ps axww | grep cron
  586  ??  Is     0:01.48 /usr/sbin/cron -s
# ps aux | grep 'ss[h]'              <span class="cmt"># Find all ssh pids without the grep pid</span>
# pgrep -l sshd                      <span class="cmt"># 查找所有进程名中有sshd的进程ID</span>
# echo $$                            <span class="cmt"># The PID of your shell</span>
# fuser -va 22/tcp                   <span class="cmt"># 列出使用端口22的进程</span>
# fuser -va /home                    <span class="cmt"># 列出访问 /home 分区的进程</span>
# strace df                          <span class="cmt"># 跟踪系统调用和信号</span>
# truss df                           <span class="cmt"># 同上(FreeBSD/Solaris/类Unix)</span>
# history | tail -50                 <span class="cmt"># 显示最后50个使用过的命令</span>
</pre>

<h2 id="nice">优先级</h2>
用 <code>renice</code> 更改正在运行进程的优先级。负值是更高的优先级，最小为-20，其正值与 "nice" 值的意义相同<span class="fn">译注：进程的优先级通常被称作它的 nice 值。用户只能对自己所有的进程使用renice命令，root用户可以在任何进程上使用renice命令，只有root用户才能提高进程的优先级</span>。
<pre># renice -5 586                      <span class="cmt"># 更强的优先级</span>
586: old priority 0, new priority -5
</pre>
使用 <code>nice</code> 命令启动一个已定义优先级的进程。 正值为低优先级，负值为高优先级。确定你知道 <code>/usr/bin/nice</code> 或者使用 shell 内置命令<span class="fn">译注：要查看所有 shell 内置命令，可运行 <code># info bash builtin</code></span>(<code># which nice</code>)。
<pre># nice -n -5 top                     <span class="cmt"># 更高优先级(/usr/bin/nice)</span>
# nice -n 5 top                      <span class="cmt"># 更低优先级(/usr/bin/nice)</span>
# nice +5 top                        <span class="cmt"># tcsh 内置 nice 命令(同上)</span>
</pre>
nice 可以影响 CPU 的调度，另一个实用命令 <code>ionice</code><span class="fn">译注：此命令仅可工作在2.6.13及以上内核版本上，并且采用了CFQ 的 IO 调度方式。通过 #cat /sys/block/[sh]d[a-z]*/queue/scheduler 命令可以得知你的系统采用了什么样的调度算法</span> 可以调度磁盘 IO。This is very useful for intensive IO application which can bring a machine to its knees while still in a lower priority. 此命令仅可在 Linux (AFAIK) 上使用。你可以选择一个类型(idle - best effort - real time)，它的 man 页很短并有很好的解释。
<pre># ionice c3 -p123                    <span class="cmt"># 给 pid 123 设置为 idle 类型</span>
# ionice -c2 -n0 firefox             <span class="cmt"># 用 best effort 类型运行 firefox 并且设为高优先级</span>
# ionice -c3 -p$$                    <span class="cmt"># 将当前的进程(shell)的磁盘 IO 调度设置为 idle 类型</span>
</pre>
例中最后一条命令对于编译(或调试)一个大型项目会非常有用。每一个运行于此 shell 的命令都会有一个较低的优先级，但并不妨碍这个系统。$$ 是你 shell 的 pid (试试 echo $$)。

<h2 id="bgfg">前台/后台</h2>当一个进程在 shell 中已运行，可以使用 <code>[Ctrl]-[Z] (^Z)</code>, <code>bg</code> 和 <code>fg</code> 来 调入调出前后台<span class="fn">译注：在命令后面加 <code>&amp;</code> 可直接使其在后台运行。</span>。举个例子：启动 2 个进程，调入后台。使用 <code>jobs</code> 列出后台列表，然后再调入一个进程到前台。
<pre># ping cb.vu &gt; ping.log
^Z                                   <span class="cmt"># ping 使用 [Ctrl]-[Z] 来暂停(停止)</span> 
# bg                                 <span class="cmt"># 调入后台继续运行</span>
# jobs -l                            <span class="cmt"># 后台进程列表</span>
[1]  - 36232 Running                       ping cb.vu &gt; ping.log
[2]  + 36233 Suspended (tty output)        top
# fg %2                              <span class="cmt"># 让进程 2 返回到前台运行</span>
</pre>
使用 <code>nohup</code> 开启一个持续运行的进程直到 shell 被关闭(避免挂断)。
<pre># nohup ping -i 60 &gt; ping.log &amp;
</pre>

<h2 id="top">Top</h2>
<code>top</code> 程序用来实时显示系统中各个进程的运行信息。
<pre># top</pre>
当 <code>top</code> 在运行的时候，按下 <code>h</code><span class="fn">译注：也可以是 <code>?</code></span> 键会显示帮助画面。常用键如下：
<ul>
  <li><b>u [用户名]</b> 只显示属于此用户的进程。使用 + 或者空白可以查看所有用户</li>
  <li><b>k [PID]</b> 结束 PID 进程</li>
  <li><b>1<span class="fn">译注：数字</span></b> 显示所有进程状态信息(只有Linux)</li>
   <li><b>R</b> 将当前排序倒转</li>
</ul>
<h2 id="kill">Kill命令与信号</h2>
使用 <code>kill</code> 或 <code>killall</code> 终止或发送一个信号给进程。
<pre># ping -i 60 cb.vu &gt; ping.log &amp;
[1] 4712
# kill -s TERM 4712                  <span class="cmt"># 同 kill -15 4712</span>
# killall -1 httpd                   <span class="cmt"># 发送 HUP 信号终止进程 httpd</span>
# pkill -9 http                      <span class="cmt"># 发送 TERM 信号终止包含 http 的进程</span>
# pkill -TERM -u www                 <span class="cmt"># 发送 TERM 信号终止 www 所有者进程</span>
# fuser -k -TERM -m /home            <span class="cmt"># 终止所有访问 /home 的进程(卸载该分区前)</span>
</pre>
下面是一些重要的信号：
<ul style="list-style-type: none;">
  <li>1       <code>HUP</code> (挂起)</li>
  <li>2       <code>INT</code> (中断)</li>
  <li>3       <code>QUIT</code> (退出)</li>
  <li>9       <code>KILL</code> (KILL 信号不能被捕捉，不能被忽略。)</li>
  <li>15     <code>TERM</code> (软件终止信号)</li>
</ul>

</div>

<div id="filesystem"><h1><a>文件系统</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#diskinfo">磁盘信息</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#fsboot">Boot</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#mountpoints">磁盘使用情况</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#filesstat">已打开的文件</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#mountcd">挂载/重挂</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#mountsmb">挂载 SMB</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#mountimg">挂载映像文件</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#burniso">Burn ISO</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#createimg">Create image</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#creatememdisk">Memory disk</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#diskperf">Disk performance</a></p>
<h2 id="permissions">权限</h2>
用 <code>chmod</code> 和 <code>chown</code> 更改访问权限和所有权。对于所有用户的默认掩码(umask)可以在 /etc/profile (Linux) 或 /etc/login.conf (FreeBSD) 中修改。其默认掩码(umask)通常为 022。掩码可以和777做减法，从而得到755的权限。
<pre>1 --x 执行                           <span class="cmt"># Mode 764 = 执行/读/写 | 读/写 | 读</span>
2 -w- 写                             <span class="cmt"># |---所有者|---用户组|---其他用户|</span>
4 r-- 读
  ugo=a                              <span class="cmt">u=所有者, g=用户组, o=其他用户, a=所有用户</span>
</pre>
<pre># chmod [OPTION] MODE[,MODE] FILE    <span class="cmt"># MODE 可以是 [ugoa]*([-+=]([rwxXst]))</span>
# chmod 640 /var/log/maillog         <span class="cmt"># 更改 maillog 访问权限为 -rw-r-----</span>
# chmod u=rw,g=r,o= /var/log/maillog <span class="cmt"># 同上</span>
# chmod -R o-r /home/*               <span class="cmt"># 递归去除所有其他用户的可读权限</span>
# chmod u+s /path/to/prog            <span class="cmt"># 在可执行位设置 SUID (知道你在干什么!<span class="fn">当执行一个具有 setuid 权限的文件时，文件的执行过程将具有文件所有者的特权(比如root)。所以，应尽量避免不加选择地创建和使用 root 用户拥有的 seruid 程序或 root 组拥有的 setgid 程序。</span>)</span>
# find / -perm -u+s -print           <span class="cmt"># 查找所有设置过 SUID 位的程序</span>
# chown user:group /path/to/file     <span class="cmt"># 改变文件的所有者和文件关联的组</span>
# chgrp group /path/to/file          <span class="cmt"># 改变文件关联的组</span>
# chmod 640 `find ./ -type f -print` <span class="cmt"># Change permissions to 640 for all files</span>
# chmod 751 `find ./ -type d -print` <span class="cmt"># Change permissions to 751 for all directories</span>
</pre>
<h2 id="diskinfo">磁盘信息</h2>
<pre># diskinfo -v /dev/ad2               <span class="cmt"># 显示磁盘信息(扇区/大小) (FreeBSD)</span>
# hdparm -I /dev/sda                 <span class="cmt"># 显示 IDE/ATA 磁盘信息 (Linux)</span>
# fdisk /dev/ad2                     <span class="cmt"># 显示和修改磁盘分区表</span>
# smartctl -a /dev/ad2               <span class="cmt"># 显示磁盘检测信息</span>
</pre>
<h2 id="fsboot">Boot</h2>
<h3>FreeBSD</h3>
如果新内核不能引导，要引导一个旧内核，停止启动倒计时，做如下动作：
<pre># unload
# load kernel.old
# boot
</pre>

<h2 id="mountpoints">系统挂载点/磁盘使用情况</h2>
<pre># mount | column -t                  <span class="cmt"># 显示系统已挂载分区情况</span>
# df                                 <span class="cmt"># 显示磁盘剩余空间和挂载的设备</span>
# cat /proc/partitions               <span class="cmt"># 显示所有设备的所有分区(Linux)</span>
</pre>

<h3 id="diskusage">磁盘使用情况</h3>
<pre># du -sh *                           <span class="cmt"># 列出当前目录下所有文件夹大小</span>
# du -csh                            <span class="cmt"># 当前目录下所有目录大小总数</span>
# du -ks * | sort -n -r              <span class="cmt"># 由大到小排序显示目录大小</span>
# ls -lSr                            <span class="cmt"># 由小到大显示文件列表</span>
</pre>

<h2 id="filesstat">谁打开了那些文件</h2>
对于找出哪些文件阻止卸载分区并给出有代表性的错误是有帮助的：
<pre># umount /home/
umount: unmount of /home             <span class="cmt"># 不能卸载，因为有一个文件锁定了 home</span>
   failed: Device busy
</pre>
<h3>FreeBSD 和大多数 Unix</h3>
<pre># fstat -f /home                     <span class="cmt"># 对于一个挂载点</span>
# fstat -p PID                       <span class="cmt"># 对于一个应用程序进程 ID</span>
# fstat -u user                      <span class="cmt"># 对于一个用户</span>
</pre>

查找已打开日志文件(或其他已打开文件)， 比如 Xorg：
<pre># ps ax | grep Xorg | awk '{print $1}'
1252
# fstat -p 1252
USER     CMD          PID   FD MOUNT      INUM MODE         SZ|DV R/W
root     Xorg        1252 root /             2 drwxr-xr-x     512  r
root     Xorg        1252 text /usr     216016 -rws--x--x  1679848 r
root     Xorg        1252    0 /var     212042 -rw-r--r--   56987  w
</pre>
在 /var 中的只有一个 inum 为 212042 的文件：
<pre># find -x /var -inum 212042
/var/log/Xorg.0.log
</pre>

<h3>Linux</h3>
使用 <code>fuser</code> 或 <code>lsof</code> 在一个挂载点中查找已打开的文件：
<pre># fuser -m /home                     <span class="cmt"># 列出访问 /home 的进程</span>
# lsof /home
COMMAND   PID    USER   FD   TYPE DEVICE    SIZE     NODE NAME
tcsh    29029 eedcoba  cwd    DIR   0,18   12288  1048587 /home/eedcoba (guam:/home)
lsof    29140 eedcoba  cwd    DIR   0,18   12288  1048587 /home/eedcoba (guam:/home)
</pre>
关于一个应用程序：
<pre>ps ax | grep Xorg | awk '{print $1}'
3324
# lsof -p 3324
COMMAND   PID    USER   FD   TYPE DEVICE    SIZE    NODE NAME
Xorg    3324 root    0w   REG        8,6   56296      12492 /var/log/Xorg.0.log
</pre>

关于单个文件：
<pre># lsof /var/log/Xorg.0.log
COMMAND  PID USER   FD   TYPE DEVICE  SIZE  NODE NAME
Xorg    3324 root    0w   REG    8,6 56296 12492 /var/log/Xorg.0.log
</pre>

<h2 id="mountcd">挂载/重挂载一个文件系统</h2>
举个 cdrom 的例子。如果已经列于 /etc/fstab 中：
<pre># mount /cdrom</pre>
或在 /dev/ 中查找设备，亦或使用 <code>dmesg</code> 命令
<h3>FreeBSD</h3>
<pre># mount -v -t cd9660 /dev/cd0c /mnt  <span class="cmt"># cdrom</span>
# mount_cd9660 /dev/wcd0c /cdrom     <span class="cmt"># 另外一个方法</span>
# mount -v -t msdos /dev/fd0c /mnt   <span class="cmt"># 软驱</span>
</pre>
/etc/fstab 中的一条：
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/acd0               /cdrom          cd9660  ro,noauto       0       0
</pre>
要允许用户做这些，可以这么做：
<pre># sysctl vfs.usermount=1  <span class="cmt"># 或者在 /etc/sysctl.conf 中插入一条 "vfs.usermount=1"</span>
</pre>

<h3>Linux</h3>
<pre># mount -t auto /dev/cdrom /mnt/cdrom   <span class="cmt"># 典型的 cdrom 挂载命令</span>
# mount /dev/hdc -t iso9660 -r /cdrom   <span class="cmt"># IDE</span>
# mount /dev/sdc0 -t iso9660 -r /cdrom  <span class="cmt"># SCSI</span>
</pre>
/etc/fstab 中的条目：
<pre>/dev/cdrom   /media/cdrom  subfs noauto,fs=cdfss,ro,procuid,nosuid,nodev,exec 0 0</pre>
<h4>用 Linux 挂载一个 FreeBSD 分区</h4>
用 fdisk 查找分区号，这通常是 root 分区，但也可能是其他 BSD slice。如果 FreeBSD 有许多 slice，他们不列于同一个 fdisk 分区表中，但可见于 /dev/sda* 或 /dev/hda* 中。
<pre># fdisk /dev/sda                     <span class="cmt"># 查找 FreeBSD 分区</span>
/dev/sda3   *        5357        7905    20474842+  a5  FreeBSD
# mount -t ufs -o ufstype=ufs2,ro /dev/sda3 /mnt
/dev/sda10 = /tmp; /dev/sda11 /usr   <span class="cmt"># 其他 slice</span>
</pre>
<h3 id="remount">重挂载</h3>
不用卸载一个设备来重挂载。 对 <code>fsck</code> 来说是必须的。举个例子：
<pre># mount -o remount,ro /              <span class="cmt"># Linux</span>
# mount -o ro /                      <span class="cmt"># FreeBSD</span>
</pre>
从 cdrom 拷贝原始数据进一个 iso 映像文件：
<pre># dd if=/dev/cd0c of=file.iso</pre>

<h2 id="addswap">给即时烧录(on-the-fly)添加 swap</h2>
假设你需要很多的 swap (即刻)，如一个 2GB 文件 /swap2gb (只限 Linux)。
<pre># dd if=/dev/zero of=/swap2gb bs=1024k count=2000
# mkswap /swap2gb                    <span class="cmt"># 创建交换区</span>
# swapon /swap2gb                    <span class="cmt"># 激活这个 swap。现在可以使用了</span>
# swapoff /swap2gb                   <span class="cmt"># 当使用完毕，释放这个 swap</span>
# rm /swap2gb
</pre>

<h2 id="mountsmb">挂载一个 SMB<span class="fn">译注：SMB (Server Message Block,服务器信息块)，又称 CIFS (Common Internet File System,通用Internet文件系统)</span> 共享</h2>
假设我们要访问计算机 smbserver 上的名叫 myshare 的 SMB 共享，在 window PC 上键入的地址是 \\smbserver\myshare\。我挂载到 /mnt/smbshare 上。注意 cifs 必须是 IP 或 DNS 名，不是 Windows 名字。
<h3>Linux</h3>
<pre># smbclient -U user -I 192.168.16.229 -L //smbshare/    <span class="cmt"># 列出共享</span>
# mount -t smbfs -o username=winuser //smbserver/myshare /mnt/smbshare
# mount -t cifs -o username=winuser,password=winpwd //192.168.16.229/myshare /mnt/share
</pre>
此外，mount.cifs 软件包可以存储认证到一个文件中。例如，<code>/home/user/.smb</code>:
<pre>username=winuser
password=winpwd
</pre>
现在可以像下面那样挂载：
<pre># mount -t cifs -o credentials=/home/user/.smb //192.168.16.229/myshare /mnt/smbshare</pre>

<h3>FreeBSD</h3>
使用 -I 来获取 IP (或 DNS 名）；smbserver 是 Windows 名。
<pre># smbutil view -I 192.168.16.229 //winuser@smbserver    <span class="cmt"># 列出共享</span>
# mount_smbfs -I 192.168.16.229 //winuser@smbserver/myshare /mnt/smbshare
</pre>

<h2 id="mountimg">挂载镜像文件</h2>
<h3>Linux loop-back</h3>
<pre># mount -t iso9660 -o loop file.iso /mnt                <span class="cmt"># 挂载 CD 镜像文件</span>
# mount -t ext3 -o loop file.img /mnt                   <span class="cmt"># 用 ext3 文件系统挂载镜像文件</span>
</pre>

<h3>FreeBSD</h3>
用于存储设备 (如果需要做 # kldload md.ko 动作)：
<pre># mdconfig -a -t vnode -f file.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
# umount /mnt; mdconfig -d -u 0                         <span class="cmt"># 清除 md 设备</span>
</pre>
用于虚拟节点：
<pre># vnconfig /dev/vn0c file.iso; mount -t cd9660 /dev/vn0c /mnt
# umount /mnt; vnconfig -u /dev/vn0c                    <span class="cmt"># 清除 vn 设备</span>
</pre>

<h3>Solaris and FreeBSD</h3>
用于 loop-back 文件接口或 lofi：
<pre># lofiadm -a file.iso
# mount -F hsfs -o ro /dev/lofi/1 /mnt
# umount /mnt; lofiadm -d /dev/lofi/1                   <span class="cmt"># 清除 lofi 设备</span>
</pre>
<h2 id="burniso">创建并刻录 ISO 镜像文件</h2>
这将会拷贝 CD 或者 DVD 的扇区。当不用 <code>conv=notrunc</code>，镜像文件会等于 CD 内容大小而非 CD 容量大小。看下面和 <a class="xref" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#dd">dd 例子</a>。
<pre># dd if=/dev/hdc of=/tmp/mycd.iso bs=2048 conv=notrunc</pre>
使用 mkisofs 把目录中所有文件创建成 CD/DVD 镜像文件。克服文件名限制：-r 开启 Rock Ridge 扩展用于 Unix 系统，-J 开启  Joliet 扩展用于微软系统。-L 允许 ISO9660 文件名第一个字符为句点。
<pre># mkisofs -J -L -r -V TITLE -o imagefile.iso /path/to/dir</pre>
对于 FreeBSD，mkisofs 可以到 port 的 sysutils/cdrtools 中找到。
<h3>刻录 ISO 镜像文件</h3>
<h4>FreeBSD</h4>
FreeBSD 默认情况下没有在 ATAPI 驱动上启用 DMA。DMA 可用 sysctl 命令启用，其参数如下，或者在 /boot/loader.conf 中添加如下条目：
<pre>hw.ata.ata_dma="1"
hw.ata.atapi_dma="1"
</pre>
<code>burncd</code> 用于 ATAPI 驱动(<code>burncd</code> 为基本系统的一部分)，<code>cdrecord</code> (在 sysutils/cdrtools 中)用于 SCSI 驱动。
<pre># burncd -f /dev/acd0 data imagefile.iso fixate      <span class="cmt"># ATAPI 驱动</span>
# cdrecord -scanbus                  <span class="cmt"># 查找 burner 设备描述符(如 1,0,0)</span>
# cdrecord dev=1,0,0 imagefile.iso
</pre>
<h4>Linux</h4>
对于 Linux，同样使用 <code>cdrecord</code> 如上文所述。此外，它还可以使用本地 ATAPI 接口查找设备描述符：
<pre># cdrecord dev=ATAPI -scanbus</pre>
然后同上面一样烧录 CD/DVD。
<h4>dvd+rw-tools</h4>
<a href="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools</a><span class="fn">http://fy.chalmers.se/~appro/linux/DVD+RW/</span> 工具包(FreeBSD: ports/sysutils/dvd+rw-tools)可以做上面的一切，其还包括 growisofs 工具来刻录 CD 或 DVD。本实例所引用的 DVD 设备 <code>/dev/dvd</code> 可能是指向 <code>/dev/scd0</code> (Linux)的符号连接，或者 <code>/dev/cd0</code> (FreeBSD)，或者 <code>/dev/rcd0c</code> (NetBSD/OpenBSD)，或者 <code>/dev/rdsk/c0t1d0s2</code> (Solaris)。对于本实例 <a href="http://www.freebsd.org/handbook/creating-dvds.html">FreeBSD 手册 18.7 章</a><span class="fn">http://www.freebsd.org/handbook/creating-dvds.html</span> 上有一份很好的文档。
<pre>          <span class="cmt"># -dvd-compat 选项将完结光盘，光盘便不可再附加数据</span>
# growisofs -dvd-compat -Z /dev/dvd=imagefile.iso     <span class="cmt"># 刻录已存在的 iso 镜像文件</span>
# growisofs -dvd-compat -Z /dev/dvd -J -R /p/to/data  <span class="cmt"># 直接刻录</span>
</pre>

<h3>转换 Nero .nrg 文件成 .iso</h3>
Nero 简单的添加了 300KB 的头到一个常规的 iso 镜像文件中。我们可用 dd 工具来去除它。
<pre># dd bs=1k if=imagefile.nrg of=imagefile.iso skip=300</pre>
<h3>转换 bin/cue 镜像成 .iso</h3>
<a href="http://freshmeat.net/projects/bchunk/"><code>bchunk</code> 程序</a><span class="fn">http://freshmeat.net/projects/bchunk/</span>可以做到这一点。在 FreeBSD 中，它在 port 的 sysutils/bchunk 中。
<pre># bchunk imagefile.bin imagefile.cue imagefile.iso
</pre>

<h2 id="createimg">创建基于文件的镜像文件</h2>
举个例子，一个使用文件 /usr/vdisk.img 的 1GB 分区。这里我们使用 vnode 0,但也可为 1。
<h3>FreeBSD</h3>
<pre># dd if=/dev/random of=/usr/vdisk.img bs=1K count=1M
# mdconfig -a -t vnode -f /usr/vdisk.img -u 0         <span class="cmt"># 创建设备 /dev/md1</span>
# bsdlabel -w /dev/md0
# newfs /dev/md0c
# mount /dev/md0c /mnt
# umount /mnt; mdconfig -d -u 0; rm /usr/vdisk.img    <span class="cmt"># 清除 md 设备</span>
</pre>
这个基于文件的镜像文件可以在 /etc/rc.conf 和 /etc/fstab 中配置成启动期间自动挂载。可用 <code># /etc/rc.d/mdconfig start</code> (先用 <code># mdconfig -d -u 0</code> 命令删除 md0 设备) 测试你的设置。<br />
需要注意的是，那个自动设置仅工作于这个基于文件的镜像文件不在 root 分区中。原因是 /etc/rc.d/mdconfig 脚本早于启动就执行了，并且 root 分区仍然是只读的。脚本 /etc/rc.d/mdconfig2 之后，镜像文件将位于 root 分区外挂载。<br />
/boot/loader.conf:
<pre>md_load="YES"</pre>
/etc/rc.conf:
<pre># mdconfig_md0="-t vnode -f /usr/vdisk.img"          <span class="cmt"># /usr 不在 root 分区中</span></pre>
/etc/fstab: (行后的两个 0 0 很重要，它告诉 fsck 忽略这个设备,现在还不存在。)
<pre>/dev/md0                /usr/vdisk      ufs     rw              0       0</pre>
也可能在增加镜像文件的大小之后，如增大到 300MB。
<pre># umount /mnt; mdconfig -d -u 0
# dd if=/dev/zero bs=1m count=300 &gt;&gt; /usr/vdisk.img
# mdconfig -a -t vnode -f /usr/vdisk.img -u 0
# growfs /dev/md0
# mount /dev/md0c /mnt                                <span class="cmt"># 文件分区现在为 300MB</span>
</pre>

<h3>Linux</h3>

<pre># dd if=/dev/zero of=/usr/vdisk.img bs=1024k count=1024
# mkfs.ext3 /usr/vdisk.img
# mount -o loop /usr/vdisk.img /mnt
# umount /mnt; rm /usr/vdisk.img                      <span class="cmt"># 清楚</span>
</pre>
<h3 id="losetup">Linux with losetup</h3>
<code>/dev/zero</code> 比 <code>urandom</code> 更快，但对于加密来说却不够安全。
<pre># dd if=/dev/urandom of=/usr/vdisk.img bs=1024k count=1024
# losetup /dev/loop0 /usr/vdisk.img                   <span class="cmt"># 创建并联结 /dev/loop0</span>
# mkfs.ext3 /dev/loop0
# mount /dev/loop0 /mnt
# losetup -a                                          <span class="cmt"># 查看已经挂载的 loop 设备</span>
# umount /mnt
# losetup -d /dev/loop0                               <span class="cmt"># Detach</span>
# rm /usr/vdisk.img
</pre>

<h2 id="creatememdisk">创建基于内存的文件系统</h2>
基于内存的文件系统对于重量级 IO 应用程序来说非常快。怎样创建一个挂载到 /memdisk 的 64M 分区：
<h3>FreeBSD</h3>
<pre># mount_mfs -o rw -s 64M md /memdisk
# umount /memdisk; mdconfig -d -u 0                   <span class="cmt"># 清除该 md 设备</span>
md     /memdisk     mfs     rw,-s64M    0   0         <span class="cmt"># /etc/fstab 条目</span>
</pre>
<h3>Linux</h3>
<pre># mount -t tmpfs -osize=64m tmpfs /memdisk
</pre>

<h2 id="diskperf">磁盘性能</h2>
在 ad4s3c (/home) 分区上读写一个 1GB 的文件。
<pre># time dd if=/dev/ad4s3c of=/dev/null bs=1024k count=1000
# time dd if=/dev/zero bs=1024k count=1000 of=/home/1Gb.file
# hdparm -tT /dev/hda      <span class="cmt"># 仅限 Linux</span>
</pre>
</div>

<div id="network"><h1><a>网络</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#routing">路由</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#secondip">额外 IP</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#changemac">更改 MAC 地址</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#ports">端口</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#firewall">防火墙</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#ipforward">IP 转发</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#nat">NAT</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#dns">DNS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#dhcp">DHCP</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#traffic">通信量</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#trafficctrl">QoS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#nis">NIS</a></p>
<h2 id="netdebug">调试 (也可看<a class="xref" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#traffic">流量分析)</a></h2>
<h3>Linux</h3>
<pre># ethtool eth0              <span class="cmt"># 显示以太网状态(replaces mii-diag)</span>
# ethtool -s eth0 speed 100 duplex full <span class="cmt"># 把网卡 eth0 速度改为 100兆/秒，采用全双工</span>
# ethtool -s eth0 autoneg off <span class="cmt"># 禁用自动协商模式</span>
# ethtool -p eth1           <span class="cmt"># 闪烁网络接口 LED 灯 - 如果支持的话，非常实用</span>
# ip link show              <span class="cmt"># 在 Linux 上显示所有网络接口(同 ifconfig 类似)</span>
# ip link set eth0 up       <span class="cmt"># 使设备激活(或Down掉)。同 "ifconfig eth0 up"</span>
# ip addr show              <span class="cmt"># 在 Linux 上显示所有 IP 地址(与 ifconfig 类似)</span>
# ip neigh show             <span class="cmt"># 与 arp -a 类似</span>
</pre>
<h3>其他系统</h3>
<pre># ifconfig fxp0             <span class="cmt"># 查看 "media" 字段(FreeBSD)</span>
# arp -a                    <span class="cmt"># 查看路由(或主机) ARP 条目(所有系统)</span>
# ping cb.vu                <span class="cmt"># 第一个要试的事情...</span>
# traceroute cb.vu          <span class="cmt"># 列印到目的地的路由路径</span>
# ifconfig fxp0 media 100baseTX mediaopt full-duplex <span class="cmt"># 100兆/秒 全双工(FreeBSD)</span>
# netstat -s                <span class="cmt"># 对每个网络协议做系统级分析</span>
</pre>
另一些命令，虽然不总是默认安装，但很好找：
<pre># arping 192.168.16.254     <span class="cmt"># 在网络层上 Ping</span>
# tcptraceroute -f 5 cb.vu  <span class="cmt"># 使用 tcp 替换 icmp 来跟踪，透过防火墙</span>
</pre>

<h2 id="routing">路由</h2>
<h3>列印路由表</h3>
<pre># route -n                  <span class="cmt"># Linux 或使用 "ip route"</span>
# netstat -rn               <span class="cmt"># Linux, BSD 和 UNIX</span>
# route print               <span class="cmt"># Windows</span>
</pre>
<h3 id="addroute">添加删除路由</h3>
<h4>FreeBSD</h4>
<pre># route add 212.117.0.0/16 192.168.1.1
# route delete 212.117.0.0/16
# route add default 192.168.1.1
</pre>
永久的添加路由可在 /etc/rc.conf 配置文件中设置
<pre>static_routes="myroute"
route_myroute="-net 212.117.0.0/16 192.168.1.1"
</pre>
<h4>Linux</h4>
<pre># route add -net 192.168.20.0 netmask 255.255.255.0 gw 192.168.16.254
# ip route add 192.168.20.0/24 via 192.168.16.254       <span class="cmt"># 等同于上面命令</span>
# route add -net 192.168.20.0 netmask 255.255.255.0 dev eth0
# route add default gw 192.168.51.254
# ip route add default via 192.168.51.254 dev eth0      <span class="cmt"># 等同于上面命令</span>
# route delete -net 192.168.20.0 netmask 255.255.255.0
</pre>
<h4>Solaris</h4>
<pre># route add -net 192.168.20.0 -netmask 255.255.255.0 192.168.16.254
# route add default 192.168.51.254 1                    <span class="cmt"># 1 = 通过此路由跳<span class="fn">译注：数据包生存周期依赖于 IP 头中的生存周期(Time-to-Live，简称 TTL)。根据 RFC 的定义，这个域值由每个路由器来减少。接收到包的每台路由器根据路由该包所花费的秒数，将包中的这个域值减去相应的时间，或直接减 1。因为目前路由器转发包的时间基本小于 1 秒，这个域值基本上在源和目的地之间的没一跳便会减 1。</span>数减 1</span>
# route change default 192.168.50.254 1
</pre>
永久条目配置在 <code>/etc/defaultrouter</code> 中。
<h4>Windows</h4>
<pre># Route add 192.168.50.0 mask 255.255.255.0 192.168.51.253
# Route add 0.0.0.0 mask 0.0.0.0 192.168.51.254</pre>
使用 <code>add -p</code> 来是路由设置永久有效。

<h2 id="secondip">配置额外的 IP 地址</h2>
<h3>Linux</h3>
<pre># ifconfig eth0 192.168.50.254 netmask 255.255.255.0       <span class="cmt"># 第一个 IP</span>
# ifconfig eth0:0 192.168.51.254 netmask 255.255.255.0     <span class="cmt"># 第二个 IP</span>
# ip addr add 192.168.50.254/24 dev eth0                   <span class="cmt"># 等价命令</span>
# ip addr add 192.168.51.254/24 dev eth0 label eth0:1
</pre>
<h3>FreeBSD</h3>
<pre># ifconfig fxp0 inet 192.168.50.254/24                     <span class="cmt"># 第一个 IP</span>
# ifconfig fxp0 alias 192.168.51.254 netmask 255.255.255.0 <span class="cmt"># 第二个 IP</span>
</pre>永久条目设置在 /etc/rc.conf 中
<pre>ifconfig_fxp0="inet 192.168.50.254  netmask 255.255.255.0"
ifconfig_fxp0_alias0="192.168.51.254 netmask 255.255.255.0"
</pre>
<h3>Solaris</h3>
用 <code>ifconfig -a</code> 命令检查设置
<pre># ifconfig hme0 plumb                                      <span class="cmt"># 启用网卡</span>
# ifconfig hme0 192.168.50.254 netmask 255.255.255.0 up    <span class="cmt"># 第一个 IP</span>
# ifconfig hme0:1 192.168.51.254 netmask 255.255.255.0 up  <span class="cmt"># 第二个 IP</span>
</pre>

<h2 id="changemac">更改 MAC 地址</h2>
通常在你更改之前先停下网络接口。不要告诉我为什么你想改变 MAC 地址......
<pre># ifconfig eth0 down
# ifconfig eth0 hw ether 00:01:02:03:04:05      <span class="cmt"># Linux</span>
# ifconfig fxp0 link 00:01:02:03:04:05          <span class="cmt"># FreeBSD</span>
# ifconfig hme0 ether 00:01:02:03:04:05         <span class="cmt"># Solaris</span>
# sudo ifconfig en0 ether 00:01:02:03:04:05     <span class="cmt"># Mac OS X Tiger</span>
# sudo ifconfig en0 lladdr 00:01:02:03:04:05    <span class="cmt"># Mac OS X Leopard</span>
</pre>
对于 Windows 已经有许多工具了。像 <a href="http://ntsecurity.nu/toolbox/etherchange/">etherchange</a><span class="fn">http://ntsecurity.nu/toolbox/etherchange</span>。或者看看 "Mac Makeup", "smac"。

<h2 id="ports">使用中的端口</h2>
监听打开的端口：
<pre># netstat -an | grep LISTEN
# lsof -i                                       <span class="cmt"># 列出所有因特网连接(Linux)</span>
# socklist                                      <span class="cmt"># 列出打开的 socket (Linux)</span>
# sockstat -4                                   <span class="cmt"># 使用 socket 的应用程序列表(FreeBSD)</span>
# netstat -anp --udp --tcp | grep LISTEN        <span class="cmt"># Linux</span>
# netstat -tup                                  <span class="cmt"># 列出活跃的连接(Linux)</span>
# netstat -tupl                                 <span class="cmt"># 列出系统中正在监听的端口(Linux)</span>
# netstat -ano                                  <span class="cmt"># Windows</span>
</pre>

<h2 id="firewall">防火墙</h2>
检查正在运行的防火墙(只是典型配置)：
<h3>Linux</h3>
<pre># iptables -L -n -v                  <span class="cmt"># 状态信息</span>
Open the iptables firewall
# iptables -P INPUT       ACCEPT     <span class="cmt"># 打开所有</span>
# iptables -P FORWARD     ACCEPT
# iptables -P OUTPUT      ACCEPT
# iptables -Z                        <span class="cmt"># 把所有链的包及字节的计数器清空</span>
# iptables -F                        <span class="cmt"># 清空所有链</span>
# iptables -X                        <span class="cmt"># 删除所有链<span class="fn">译注：链必须没有被引用</span></span>
</pre>
<h3>FreeBSD</h3>
<pre># ipfw show                          <span class="cmt"># 状态信息</span>
# ipfw list 65535 <span class="cmt"># 如果显示 "65535 deny ip from any to any"，那防火墙已被禁用</span>
# sysctl net.inet.ip.fw.enable=0     <span class="cmt"># 禁用</span>
# sysctl net.inet.ip.fw.enable=1     <span class="cmt"># 启用</span>
</pre>
<h2 id="ipforward">路由 IP 转发</h2>
<h3>Linux</h3>
查看然后启用 IP 转发：
<pre># cat /proc/sys/net/ipv4/ip_forward     <span class="cmt"># 查看 IP 转发 0=禁用, 1=启用</span>
# echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</pre>
或者编辑 /etc/sysctl.conf：
<pre>net.ipv4.ip_forward = 1</pre>

<h3>FreeBSD</h3>
查看并启用：
<pre># sysctl net.inet.ip.forwarding          <span class="cmt"># 查看 IP 转发 0=禁用, 1=启用</span>
# sysctl net.inet.ip.forwarding=1
# sysctl net.inet.ip.fastforwarding=1	 <span class="cmt"># 专用路由器或防火墙</span>
Permanent with entry in /etc/rc.conf:
gateway_enable="YES"                     <span class="cmt"># 如果主机是网关则设置为 YES。</span>
</pre>

<h3>Solaris</h3>
<pre># ndd -set /dev/ip ip_forwarding 1       <span class="cmt"># 查看 IP 转发 0=禁用, 1=启用</span>
</pre>

<h2 id="nat">NAT - 网络地址转换</h2>
<h3>Linux</h3>
<pre># iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE	<span class="cmt"># 激活 NAT</span>
# iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 20022 -j DNAT \
--to 192.168.16.44:22           <span class="cmt"># 转发端口 20022 到内部 IP 端口(ssh)</span>
# iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 993:995 -j DNAT \
--to 192.168.16.254:993:995     <span class="cmt"># 转发 993-995 范围端口</span>
# ip route flush cache
# iptables -L -t nat            <span class="cmt"># 查看 NAT 状态信息</span>
</pre>
使用 -D 替换 -A 来删除端口转发。

<h3>FreeBSD</h3>
<pre># natd -s -m -u -dynamic -f /etc/natd.conf -n fxp0
Or edit /etc/rc.conf with:
firewall_enable="YES"           <span class="cmt"># 设置 YES 来启用防火墙功能</span>
firewall_type="open"            <span class="cmt"># 防火墙类型(看 /etc/rc.firewall)</span>
natd_enable="YES"               <span class="cmt"># 启用 natd (如果 firewall_enable == YES)。</span>
natd_interface="tun0"           <span class="cmt"># 公共的网络接口或要使用的 IP 地址。</span>
natd_flags="-s -m -u -dynamic -f /etc/natd.conf"
</pre>
端口转发：
<pre># cat /etc/natd.conf 
same_ports yes
use_sockets yes
unregistered_only
# redirect_port tcp insideIP:2300-2399 3300-3399  <span class="cmt"># 端口范围</span>
redirect_port udp 192.168.51.103:7777 7777
</pre>

<h2 id="dns">DNS</h2>
在 unix 上，对于所有的网络接口的 DNS 条目都存储在 /etc/resolv.conf 文件中。主机域也储存在这个文件中。最小化配置如下：
<pre>nameserver 78.31.70.238
search sleepyowl.net intern.lab
domain sleepyowl.net
</pre>
检查系统域名：
<pre># hostname -d                        <span class="cmt"># 等同于 dnsdomainname</span></pre>
<h3>Windows</h3>
在 Windows 上，DNS 配置于每个网络接口。要显示配置的 DNS 和清空 DNS 缓存可是使用：
<pre># ipconfig /?                        <span class="cmt"># 显示帮助</span>
# ipconfig /all                      <span class="cmt"># 显示所有信息包括 DNS</span>
# ipconfig /flushdns                 <span class="cmt"># 清除 DNS 缓存</span>
</pre>

<h3>转发查询</h3>
Dig 是你测试 DNS 设置的好朋友。举个例子，用于测试的 DNS 服务器为 <code>213.133.105.2 ns.second-ns.de</code>。查看哪个服务器客户端接收应答(简单应答).
<pre># dig sleepyowl.net
sleepyowl.net.          600     IN      A       78.31.70.238
;; SERVER: 192.168.51.254#53(192.168.51.254)
</pre>
路由器 192.168.51.254 应答了，并返回了一条 A 条目(记录)。任何条目都可查询，DNS 服务器可用 @ 来选定：
<pre># dig MX google.com
# dig @127.0.0.1 NS sun.com          <span class="cmt"># 测试本地服务器</span>
# dig @204.97.212.10 NS MX heise.de  <span class="cmt"># 查询外部</span>
# dig AXFR @ns1.xname.org cb.vu      <span class="cmt"># 查看区传送(zone transfer)</span>
</pre>
程式 host 也很强大。
<pre># host -t MX cb.vu                   <span class="cmt"># 获取邮件 MX 记录</span>
# host -t NS -T sun.com              <span class="cmt"># 通过 TCP 连接获取 NS 记录</span>
# host -a sleepyowl.net              <span class="cmt"># 获取所有</span>
</pre>

<h3>反向查询</h3>
查找属于一个 IP 地址(in-addr.arpa.)的域名。可用 <code>dig</code>, <code>host</code> 和 <code>nslookup</code> 命令查询：
<pre># dig -x 78.31.70.238
# host 78.31.70.238
# nslookup 78.31.70.238
</pre>

<h3>/etc/hosts</h3>
单个主机可以配置于文件 /etc/hosts 来代替本地正在运行的 <code>named</code> 反向域名查询。格式很简单，举个例子：
<pre>78.31.70.238   sleepyowl.net   sleepyowl</pre>
对于 hosts 文件和 DNS 查询之间的优先级，可在 <code>/etc/nsswitch.conf</code> 和 <code>/etc/host.conf</code> 中配置 order 名称解析。这个文件同样存在于 Windows 上，通常在：
<pre>C:\WINDOWS\SYSTEM32\DRIVERS\ETC</pre>

<h2 id="dhcp">DHCP</h2>
<h3>Linux</h3>
一些发行版(SuSE)使用 dhcpcd 作为客户端。默认网络接口是 eth0。
<pre># dhcpcd -n eth0           <span class="cmt"># 触发更新(并不总是可以工作)</span>
# dhcpcd -k eth0           <span class="cmt"># 释放并关闭</span>
</pre>
租约(lease)的全部信息存储在：
<pre>/var/lib/dhcpcd/dhcpcd-eth0.info</pre>

<h3>FreeBSD</h3>
FreeBSD (和 Debian) 使用 <code>dhclient</code>。要配置一个网络接口(如：bge0)运行：
<pre># dhclient bge0</pre>
租约(lease)的全部信息存储在：
<pre>/var/db/dhclient.leases.bge0</pre>
使用 <pre>/etc/dhclient.conf</pre> 设置 prepend 选项或强制不同的选项：
<pre># cat /etc/dhclient.conf
interface "rl0" {
    prepend domain-name-servers 127.0.0.1;
    default domain-name "sleepyowl.net";
    supersede domain-name "sleepyowl.net";
}
</pre>

<h3>Windows</h3>
dhcp 租约(lease)使用 <code>ipconfig</code> 来更新：
<pre># ipconfig /renew          <span class="cmt"># 更新所有适配器</span>
# ipconfig /renew LAN      <span class="cmt"># 更新名叫 "LAN" 的适配器</span>
# ipconfig /release WLAN   <span class="cmt"># 释放名叫 "WLAN" 的适配器</span>
</pre>
是的，这是一个使用简单名称重新命名你的适配器的好主意！


<h2 id="traffic">通信量分析(Traffic analysis)</h2>
<a href="http://people.suug.ch/~tgr/bmon/">Bmon</a><span class="fn">http://people.suug.ch/~tgr/bmon/</span> 是一个小的流量监控控制台，而且可以显示不同的网络接口的流量。 
<h3>用 tcpdump 嗅探(sniff)</h3>
<pre># tcpdump -nl -i bge0 not port ssh and src \(192.168.16.121 or 192.168.16.54\)
# tcpdump -l &gt; dump &amp;&amp; tail -f dump               <span class="cmt"># 缓冲输出</span>
# tcpdump -i rl0 -w traffic.rl0                   <span class="cmt"># 把数据报文写入二进制文件</span>
# tcpdump -r traffic.rl0                          <span class="cmt"># 从文件读取数据报文(也可以使用 ethereal)</span>
# tcpdump port 80                                 <span class="cmt"># 两个经典命令</span>
# tcpdump host google.com
# tcpdump -i eth0 -X port \(110 or 143\)          <span class="cmt"># 查看端口 110(POP) 或 143(IMAP)的数据报文</span>
# tcpdump -n -i eth0 icmp                         <span class="cmt"># 只捕获 ping</span>
# tcpdump -i eth0 -s 0 -A port 80 | grep GET      <span class="cmt"># -s 0 为全部包, -A 为 ASCII</span>
</pre>
另一些重要选项：
<ul style="list-style-type: none;">
  <li><code>-A</code>     显示每个包清晰文本(除了报头)</li>
  <li><code>-X</code>     显示包的 ASCII 文本</li>
  <li><code>-l</code>     使标准输出变为缓冲行形式</li>
  <li><code>-D</code>     显示所有可用网络接口</li>
</ul>

对于 Windows 可以使用 <a rel="nofollow" href="http://www.winpcap.org/">www.winpcap.org</a>。使用 windump -D 来列出网络接口。
<h3>用 nmap 扫描</h3>
<a rel="nofollow" href="http://insecure.org/nmap/">Nmap</a><span class="fn">http://insecure.org/nmap/</span> 是一个用于 OS 探测的端口扫描工具，她通常在许多发行版上有安装，并且同样可用于 Windows。如果你不扫描你的服务器，骇客们会为你做这些...
<pre># nmap cb.vu               <span class="cmt"># 扫描主机上所有保留的 TCP 端口</span>
# nmap -sP 192.168.16.0/24 <span class="cmt"># 找出在 0/24 上主机所使用的 IP<span class="fn">译注：通过使用 "-sP" 参数，进行 ping 扫描。缺省情况下，Nmap给每个扫描到的主机发送一个 ICMP echo 和一个 TCP ACK，主机对任何一种的响应都会被Nmap得到。</span></span>
# nmap -sS -sV -O cb.vu    <span class="cmt"># 做秘密 SYN 扫描来探测系统和系统服务的版本信息</span>
PORT      STATE  SERVICE             VERSION
22/tcp    open   ssh                 OpenSSH 3.8.1p1 FreeBSD-20060930 (protocol 2.0)
25/tcp    open   smtp                Sendmail smtpd 8.13.6/8.13.6
80/tcp    open   http                Apache httpd 2.0.59 ((FreeBSD) DAV/2 PHP/4.
[...]
Running: FreeBSD 5.X
Uptime 33.120 days (since Fri Aug 31 11:41:04 2007)
</pre>
其他非标准但好用的工具有 <code>hping</code> (www.hping.org)，她是一个 IP 分组组装/分析器，和 <code>fping</code> (fping.sourceforge.net)。fping 可以在一个循环队列(round-robin fashion)中扫描多种主机。

<h2 id="trafficctrl">流量控制(QoS)</h2>
流量控制管理着一个网络的队列、流量监控、调度以及其他流量设置(traffic parameters)。以下简单实用的示例使用 Linux 和 FreeBSD 的能力来更好的利用带宽。
<h3>上传限制</h3>
DSL 或有线调制解调器有一个很长的列队来提高上传吞吐量(upload throughput)。然而用一个快速的设备(如以太网)填充这个列队将大大减少交互性。这就是限制设备上传速度有用的原因，以匹配调制解调器的实际能力，这可以有效提高交互性。设置大约为 modem 最大速度的 90%。
<h4>Linux</h4>
给 512K 上传速度的 modem。
<pre># tc qdisc add dev eth0 root tbf rate 480kbit latency 50ms burst 1540
# tc -s qdisc ls dev eth0                         <span class="cmt"># 状态</span>
# tc qdisc del dev eth0 root                      <span class="cmt"># 删除队列</span>
# tc qdisc change dev eth0 root tbf rate 220kbit latency 50ms burst 1540
</pre>
<h4>FreeBSD</h4>
FreeBSD 使用 <code>dummynet</code> 来控制带宽，其配置工具为 ipfw。Pipe 用来设置限制带宽的单位[K|M]{比特/秒|字节/秒}，0 意味着没有限制。使用同样的 pipe 数字可重新配置它。举个例子，限制上传带宽为 500K。
<pre>
# kldload dummynet                                <span class="cmt"># 如有必要加载这个模块</span>
# ipfw pipe 1 config bw 500Kbit/s                 <span class="cmt"># 创建一个带宽限制的 pipe</span>
# ipfw add pipe 1 ip from me to any               <span class="cmt"># 转移所有上传进入这个 pipe</span>
</pre>
<h3>服务质量 (Quality of service)</h3>
<h4>Linux</h4>
使用 <code>tc</code> 的优先级队列来优化 VoIP。在 <a rel="nofollow" href="http://www.voip-info.org/wiki-QoS+Linux+with+HFS">voip-info.org</a> 或 <a rel="nofollow" href="http://www.howtoforge.com/voip_qos_traffic_shaping_iproute2_asterisk">www.howtoforge.com</a> 上可以看到完整的例子。假设 VoIP 使用 UDP 端口 10000:11024 并且使用 eth0 设备(也可为 ppp0 或 so)。下列命令定义了三个队列，并且用 QoS <code>0x1e</code>(设置所有位) 强制 VOIP 流量到队列 1。默认流量流入队列 3，Qos <i>Minimize-Delay</i> 流入队列 2。
<pre># tc qdisc add dev eth0 root handle 1: prio priomap 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 0
# tc qdisc add dev eth0 parent 1:1 handle 10: sfq
# tc qdisc add dev eth0 parent 1:2 handle 20: sfq
# tc qdisc add dev eth0 parent 1:3 handle 30: sfq
# tc filter add dev eth0 protocol ip parent 1: prio 1 u32 \
  match ip dport 10000 0x3C00 flowid 1:1          <span class="cmt"># 使用服务端端口范围</span>
  match ip dst 123.23.0.1 flowid 1:1              <span class="cmt"># 或/和使用服务器 IP</span>
</pre>
状态和移除：
<pre># tc -s qdisc ls dev eth0                         <span class="cmt"># queue status</span>
# tc qdisc del dev eth0 root                      <span class="cmt"># delete all QoS</span>
</pre>
<h4>计算端口范围和掩码 (mask)</h4>
用你所计算的端口掩码来定义 tc 过滤器的端口范围。查询 2^N 端口范围结尾，推断范围并转换成十六进制。这就是你的掩码 (mask)。例如 10000 -&gt; 11024，它的范围是 1024。
<pre># 2^13 (8192) &lt; 10000 &lt; 2^14 (16384)              <span class="cmt"># 结尾是 2^14 = 16384</span>
# echo "obase=16;(2^14)-1024" | bc                <span class="cmt"># 掩码是 0x3C00</span>
</pre>

<h4>FreeBSD</h4>
假设最大连接带宽为 500Kbit/s，我们使用优先级 100:10:1 定义 3 个队列给 VoIP:ssh:剩余所有。
<pre># ipfw pipe 1 config bw 500Kbit/s 
# ipfw queue 1 config pipe 1 weight 100
# ipfw queue 2 config pipe 1 weight 10
# ipfw queue 3 config pipe 1 weight 1
# ipfw add 10 queue 1 proto udp dst-port 10000-11024
# ipfw add 11 queue 1 proto udp dst-ip 123.23.0.1 <span class="cmt"># 或/和使用服务器 IP</span>
# ipfw add 20 queue 2 dsp-port ssh
# ipfw add 30 queue 3 from me to any              <span class="cmt"># 剩余所有</span>
</pre>
状态和移除：
<pre># ipfw list                                       <span class="cmt"># 规则信息</span>
# ipfw pipe list                                  <span class="cmt"># 管道信息</span>
# ipfw flush                                      <span class="cmt"># 删除除默认外所有规则</span>
</pre>
<h2 id="nis">NIS 调试</h2>
一些可工作在已配置好的 NIS 客户端上的命令：
<pre># ypwhich                  <span class="cmt"># 获取提供 NIS 服务的服务器名</span>
# domainname               <span class="cmt"># 已配置的 NIS 域名</span>
# ypcat group              <span class="cmt"># 列印 NIS 映射 group</span>
# cd /var/yp &amp;&amp; make       <span class="cmt"># 重建 yp 数据库</span>
</pre>
ypbind 正在运行吗？
<pre># ps auxww | grep ypbind
/usr/sbin/ypbind -s -m -S servername1,servername2	<span class="cmt"># FreeBSD</span>
/usr/sbin/ypbind           <span class="cmt"># Linux</span>
# yppoll passwd.byname
Map passwd.byname has order number 1190635041. Mon Sep 24 13:57:21 2007
The master server is servername.domain.net.
</pre>
<h3>Linux</h3>
<pre># cat /etc/yp.conf
ypserver servername
domain domain.net broadcast
</pre>
</div>

<div id="ssh"><h1><a>SSH SCP</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#publickey">公钥认证</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#sshfingerprint">指纹</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#scp">SCP</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#sshtunnel">隧道(Tunneling)</a></p>
<h2 id="publickey">Public key authentication</h2>
使用公钥认证而不是密码连接主机。方法是附加你的公钥文件到远程主机。本例中我们用客户端产生的 key <b>从 <i>host-client</i> 连接到 <i>host-server</i></b>。
<ul>
  <li>使用 ssh-keygen 生成密钥对。私钥放在 <code>~/.ssh/id_dsa</code>，公钥在 <code>~/.ssh/id_dsa.pub</code>。</li>
  <li>拷贝你的公钥到服务器的 <code>~/.ssh/authorized_keys2</code>。</li>
</ul>
<pre># ssh-keygen -t dsa -N ''
# cat ~/.ssh/id_dsa.pub | ssh you@host-server "cat - &gt;&gt; ~/.ssh/authorized_keys2"
</pre>

<h3>使用来自 ssh.com 的 Windows 客户端</h3>
ssh.com 的非商业性版本的客户端可下载自它主 FTP 站点：<a rel="nofollow" href="http://ftp.ssh.com/pub/ssh/">ftp.ssh.com/pub/ssh/</a>。 用 ssh.com 客户端产生的密钥需要在 OpenSSH 服务器上进行转换。可以使用 ssh-keygen 命令来完成。
<ul>
  <li>使用 ssh.com 客户端创建一对密钥：Settings - User Authentication - Generate New....</li>
  <li>我使用 DSA 密钥类型；密钥长度为 2048。</li>
  <li>拷贝 ssh.com 客户端产生的公钥到服务器的 ~/.ssh 目录。</li>
  <li>她的密钥对在 C:\Documents and Settings\%USERNAME%\Application Data\SSH\UserKeys。</li>
  <li>在服务器上使用 ssh-keygen 转换公钥：
<pre># cd ~/.ssh
# ssh-keygen -i -f keyfilename.pub &gt;&gt; authorized_keys2
</pre></li>
</ul>

<i>注意：</i> 我们使用 DSA 密钥，使用 RSA 密钥也是可以的。这个密钥不受密码保护。
<h3>在 Windows 上使用 Putty</h3>
<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">Putty</a><span class="fn">http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</span> 是一个简单并且自由的(MIT许可)<span class="fn">译注：free 不单单是免费</span> ssh Windows 客户端。
<ul>
  <li>使用 puTTYgen 程序创建密钥对。</li>
  <li>保存密钥对(比如：C:\Documents and Settings\%USERNAME%\.ssh).</li>
  <li>拷贝公钥到服务器的 ~/.ssh 目录：
    <pre># scp .ssh/puttykey.pub root@192.168.51.254:.ssh/</pre></li>
    <li>使用 ssh-keygen 在 OpenSSH 服务器上转换这个公钥：
<pre># cd ~/.ssh
# ssh-keygen -i -f puttykey.pub &gt;&gt; authorized_keys2
</pre></li>
<li>在 Putty 中设置指向私钥的位置：Connection - SSH - Auth</li>
</ul>

<h2 id="sshfingerprint">检查指纹</h2>
在首次连接时，SSH 会请求保存不知道的主机指纹。要避免中间人(man-in-the-middle)攻击，服务器的管理员可以发送密钥指纹给客户端，来让其在首次登陆时验证服务器的真实性。使用 <code>ssh-keygen -l</code> 获取服务器的指纹：
<pre># ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub      <span class="cmt"># RSA 密钥</span>
2048 61:33:be:9b:ae:6c:36:31:fd:83:98:b7:99:2d:9f:cd /etc/ssh/ssh_host_rsa_key.pub
# ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub      <span class="cmt"># DSA 密钥(默认)</span>
2048 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee /etc/ssh/ssh_host_dsa_key.pub
</pre>
现在客户端在连接到服务器时可验证其服务器的真实性：
<pre>
# ssh linda
The authenticity of host 'linda (192.168.16.54)' can't be established.
DSA key fingerprint is 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee.
Are you sure you want to continue connecting (yes/no)? yes
</pre>
<h2 id="scp">安全文件传输</h2>
一些简单的命令：<br />
<pre># scp file.txt host-two:/tmp
# scp joe@host-two:/www/*.html /www/tmp
# scp -r joe@host-two:/www /www/tmp
</pre>
在 Konqueror 或 Midnight 控制台中，用地址 <strong>fish://user@gate</strong> 来访问远程文件系统是可行的，就是比较慢而已。<br />
此外，也可以用基于 SCP 文件系统客户端的 <strong>sshfs</strong> 来挂载一个远程目录。<a href="http://fuse.sourceforge.net/sshfs.html">看 fuse sshfs</a><span class="fn">http://fuse.sourceforge.net/sshfs.html</span>.

<h2 id="sshtunnel">隧道(Tunneling)</h2>
SSH 隧道可以让你通过 SSH 连接进行端口转发(转发/反向隧道)，从而确保了传输及端口访问的安全。它只能工作在 TCP 协议上。通常端口转发命令如下(也可看 <a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#sshnat">ssh 和 NAT 实例</a>)：
<pre># ssh -L localport:desthost:destport user@gate  <span class="cmt"># gate 为目标主机网关</span>
# ssh -R destport:desthost:localport user@gate  <span class="cmt"># 转发你的 localport 到目标端口</span>
# ssh -X user@gate   <span class="cmt"># 转发 X 程序</span>
</pre>
这将会连接到 gate 并转发端口到目标主机 desthost:destport。注意 desthost 为 gate 中的目标主机名。因此，如果连接到了 gate，那么 desthost 就是 localhost。也可以做更多的端口转发。
<h3>在 gate 上直接转发</h3>
假设我们想访问在 gate 上运行的 CVS(2401端口) 和 HTTP(80端口)。下面是个简单的例子，desthost 就是 localhost，我们使用本的端口 8080 代替 80 端口，所以我们不需要 root 权限。一旦 ssh session 打开，二个服务就都可在本地端口访问。
<pre># ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate</pre>
<h3>转发 Netbios 和远程桌面到第二个服务器</h3>
假设有一台在 gate 后面没有运行 ssh 的 Winodws SMB 服务器。我们需要访问 SMB 共享和远程桌面。
<pre># ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate</pre>
现在这个 SMB 共享可以使用 \\127.0.0.1\ 访问，但只能在本地共享关闭的情况下，因为<i>本的共享也是在 139 端口监听的</i>。<br />
保持本的共享也是可行的，因此我们需要为这个通道使用新 IP 地址来新建一个虚拟设备，SMB 共享将会使用此地址连接。此外，<i>本地 RDP 已经在 3389 端口监听了</i>，所以我们选择端口 3388。对于这个例子，让我们使用一个虚拟 IP 地址 10.1.1.1。<br />
<ul>
<li>对于 Putty 上使用源端口=10.1.1.1:139。它可以创建多重回路(multiple loop)设备和通道。在 Windows 2000 上，只有 Putty 为我工作。</li>
<li>对于 ssh.com 的客户端，要禁用 "Allow local connections only"。因为 ssh.com 客户端绑定了所有地址，所以只能连接单个共享。</li>
</ul>
现在用 IP 地址 10.1.1.1 创建回路(loopback)接口：
<ul>
<li># 系统-&gt;控制面板-&gt;添加硬件 # 是，我已经连接了此硬件(Y)
# 添加新的硬件设备(在列表最下面)。</li>
<li># 安装我手动选择的硬件 # 网络适配器 # Microsoft , Microsoft Loopback Adapter。</li>
<li>配置这个假设备的 IP 地址为 10.1.1.1，掩码 255.255.255.0，没有网关。</li>
<li>高级-&gt;WINS，开启 LMHOSTS 查询；禁用 TCP/IP 上的 NetBIOS。</li>
<li># 启用 Microsoft 网络客户端。# 禁用 Microsoft 网络文件和打印机共享</li>
</ul>
做完这些之后我有重启。现在用 \\10.1.1.1 连接 SMB 共享和用 10.1.1.1:3388 连接远程桌面。
<h4>调试</h4>
如果不能工作：
<ul>
<li>端口有没有转发：运行控制台运行 netstat -an 命令并查看有没有 0.0.0.0:139 或者 10.1.1.1:139</li>
<li>有没有 telnet 到 10.1.1.1 139？</li>
<li>你需要打开 "本地端口接受其他主机连接"。</li>
<li>"Microsoft 网络文件和打印机共享" 有没有被禁用？</li>
</ul>

<h3 id="sshnat">在 NAT 后面连接两个客户端</h3>
假设两个客户端在一个 NAT 网关后面，cliadmin 客户端要连接到 cliuser 客户端(目的地)，两者都可用 ssh 登录到正在运行 sshd 的 gate 上。你不需要 root 权限，只要端口大于 1024 即可。我们在 gate 上使用 2022 端口。而且，由于 gate 使用与本地，所以网关端口不是必须的。<br />
开启 cliuser 客户端(从目标到 gate)：
<pre># ssh -R 2022:localhost:22 user@gate            <span class="cmt"># 转发客户端 22 端口到 gate:2022 端口</span></pre>
开启 cliadmin 客户端(从主机到 gate)：
<pre># ssh -L 3022:localhost:2022 admin@gate         <span class="cmt"># 转发客户端 3022 端口到 gate:2022 端口</span></pre>
现在 admin 可以直接连接 cliuser 客户端：
<pre># ssh -p 3022 admin@localhost                   <span class="cmt"># local:3022 -&gt; gate:2022 -&gt; client:22</span></pre>

<h3>在 NAT 后面的 VNC 连接</h3>
假设一个在 NAT 后面，监听在端口 5900 上可被访问的 Windows VNC 客户端。<br />
开启 cliwin 客户端到 gate：
<pre># ssh -R 15900:localhost:5900 user@gate</pre>
开启 cliadmin 客户端(从主机到 gate)：
<pre># ssh -L 5900:localhost:15900 admin@gate</pre>
现在 admin 直接连接到 VNC 客户端：
<pre># vncconnect -display :0 localhost</pre>
</div>

<div id="vpn"><h1><a>使用 SSH 建立 VPN</a></h1>
自 4.3 版开始，OpenSSH 可以使用 tun/tap<span class="fn">译注：tun 为虚拟点对点设备，tap 为虚拟以太网设备。</span> 设备来加密一个隧道。其非常类似于基于 TLS 的 VPN 解决方案(像 OpenVPN)。对于 SSH 的一个优势是，她不需要安装和配置额外的软件。另外隧道使用 SSH 认证(像共享密钥)。
其缺点是，对于一个缓慢的连接， 其传输效率较低。并且这个隧道依赖于单个(易断的) TCP 链接。这个技术对于快速设置一个基于 IP 的 VPN 来说非常有用。她对于用单个 TCP 端口转发没有限制，并且在所有 3/4 层 协议像 ICMP、TCP/UDP 等上都可用。不管怎么样，下面这些选择在 sshd_conf 文件中是必须的：
<pre>PermitRootLogin yes
PermitTunnel yes
</pre>

<h2 id="sshp2p">单个 P2P 连接</h2>
这里，我们用点对点隧道连接 hclient 和 hserver 两个主机。这个连接是<i>从 hclient 开始</i>到 hserver 的，并且是用 root 来做。这个通道的连接点是 10.0.1.1(服务端)和 10.0.1.2(客户端)，然后我们创建设备 tun5(当然也可以是其它数字)。这个过程非常简单：
<ul>
  <li>使用 SSH 的通道选项 -w 来连接</li>
  <li>设置隧道的 IP 地址。服务端和客户端各一次。</li>
</ul>
<h3>连接到服务端</h3>
连接始于客户端,然后再服务端执行命令。
<h4>Linux上的服务端</h4>
<pre><span class="cmt">cli&gt;#</span> ssh -w5:5 root@hserver
<span class="cmt">srv&gt;#</span> ifconfig tun5 10.0.1.1 netmask 255.255.255.252   <span class="cmt"># 在服务端 shell 上执行</span>
</pre>
<h4>FreeBSD上的服务端</h4>
<pre><span class="cmt">cli&gt;#</span> ssh -w5:5 root@hserver
<span class="cmt">srv&gt;#</span> ifconfig tun5 10.0.1.1 10.0.1.2                  <span class="cmt"># 在服务端 shell 上执行</span>
</pre>

<h3>连接到客户端</h3>
在客户端上执行命令：
<pre><span class="cmt">cli&gt;#</span> ifconfig tun5 10.0.1.2 netmask 255.255.255.252   <span class="cmt"># Linux上的客户端</span>
<span class="cmt">cli&gt;#</span> ifconfig tun5 10.0.1.2 10.0.1.1                  <span class="cmt"># FreeBSD上的客户端</span>
</pre>
现在两个主机都连上了，并且可以在任何 3/4 层协议上使用此通道 IP 地址透明的通讯。

<h2 id="sshg2g">连接两个网络</h2>
除上面的 p2p 设置外，一个更有用的是SSH VPN 用两个 gate 连接两个私有网络。假设有这样一个例子，netA 为 192.168.51.0/24 还有 netB 为  192.168.16.0/24。设置过程同上面相似，我们只需要添加 routing。如果 gate 不同于默认网关，那在私有网络接口上必须开启 NAT。<br />
192.168.51.0/24 (netA)|gateA &lt;-&gt; gateB|192.168.16.0/24 (netB)<br />
<ul>
  <li>使用隧道选项 -w 连接 SSH。</li>
  <li>配置隧道的 IP 地址。服务端和客户端各一次。</li>
  <li>为两个网络添加 routing。</li>
  <li>如果需要，在 gate 的私有网络接口上开启 NAT。</li>
</ul>
设置是<i>从 netA 中的 gasteA 开始的</i>.
<h3>连接 gateA 到 gateB</h3>
连接从 gateA 开始，命令执行于 gateB。
<h4>Linux 上的 gateB</h4>
<pre><span class="cmt">gateA&gt;#</span> ssh -w5:5 root@gateB
<span class="cmt">gateB&gt;#</span> ifconfig tun5 10.0.1.1 netmask 255.255.255.252 <span class="cmt"># 在 gateB 的 shell 中执行</span>
<span class="cmt">gateB&gt;#</span> route add -net 192.168.51.0 netmask 255.255.255.0 dev tun5
<span class="cmt">gateB&gt;#</span> echo 1 &gt; /proc/sys/net/ipv4/ip_forward         <span class="cmt"># 如果不是默认网关</span>
<span class="cmt">gateB&gt;#</span> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</pre>
<h4>FreeBSD 上的 gateB</h4>
<pre><span class="cmt">gateA&gt;#</span> ssh -w5:5 root@gateB                          <span class="cmt"># 创建 tun5 设备</span>
<span class="cmt">gateB&gt;#</span> ifconfig tun5 10.0.1.1 10.0.1.2               <span class="cmt"># 在 gateB 的 shell 中执行</span>
<span class="cmt">gateB&gt;#</span> route add 192.168.51.0/24 10.0.1.2
<span class="cmt">gateB&gt;#</span> sysctl net.inet.ip.forwarding=1               <span class="cmt"># 如果不是默认网关</span>
<span class="cmt">gateB&gt;#</span> natd -s -m -u -dynamic -n fxp0                <span class="cmt"># 看 <a class="xref" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#nat">NAT</a></span>
<span class="cmt">gateA&gt;#</span> sysctl net.inet.ip.fw.enable=1
</pre>

<h3>配置 gateA</h3>
在 gateA 上执行命令：
<h4>Linux 上的 gateA</h4>
<pre><span class="cmt">gateA&gt;#</span> ifconfig tun5 10.0.1.2 netmask 255.255.255.252
<span class="cmt">gateA&gt;#</span> route add -net 192.168.16.0 netmask 255.255.255.0 dev tun5
<span class="cmt">gateA&gt;#</span> echo 1 &gt; /proc/sys/net/ipv4/ip_forward
<span class="cmt">gateA&gt;#</span> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</pre>
<h4>FreeBSD 上的 gateA</h4>
<pre><span class="cmt">gateA&gt;#</span> ifconfig tun5 10.0.1.2 10.0.1.1
<span class="cmt">gateA&gt;#</span> route add 192.168.16.0/24 10.0.1.2
<span class="cmt">gateA&gt;#</span> sysctl net.inet.ip.forwarding=1
<span class="cmt">gateA&gt;#</span> natd -s -m -u -dynamic -n fxp0                <span class="cmt"># 看 <a class="xref" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#nat">NAT</a></span>
<span class="cmt">gateA&gt;#</span> sysctl net.inet.ip.fw.enable=1
</pre>
现在两个私有网络都可以通过 SSH VPN 来透明的连接。如果 gate 不是默认网关，那么 IP 转发和 NAT 设置都是必须的。在这种情况下，客户端将不知道在哪里转发响应(response)，并且 NAT 必须是开启的。
</div>

<div id="rsync"><h1><a>RSYNC</a></h1>
Rsync 差不多可以代替 cp 和 scp，此外，断点续传是重启有效的。尾部的斜杠也有着不同的意思，请阅读 man 页面......这里有一些例子：<br />
拷贝目录中所有内容：
<pre># rsync -a /home/colin/ /backup/colin/
# rsync -a /var/ /var_bak/
# rsync -aR --delete-during /home/user/ /backup/      <span class="cmt"># 使用相对路径(看下面)</span>
</pre>
同之前一样，但使用了压缩和网络。Rsync 使用 SSH 进行传输，并且使用 SSH 密钥，如果设置的话。和 SCP 一样使用 ":"。一个典型的拷贝：
<pre># rsync -axSRzv /home/user/ user@server:/backup/user/</pre>
排除在 /home/user/ 中任何 tmp 目录，并且保持相对目录层次结构，远程目录的结构就是 /backup/home/user/。典型的用于备份的命令。
<pre># rsync -azR --exclude /tmp/ /home/user/ user@server:/backup/</pre>

SSH 连接使用端口 20022：
<pre># rsync -az -e 'ssh -p 20022' /home/colin/ user@server:/backup/colin/</pre>
使用 rsync 守护进程(使用"::")是很快的，但没有透过 SSH 加密。 位置 /backup 定义在了配置文件 /etc/rsyncd.conf 中。变量 RSYNC_PASSWORD 可以设置用来免除手动输入密码。
<pre># rsync -axSRz /home/ ruser@hostname::rmodule/backup/
# rsync -axSRz ruser@hostname::rmodule/backup/ /home/    <span class="cmt"># 回拷贝</span>
</pre>
一些重要选项：
<ul style="list-style-type: none;">
  <li><code>-a, --archive</code><span style="padding-left: 84px;"> 归档模式，等于 -rlptgoD (非 -H)</span></li>
  <li><code>-r, --recursive</code><span style="padding-left: 72px;"> 对子目录以递归模式处理</span></li>
  <li><code>-R, --relative</code><span style="padding-left: 78px;"> 使用相对路径名</span></li>
  <li><code>-H, --hard-links</code><span style="padding-left: 64px;"> 保留硬链结</span></li>
  <li><code>-S, --sparse</code><span style="padding-left: 93px;"> 对稀疏文件进行特殊处理以节省DST的空间</span></li>
  <li><code>-x, --one-file-system</code><span style="padding-left: 30px;"> 不跨越文件系统边界</span></li>
  <li><code> --exclude=PATTERN</code><span style="padding-left: 58px;"> 指定排除不需要传输的文件模式</span></li>
  <li><code> --delete-during</code><span style="padding-left: 72px;"> 传输期间删除</span></li>
  <li><code> --delete-after</code><span style="padding-left: 80px;"> 传输结束以后再删除</span></li>
</ul>

<h2 id="winrsync">在 Windows 上使用 Rsync</h2>
可以通过 cygwin 或 独立打包的 <a href="http://sourceforge.net/projects/sereds/">cwrsync</a><span class="fn">http://sourceforge.net/projects/sereds</span> 来在 Windows 上运行 rsync。这对于自动备份来说非常方便。只装其中一个(<i>不是两个</i>)，然后添加路径到 Windows 系统变量中：# 控制面板 -&gt; 系统 -&gt; 高级标签，环境变量按钮。编辑 "Path" 添加 rsync 的安装路径，比如：C:\Program Files\cwRsync\bin 或者 C:\cygwin\bin。这可以让 <code>rsync</code> 和 <code>ssh</code> 可用于 Windows 命令窗口中。
<h3>公钥认证</h3>
Rsync 是自动使用 SSH 隧道的，因此在服务端使用 SSH 认证。自动备份可免受用户的影响，rsync 命令对于使用 SSH 公钥认证可以不需要密码。<br />
下面所有的命令都可在 windows 控制台中执行。在控制台(开始 -&gt; 运行 -&gt; cmd)中像在 <a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#ssh">SSH</a> 中描述的那样创建和上传密钥，根据你的情况改变 "user" 和 "server"。如果文件 authorized_keys2 不存在，拷贝 id_dsa.pub 成 authorized_keys2 并上传它。
<pre># ssh-keygen -t dsa -N ''                   <span class="cmt"># 创建密钥对</span>
# rsync user@server:.ssh/authorized_keys2 . <span class="cmt"># 从服务器拷贝本地文件</span>
# cat id_dsa.pub &gt;&gt; authorized_keys2        <span class="cmt"># 或者使用编辑器添加这个公钥</span>
# rsync authorized_keys2 user@server:.ssh/  <span class="cmt"># 拷贝文件回服务器</span>
# del authorized_keys2                      <span class="cmt"># 删除本地拷贝</span>
</pre>
现在测试一下(在同一行里面):
<pre>rsync -rv "/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/" \
'user@server:My\ Documents/'
</pre>
<h3>自动备份</h3>
使用批处理文件自动备份并添加到任务计划(程序 -&gt; 附件 -&gt; 系统工具 -&gt; 任务计划)。举个例子，创建批处理文件 backup.bat 取代 user@server。
<pre>@ECHO OFF
REM rsync the directory My Documents
SETLOCAL
SET CWRSYNCHOME=C:\PROGRAM FILES\CWRSYNC
SET CYGWIN=nontsec
SET CWOLDPATH=%PATH%
REM uncomment the next line when using cygwin
SET PATH=%CWRSYNCHOME%\BIN;%PATH%
echo Press Control-C to abort
rsync -av "/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/" \
'user@server:My\ Documents/'
pause
</pre>
</div>

<div id="sudo"><h1><a>SUDO</a></h1>
Sudo 可以给用户一些超级用户的权限而不需要 root 密码。Sudo 对于一个服务器和工作站混合的多用户环境来说非常有用。使用 sudo 运行命令：
<pre># sudo /etc/init.d/dhcpd restart            <span class="cmt"># 用 root 权限运行 rc 脚本</span>
# sudo -u sysadmin whoami                   <span class="cmt"># 使用其他用户运行命令</span>
</pre>
<h2>配置</h2>
Sudo 的配置在 <code>/etc/sudoers</code> 中，并且只能用 <code>visudo</code> 编辑<span class="fn">译注：并不是说不能用其他编辑器编辑，而是因为 <code>visudo</code> 会对其语法进行严格检查，避免给系统带来严重后果。</span>。其基本语法是(列表是以逗号分隔的)：
<pre>user hosts = (runas) commands          <span class="cmt"># 在 /etc/sudoers</span> 中</pre>        
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li><code>users</code> 一个或多个用户或是%用户组(像 %wheel) 来获得权限</li>
  <li><code>hosts</code> 主机列表(或 ALL)</li>
  <li><code>runas</code> 列出用户以何种身份(或 ALL)来执行命令，放在 ( ) 内！</li>
  <li><code>commands</code> 列出可被 users 以 runas 或 root 权限运行的命令(或 ALL)</li>
</ul>
另外一些关键字可以定义别名，他们是 User_Alias, Host_Alias, Runas_Alias 和 Cmnd_Alias。这对于一些较大的设置比较有用。下面是 sudoers 例子：
<pre># cat /etc/sudoers
<span class="cmt"># 主机别名</span>
Host_Alias   DMZ     = 212.118.81.40/28
Host_Alias   DESKTOP = work1, work2

<span class="cmt"># 用户别名 和 runas 别名</span>
User_Alias   ADMINS  = colin, luca, admin
User_Alias   DEVEL   = joe, jack, julia
Runas_Alias  DBA     = oracle,pgsql

<span class="cmt"># 命令别名，其值为全路径命令</span>
Cmnd_Alias   SYSTEM  = /sbin/reboot,/usr/bin/kill,/sbin/halt,/sbin/shutdown,/etc/init.d/
Cmnd_Alias   PW      = /usr/bin/passwd [A-z]*, !/usr/bin/passwd root <span class="cmt"># Not root pwd!</span>
Cmnd_Alias   DEBUG   = /usr/sbin/tcpdump,/usr/bin/wireshark,/usr/bin/nmap
</pre><pre><span class="cmt"># 一个真实的规则</span>
root,ADMINS  ALL     = (ALL) NOPASSWD: ALL    <span class="cmt"># ADMINS 别名中的用户可做任何事情不需要密码</span>
DEVEL        DESKTOP = (ALL) NOPASSWD: ALL    <span class="cmt"># 开发人员可在 DESKTOP 别名的主机上做任何事情</span>
DEVEL        DMZ     = (ALL) NOPASSWD: DEBUG  <span class="cmt"># 开发人员可以在 DMZ 别名的主机上使用 DEBUG 别名中的命令</span>

<span class="cmt"># 用户 sysadmin 可以在 DMZ 服务器上执行一些命令</span>
sysadmin     DMZ     = (ALL) NOPASSWD: SYSTEM,PW,DEBUG
sysadmin     ALL,!DMZ = (ALL) NOPASSWD: ALL   <span class="cmt"># 可以在非 DMZ 主机上做任何事情</span>
%dba         ALL     = (DBA) ALL              <span class="cmt"># 用户组 dba 可以运行 DBA 别名中用户权限的所有命令</span>

<span class="cmt"># 所有用户可以在 DESKTOP 别名的主机上 挂载/卸载 CD-ROM</span>
ALL          DESKTOP = NOPASSWD: /sbin/mount /cdrom,/sbin/umount /cdrom
</pre> 

</div>

<div id="crypt"><h1><a>文件加密</a></h1>
<h2>单个文件</h2>
加密和解密：
<pre># openssl des -salt -in file -out file.des
# openssl des -d -salt -in file.des -out file
</pre>
那个 file 可以是归档文件(tar archive)。
    
<h2>归档并加密整个目录</h2>
<pre># tar -cf - directory | openssl des -salt -out directory.tar.des      <span class="cmt"># 加密</span>
# openssl des -d -salt -in directory.tar.des | tar -x                 <span class="cmt"># 解密</span>
</pre>
    
<h2>压缩归档并加密整个目录</h2>
<pre># tar -zcf - directory | openssl des -salt -out directory.tar.gz.des  <span class="cmt"># 加密</span>
# openssl des -d -salt -in directory.tar.gz.des | tar -xz             <span class="cmt"># 解密</span>
</pre>

<ul>
<li>在使用-k mysecretpassword后，des会取消交互式的密码请求。不过，这非常不安全。</li>
<li>使用des3代替des来获得更强的加密(Triple-DES Cipher)。这同样会消耗更多的CPU。</li>
</ul>

<h2>GPG</h2>
<a href="http://gnupg.org/">GnuPG</a> 是众所周知的对邮件或任何数据进行加密和签名的软件。此外，gpg 还提供高级密钥管理系统。此章节只涵盖了文件加密，没有邮件加密、签名或者信任网络(Web-Of-Trust)。<br />
单纯的加密是一个对称式的加密算法(symmetric cipher)。在本例中，文件是用一个秘密来加密的，任何人知道了这个密码都可以对其进行解密，因此就不需要密钥。Gpg 添加后缀 ".gpg" 到已加密的文件名。
<pre># gpg -c file                        <span class="cmt"># 使用密码加密文件</span>
# gpg file.gpg                       <span class="cmt"># 文件解密(选项 -o 其他文件)</span>
</pre>
<h3>使用密钥</h3>
对于更详细的请看 <a href="http://www.madboa.com/geek/gpg-quickstart">GPG 快速上手</a><span class="fn">http://www.madboa.com/geek/gpg-quickstart</span> 和 <a href="http://aplawrence.com/Basics/gpg.html">GPG/PGP 基础</a><span class="fn">http://aplawrence.com/Basics/gpg.html</span>，特别是 <a href="http://gnupg.org/documentation">gnupg 文档</a><span class="fn">http://gnupg.org/documentation</span>。<br />
密钥对(私钥，公钥)为非对称加密技术。 要点如下：
<ul>
<li>你的公钥是用来给<i>别人</i>加密文件的并且只有你作为接收者才可以解密(甚至不是一个人加密的文件也可以解密)。公钥是公开的也就意味着可以分发。</li>
<li>用你的密码加密的私钥用来解密用<i>你的</i>公钥加密的文件。这个密钥必须保持<i>安全</i>。因为如果遗失了私钥或者密码，那么所有的文件都是使用你的公钥加密的。</li>
<li>多个密钥文件被称为密钥环(keyrings)，她可以包含一个以上的密钥。</li>
</ul>
首先生成密钥对。使用默认就行，但你至少要输入你的全名、邮件地址和可选注释。该注释对于创建相同的名字和邮件地址的多个密钥来说非常有用。此外，你应该使用"口令(passphrase)"，而不是简单的密码。
<pre># gpg --gen-key                      <span class="cmt"># 这需要一些时间</span></pre>
在 Unix 上密钥存储在 ~/.gnupg/ 中，在 Windows 上通常存储在<br />
C:/Documents and Settings/%USERNAME%/Application Data/gnupg/ 中。
<pre>~/.gnupg/pubring.gpg                 <span class="cmt"># 包含你的公钥和所有其他导入的信息</span>
~/.gnupg/secring.gpg                 <span class="cmt"># 可包含多个私钥</span>
</pre>
常用选项的简短描述：
<ul style="list-style-type: none; page-break-inside: avoid;">
  <li><b>-e</b> 加密数据</li>
  <li><b>-d</b> 解密数据</li>
  <li><b>-r</b> 为某个收件者加密('全名' 或者 'email@domain')</li>
  <li><b>-a</b> 输出经过 ascii 封装的密钥</li>
  <li><b>-o</b> 指定输出文件</li>
</ul>
本实例使用'Your Name' 和 'Alice' 作为密钥的 email 或 全名 或 部分名字的参考。举个例子，我可以使用 'Colin' or 'c@cb.vu' 给我的密钥 [Colin Barschel (cb.vu) &lt;c@cb.vu&gt;]。
<h3>只用于个人的加密</h3>
不需要导出/导入任何密钥，因为你都已经有了。
<pre># gpg -e -r 'Your Name' file                  <span class="cmt"># 使用你的公钥加密</span>
# gpg -o file -d file.gpg                     <span class="cmt"># 解密。使用 -o 指定输出文件</span>
</pre>
<h3>用密钥加密-解密</h3>
首先你需要导出给别人使用的公钥。并且你需要导入来自 Alice 她所加密文件的公钥。你可以用简单的 ascii 文档或者使用公钥服务器来保存这些密钥。<br />
举个例子，Alice 导出她的公钥，然后你导入它，之后你就可以加密一个文件给她。这个加密文件只有 Alice 可以解密。
<pre># gpg -a -o alicekey.asc --export 'Alice'               <span class="cmt"># Alice 导出她的公钥到 ascii 文件中</span>
# gpg --send-keys --keyserver subkeys.pgp.net KEYID     <span class="cmt"># Alice 把她的公钥放入一个服务器</span>
# gpg --import alicekey.asc                             <span class="cmt"># 你导入她的密钥到你的公钥环(pubring)中</span>
# gpg --search-keys --keyserver subkeys.pgp.net 'Alice' <span class="cmt"># 或者从一个服务器中获取他的公钥</span>
</pre>
一旦这些公钥导入后，加密或解密一个文件会非常简单：
<pre># gpg -e -r 'Alice' file                      <span class="cmt"># 给 Alice 加密文件</span>
# gpg -d file.gpg -o file                     <span class="cmt"># 解密 Alice 给你的加密文件</span>
</pre>
<h3>密钥管理</h3>
<pre># gpg --list-keys                             <span class="cmt"># 列出所有公钥并查看其 KEYID</span>
    <span class="cmt">KEYID 跟在 '/' 后面 比如：pub   1024D/D12B77CE 它的 KEYID 是 D12B77CE</span>
# gpg --gen-revoke 'Your Name'                <span class="cmt"># 产生一份撤销密钥证书</span>
# gpg --list-secret-keys                      <span class="cmt"># 列出所有私钥</span>
# gpg --delete-keys NAME                      <span class="cmt"># 从本的密钥环中删除一个公钥</span>
# gpg --delete-secret-key NAME                <span class="cmt"># 从本的密钥环中删除一个私钥</span>
# gpg --fingerprint KEYID                     <span class="cmt"># 显示 KIYID 这个密钥的指纹</span>
# gpg --edit-key KEYID                        <span class="cmt"># 编辑密钥(比如签名或者添加/删除 email)</span>
</pre>

</div>

<div id="cryptpart"><h1><a>分区加密</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#wluks">Linux with LUKS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#woluks">Linux dm-crypt only</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#bsdgeli">FreeBSD GELI</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#bsdpwd">FreeBSD 只使用密码</a></p>
有(许多)其他替代方法来加密磁盘，我只呈现我所知道和使用的方法。请记住，安全只是系统还未经过实际考验而已。入侵者可以轻易通过键盘事件记录密码。此外，当已经加载了分区，其数据是可以自由访问的，并不会阻止入侵者去访问它。
<h2 id="dm-crypt">Linux</h2>
这部分我们使用可用于 2.6 内核的 Linux dm-crypt (device-mapper)。在这个实例中，让我们加密 <code>/dev/sdc1</code> 分区，它可为任何其他分区、磁盘、USB或者用 <code>losetup</code> 创建的基于文件的分区。对于基于文件的分区，我们使用 <code>/dev/loop0</code>。看 <a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#losetup">镜像文件分区</a>。Device mapper 利用标签来标识一个分区。我们使用 <code>sdc1</code> 作为此标签，但可以为任何字符串。
<h3 id="wluks">dm-crypt with LUKS</h3>
LUKS 和 dm-crypt 是较好的加密技术，并且可为同一个分区设置多个口令，更改密码也很方便。可简单输入 <code># cryptsetup --help</code> 来测试 LUKS 是否可用。如果没有显示任何关于 LUKS 的信息，可看下面<a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#woluks">Without LUKS</a> 的介绍。第一步如果需要的话创建一个分区：<code>fdisk /dev/sdc</code>。
<h4>创建加密分区</h4>
<pre># dd if=/dev/urandom of=/dev/sdc1          <span class="cmt"># 可选</span>
# cryptsetup -y luksFormat /dev/sdc1       <span class="cmt"># 这破坏了在 sdc1 上的数据</span>
# cryptsetup luksOpen /dev/sdc1 sdc1
# mkfs.ext3 /dev/mapper/sdc1               <span class="cmt"># 创建 ext3 文件系统</span>
# mount -t ext3 /dev/mapper/sdc1 /mnt
# umount /mnt
# cryptsetup luksClose sdc1                <span class="cmt"># Detach 已加密的分区</span></pre>
<h4>Attach</h4>
<pre># cryptsetup luksOpen /dev/sdc1 sdc1
# mount -t ext3 /dev/mapper/sdc1 /mnt</pre>
<h4>Detach</h4>
<pre># umount /mnt
# cryptsetup luksClose sdc1
</pre>
<h3 id="woluks">dm-crypt without LUKS</h3>
<pre># cryptsetup -y create sdc1 /dev/sdc1      <span class="cmt"># 或任何其他分区像 /dev/loop0</span>
# dmsetup ls                               <span class="cmt"># 检查一下，将显示：sdc1 (254, 0)</span>
# mkfs.ext3 /dev/mapper/sdc1               <span class="cmt"># 只有第一次要这么做！</span>
# mount -t ext3 /dev/mapper/sdc1 /mnt
# umount /mnt/
# cryptsetup remove sdc1                   <span class="cmt"># Detach 已加密的分区</span>
</pre>
这样做等同于(非 mkfs 部分) re-attach 分区。如果密码不正确，mount 命令将会失败。对于这个例子，只要简单的移除 sdc1 (<code>cryptsetup remove sdc1</code>)并重建即可。
<h2 id="bsdgeli">FreeBSD</h2>
两个流行的 FreeBSD 磁盘加密模块为 <code>gbde</code> 和 <code>geli</code>。我现在使用 <code>geli</code> 原因是它够快并且它使用加解密硬件加速设备。详情可看 <a href="http://www.freebsd.org/handbook/disks-encrypting.html">FreeBSD 使用手册 18.6</a><span class="fn">http://www.freebsd.org/handbook/disks-encrypting.html</span>。<code>geli</code> 模块必须已编译或加载进内核：
<pre>options GEOM_ELI
device crypto                                       <span class="cmt"># 内核配置文件中加入这两行</span>
# echo 'geom_eli_load="YES"' &gt;&gt; /boot/loader.conf   <span class="cmt"># 也可以在系统引导时加载或者做：kldload geom_eli</span>
</pre>
<h3>使用密码和密钥</h3>
我为一个典型的磁盘加密使用这些设置，其使用了一个口令和一个加密主密钥(master key)的密钥。这意味着你需要密码和生产的密钥 <code>/root/ad1.key</code> 来 attach 分区。主密钥存储在这个加密分区中并且不可见。看下面为 USB 或 映像文件的加密设置。
<h4>创建加密分区</h4>
<pre>
# dd if=/dev/random of=/root/ad1.key bs=64 count=1  <span class="cmt"># 加密主密钥的密钥</span>
# geli init -s 4096 -K /root/ad1.key /dev/ad1       <span class="cmt"># 对于磁盘也可用 -s 8192</span>
# geli attach -k /root/ad1.key /dev/ad1             <span class="cmt"># 将 /dev/ad1 与所生成的密钥 /root/ad1.key 关联</span>
# dd if=/dev/random of=/dev/ad1.eli bs=1m           <span class="cmt"># 可选，需要很长时间</span>
# newfs /dev/ad1.eli                                <span class="cmt"># 创建文件系统</span>
# mount /dev/ad1.eli /mnt
</pre>
<h4>Attach</h4>
<pre># geli attach -k /root/ad1.key /dev/ad1
# fsck -ny -t ffs /dev/ad1.eli                      <span class="cmt"># 检查文件系统</span>
# mount /dev/ad1.eli /mnt
</pre>
<h4>Detach</h4>
Detach 步骤会在关机时自动完成。
<pre># umount /mnt
# geli detach /dev/ad1.eli
</pre>
<h4>/etc/fstab</h4>
加密分区在 /etc/fstab 中配置成自动加载。系统启动时会询问加密分区的密码。对于本例下列设置是必须的：
<pre># grep geli /etc/rc.conf
geli_devices="ad1"
geli_ad1_flags="-k /root/ad1.key"
# grep geli /etc/fstab
/dev/ad1.eli         /home/private              ufs             rw      0       0
</pre>
<h3 id="bsdpwd">仅用密码</h3>
加密一个 USB stick 或者映像文件使用密码而不是密钥来得更方便。这种情况下，没有必要随身携带额外的密钥文件。所做步骤同上面非常相似，只是不需要密钥文件。让我们来加密一个 1 GB 的映像文件<code>/cryptedfile</code>。
<pre># dd if=/dev/zero of=/cryptedfile bs=1M count=1000  <span class="cmt"># 1 GB 文件</span>
# mdconfig -at vnode -f /cryptedfile
# geli init /dev/md0                                <span class="cmt"># 仅用密码加密</span>
# geli attach /dev/md0
# newfs -U -m 0 /dev/md0.eli
# mount /dev/md0.eli /mnt
# umount /dev/md0.eli
# geli detach md0.eli
</pre>
现在可以把这个映像文件加载成仅需密码的文件系统。
<pre># mdconfig -at vnode -f /cryptedfile
# geli attach /dev/md0
# mount /dev/md0.eli /mnt
</pre>
</div>

<div id="certs"><h1><a>SSL 认证</a></h1>
所谓的 SSL/TLS 认证是加密的公钥认证，它由一个公用密钥和私用密钥组成。证书用来认证终端和加密数据的。例如，用在 web 服务器(https)或者邮件服务器(imaps)。
<h2>步骤</h2>
<ul>
<li>我们需要一个证书颁发机构来签署我们的证书。这一步通常由供应商提供，如 Thawte、Verisign等。不过，我们也可以创建我们自己的。</li>
<li>创建一个证书签发申请(signing request)。这个申请需要一个已经包含所有必需的信息的未签署证书(公共部分)。该证书申请通常发送到认证供应商去签署。这一步同样也在本地机器上创建了私钥。</li>
<li>证书颁发机构签署证书。</li>
<li>如果有需要，加入证书和密钥到单个文件来给应用程序使用(web 服务器、邮件服务器等）。</li>
</ul>

<h2>配置 OpenSSL</h2>
我们使用 /usr/local/certs 作为这个例子的目录或者根据你的设置相应的编辑 /etc/ssl/openssl.cnf 文件，因此你知道文件将创建在哪里。以下是 openssl.cnf 的相关部分：
<pre>[ CA_default ]
dir             = /usr/local/certs/CA       <span class="cmt"># 保存所有信息的文件夹</span>
certs           = $dir/certs                <span class="cmt"># 已生成证书的默认保存目录</span>
crl_dir         = $dir/crl                  <span class="cmt"># 生成的证书撤销列表(CRL)的默认保存目录</span>
database        = $dir/index.txt            <span class="cmt"># 保存已签发证书的文本数据库文件</span>
</pre>
确保所有目录已经创建
<pre># mkdir -p /usr/local/certs/CA
# cd /usr/local/certs/CA
# mkdir certs crl newcerts private
# echo "01" &gt; serial                        <span class="cmt"># 仅当 serial 不存在时</span>
# touch index.txt
</pre>

<h2 id="createca">创建一个认证授权</h2>

如果你没有来自供应商的认证授权，你必须创建你自己的。如果打算去供应商签署申请，那么这个步骤不是必须的。创建认证授权 (CA)：
<pre># openssl req -new -x509 -days 730 -config /etc/ssl/openssl.cnf \
-keyout CA/private/cakey.pem -out CA/cacert.pem
</pre>

<h2 id="createreq">创建证书签发申请</h2>
要创建一个新证书(比如给邮件服务器或 web 服务器)，首先用其私钥创建证书申请。如果你的应用程序不支持加密的私钥(比如  UW-IMAP 就不支持)，那么就用 <code>-nodes</code> 来禁用加密。
<pre># openssl req -new -keyout newkey.pem -out newreq.pem \
-config /etc/ssl/openssl.cnf
# openssl req -nodes -new -keyout newkey.pem -out newreq.pem \
-config /etc/ssl/openssl.cnf                <span class="cmt"># 不对这个密钥加密</span>
</pre>

<h2 id="signcert">签署证书</h2>
该证书申请由 CA 签发确认，这个步骤通常由供应商完成。<i>注意：在下面命令中替换 "servername" 成你的服务器名称</i>。
<pre># cat newreq.pem newkey.pem &gt; new.pem
# openssl ca -policy policy_anything -out servernamecert.pem \
-config /etc/ssl/openssl.cnf -infiles new.pem
# mv newkey.pem servernamekey.pem
</pre>
现在，servernamekey.pem 就是私钥，servernamecert.pem 就为服务器的证书。

<h2>创建联合认证(united certificate)</h2>
IMAP 服务器想要私钥和服务器证书在同一个文件中。通常，这还是比较容易处理的，但是该文件要保证安全! Apache 也可以处理好它。创建一个包含证书和密钥的文件 servername.pem 。
<ul>
  <li>用文本编辑器打开私钥文件(servernamekey.pem)，并拷贝私钥到 "servername.pem" 文件中去。</li>
  <li>服务器证书(servernamecert.pem)也做同样的动作。</li>
</ul>
最后 servername.pem 文件应该看起来像这样：<br /><br />
<pre>-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDutWy+o/XZ/[...]qK5LqQgT3c9dU6fcR+WuSs6aejdEDDqBRQ
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIIERzCCA7CgAwIBAgIBBDANB[...]iG9w0BAQQFADCBxTELMAkGA1UEBhMCREUx
-----END CERTIFICATE-----
</pre>
现在我们的 /usr/local/certs/ 目录中有了这些；
<ul style="list-style-type: none;">
  <li>CA/private/cakey.pem <i>(CA 服务器私钥)</i></li>
  <li>CA/cacert.pem <i>(CA 服务器公钥)</i></li>
  <li>certs/servernamekey.pem <i>(服务器私钥)</i></li>
  <li>certs/servernamecert.pem <i>(服务器已签署的证书)</i></li>
  <li>certs/servername.pem <i>(私钥和服务器证书)</i></li>
</ul>
要保证私钥的安全!

<h2 id="viewcert">查看证书信息</h2>
要查看证书信息，只要这么做：
<pre># openssl x509 -text -in servernamecert.pem      <span class="cmt"># 显示证书信息</span>
# openssl req -noout -text -in server.csr        <span class="cmt"># 显示申请信息</span>
# openssl s_client -connect cb.vu:443            <span class="cmt"># 检查 web 服务器认证信息</span>
</pre>
</div>


<div id="cvs"><h1><a>CVS</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cvssetup">服务器设置</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cvstest">CVS 测试</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cvsssh">SSH 隧道</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cvsusage">CVS 使用</a></p>
<h2 id="cvssetup">服务器设置</h2>
<h3>CVS 环境初始化</h3>
决定主 repository 将要创建和重置的 cvs 根目录。比如 /usr/local/cvs (根)：
<pre># mkdir -p /usr/local/cvs
# setenv CVSROOT /usr/local/cvs      <span class="cmt"># 设置 CVSROOT 环境变量(本地)</span>
# cvs init                           <span class="cmt"># 创建所有初始化 CVS 配置文件</span>
# cd /root
# cvs checkout CVSROOT               <span class="cmt"># 签出配置文件来修改他们</span>
# cd CVSROOT
edit config ( fine as it is)
# cvs commit config
cat &gt;&gt; writers                       <span class="cmt"># 创建 writers 文件 (也可为 readers)</span>
colin
^D                                   <span class="cmt"># 使用 [Control][D] 退出编辑</span>
# cvs add writers                    <span class="cmt"># 添加文件 writers 进 repository</span>
# cvs edit checkoutlist
# cat &gt;&gt; checkoutlist
writers
^D                                   <span class="cmt"># 使用 [Control][D] 退出编辑</span>
# cvs commit                         <span class="cmt"># 提交所有配置更改</span>
</pre>
添加一个 <strong>readers</strong> 文件，如果你要区分读写权限的话。<i>注意：</i> 不要在主 cvs 中直接编辑文件，而应该签出要编辑的文件，修改完成后再签入。我们所做的文件 <strong>writers</strong> 用来定义可写权限。<br />
下面有三种流行的方式去访问 CVS。前两个不需要任何进一步的配置。看 <a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#cvsroot">CVSROOT</a> 部分的实例了解如何使用它们：

<ul>
  <li>直接本的访问文件系统。用户需要有足够的权限来直接访问 CVS，除了要登录到操作系统，没有进一步的验证。然而这仅对本地 repository 才有用。</li>
  <li>使用 ext 协议通过 ssh 来远程访问。任何有 ssh shell 账户和在 CVS 服务器上可读写权限的都可直接使用 ext 协议通过 ssh 来访问 CVS，而不需要任何额外的隧道。没有服务器来处理运行在 CVS 上的验证工作。ssh 登录会去验证。</li>
  <li>用 pserver 来远程访问。这是对于有较大用户量的首选方法，用户由 CVS 的 pserver 通过一个专门的密码数据库来验证，因此不需要本地用户帐户。这种设置在下面会有说明。</li>
</ul>

<h3>用 inetd 设置网络</h3>
如果不需要网络访问，CVS 可以运行于本地。对于远程访问，在 /etc/inetd.conf (Suse 为 /etc/xinetd.d/cvs)中配置如下行，可让守护进程 inetd 启动 pserver：
<pre>cvspserver	stream  tcp  nowait  cvs  /usr/bin/cvs	cvs \
--allow-root=/usr/local/cvs pserver
</pre>
这是个用来阻断从 internet 访问 cvs 端口的好方法，可使用 ssh 隧道来远程的访问 repository。

<h3>单独认证</h3>
CVS 用户可能不是操作系统的一部分(即不是本地用户)。这其实可从安全的角度去看。简单的添加一个叫 <strong>passwd</strong> (in the CVSROOT directory) 的文件，其包含 crypt 格式的用户登录名和密码。这也可以使用 apache 的 htpasswd 工具来完成。<br />
<i>注意：</i>这个 passwd 文件仅仅是文件，可以在 CVSROOT 中直接编辑。它不能被签出。更多信息请用 htpasswd --help
<pre># htpasswd -cb passwd user1 password1  <span class="cmt"># -c 创建文件</span>
# htpasswd -b passwd user2 password2
</pre>

现在添加 <code>:cvs</code> 到每行的结尾处，用来告诉 cvs 服务器更改用户到 cvs (或任何你正在运行的 cvs 服务器下)。它看起来像这样：
<pre># cat passwd
user1:xsFjhU22u8Fuo:cvs
user2:vnefJOsnnvToM:cvs
</pre>

<h2 id="cvstest">测试它</h2>
测试作为一般用户登录(比如我)
<pre># cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs login
Logging in to :pserver:colin@192.168.50.254:2401/usr/local/cvs
CVS password:

</pre>

<h3 id="cvsroot">CVSROOT 变量</h3>
这是个环境变量用来指定 repository 的位置。对于本地使用，该变量只需设置成 repository 的目录。对于通过网络使用，传输协议必须指定。使用 <code>setenv CVSROOT string</code> (csh, tcsh shell) 或者 <code>export CVSROOT=string</code> ( sh, bash shell) 设置 CVSROOT 环境变量。
<pre># setenv CVSROOT :pserver:&lt;username&gt;@&lt;host&gt;:/cvsdirectory
<i><span class="cmt">For example:</span></i>
# setenv CVSROOT /usr/local/cvs                               <span class="cmt"># 仅限本的使用</span>
# setenv CVSROOT :local:/usr/local/cvs                        <span class="cmt"># 同上</span>
# setenv CVSROOT :ext:user@cvsserver:/usr/local/cvs           <span class="cmt"># 通过 SSH 直接访问</span>
# setenv CVS_RSH ssh                                          <span class="cmt"># ext 协议访问</span>
# setenv CVSROOT :pserver:user@cvsserver.254:/usr/local/cvs   <span class="cmt"># 通过 pserver 网络访问</span>
</pre>
一旦登录成功就可导入一个新项目进 repository：<strong>cd 进入</strong>你的项目根目录
<pre>cvs import &lt;module name&gt; &lt;vendor tag&gt; &lt;initial tag&gt;
cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs import MyProject MyCompany START
</pre>

在 repository 中有个名叫 MyProject 新项目(之后用来签出)。CVS 会导入当前目录的内容进新项目。<br /><br />
签出：
<pre># cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs checkout MyProject
<i><span class="cmt">或者</span></i>
# setenv CVSROOT :pserver:colin@192.168.50.254:/usr/local/cvs
# cvs checkout MyProject
</pre>

<h2 id="cvsssh">通过 SSH 隧道访问 CVS</h2>
我们需要两个 shell 来做这个。在第一个 shell 中，我们连接到 cvs 服务器并对 cvs 连接进行端口转发(port-forward)。在第二个 shell 中，我们就像在本地一样使用 cvs。
<br />
在 shell 1:
<pre># ssh -L2401:localhost:2401 colin@cvs_server   <span class="cmt"># 直接连接到 cvs 服务器。或：</span>
# ssh -L2401:cvs_server:2401 colin@gateway     <span class="cmt"># 使用一个网关间接连接到 cvs 服务器</span></pre>
在 shell 2:
<pre># setenv CVSROOT :pserver:colin@localhost:/usr/local/cvs
# cvs login
Logging in to :pserver:colin@localhost:2401/usr/local/cvs
CVS password:
# cvs checkout MyProject/src
</pre>
<h2 id="cvsusage">CVS 命令及其使用</h2>
<h3>导入</h3>
该 import 命令用来添加整个目录，它必须运行于要导入的目录中。比如，目录 /devel/ 包含的所有文件和子目录要导入。该目录名在 CVS 中(模块)将会称为 "myapp"。
<pre># cvs import [options] directory-name vendor-tag release-tag
# cd /devel                          <span class="cmt"># 必须在该目录中来导入</span>
# cvs import myapp Company R1_0      <span class="cmt"># 修订(release)标签可以为任何单个单词</span>
</pre>
在添加了一个新目录 "/devel/tools/" 后，也可这么导入。
<pre># cd /devel/tools
# cvs import myapp/tools Company R1_0
</pre>
<h3>签出、更新和提交</h3>
<pre># cvs co myapp/tools                 <span class="cmt"># 仅会签出 tools 目录</span>
# cvs co -r R1_1 myapp               <span class="cmt"># 签出修订版本为 R1_1 的 myapp (sticky)</span>
# cvs -q -d update -P                <span class="cmt"># 典型的 CVS 更新</span>
# cvs update -A                      <span class="cmt"># 重置所有 sticky 标签(或日期、选项)</span>
# cvs add newfile                    <span class="cmt"># 添加一个新文件</span>
# cvs add -kb newfile                <span class="cmt"># 添加一个二进制文件</span>
# cvs commit file1 file2             <span class="cmt"># 仅提交这两个文件</span>
# cvs commit -m "message"            <span class="cmt"># 提交所有更改并为这个更改添加日志消息</span>
</pre>

<h3>创建一个 patch</h3>
It is best to create and apply a patch from the working development directory related to the project, or from within the source directory.
<pre># cd /devel/project
# diff -Naur olddir newdir &gt; patchfile <span class="cmt"># Create a patch from a directory or a file</span>
# diff -Naur oldfile newfile &gt; patchfile
</pre>
<h3>应用一个 patch</h3>
Sometimes it is necessary to strip a directory level from the patch, depending how it was created. In case of difficulties, simply look at the first lines of the patch and try -p0, -p1 or -p2.
<pre># cd /devel/project
# patch --dry-run -p0 &lt; patchfile    <span class="cmt"># Test the path without applying it</span>
# patch -p0 &lt; patchfile
# patch -p1 &lt; patchfile              <span class="cmt"># strip off the 1st level from the path</span>
</pre>
</div>

<div id="svn"><h1><a>SVN</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#svnsetup">Server setup</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#svnssh">SVN+SSH</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#svnhttp">SVN over http</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#svnusage">SVN usage</a></p>
<a href="http://subversion.tigris.org/">Subversion (SVN)</a><span class="fn">http://subversion.tigris.org/</span> is a version control system designed to be the successor of CVS (Concurrent Versions System). The concept is similar to CVS, but many shortcomings where improved. See also the <a href="http://svnbook.red-bean.com/en/1.4/">SVN book</a><span class="fn">http://svnbook.red-bean.com/en/1.4/</span>.
<h2 id="svnsetup">Server setup</h2>
The initiation of the repository is fairly simple (here for example <code>/home/svn/</code> must exist):
<pre># svnadmin create --fs-type fsfs /home/svn/project1</pre>
Now the access to the repository is made possible with:
<ul>
  <li><code>file://</code> Direct file system access with the svn client with. This requires local permissions on the file system.</li>
  <li><code>svn://</code> or <code>svn+ssh://</code> Remote access with the svnserve server (also over SSH). This requires local permissions on the file system.</li>
  <li><code>http://</code> Remote access with webdav using apache. No local users are necessary for this method.</li>
</ul>
Using the local file system, it is now possible to import and then check out an existing project. Unlike with CVS it is not necessary to cd into the project directory, simply give the full path:
<pre># svn import /project1/ file:///home/svn/project1/trunk -m 'Initial import'
# svn checkout file:///home/svn/project1
</pre>
The new directory "trunk" is only a convention, this is not required.
<h3 id="svnssh">Remote access with ssh</h3>
No special setup is required to access the repository via ssh, simply replace <code>file://</code> with <code>svn+ssh/hostname</code>. For example:
<pre># svn checkout svn+ssh://hostname/home/svn/project1</pre>
As with the local file access, every user needs an ssh access to the server (with a local account) and also read/write access. This method might be suitable for a small group. All users could belong to a subversion group which owns the repository, for example:
<pre># groupadd subversion
# groupmod -A user1 subversion
# chown -R root:subversion /home/svn
# chmod -R 770 /home/svn
</pre>
<h3 id="svnhttp">Remote access with http (apache)</h3>
Remote access over http (https) is the only good solution for a larger user group. This method uses the apache authentication, not the local accounts. This is a typical but small apache configuration:
<pre>LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so   <span class="cmt"> # Only for access control</span>
</pre><pre style="page-break-inside:avoid;">&lt;Location /svn&gt;
  DAV svn
  <span class="cmt"># any "/svn/foo" URL will map to a repository /home/svn/foo</span>
  SVNParentPath /home/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthzSVNAccessFile /etc/apache2/svn.acl
  AuthUserFile /etc/apache2/svn-passwd
  Require valid-user
&lt;/Location&gt;
</pre>
The apache server needs full access to the repository:
<pre># chown -R www:www /home/svn</pre>
Create a user with htpasswd2:
<pre># htpasswd -c /etc/svn-passwd user1 <span class="cmt"> # -c creates the file</span></pre>
<h4>Access control svn.acl example</h4>
<pre><span class="cmt"># Default it read access. "* =" would be default no access</span>
[/]
* = r
[groups]
project1-developers = joe, jack, jane
<span class="cmt"># Give write access to the developers</span>
[project1:]
@project1-developers = rw
</pre>

<h2 id="svnusage">SVN commands and usage</h2>
See also the <a rel="nofollow" href="http://www.cs.put.poznan.pl/csobaniec/Papers/svn-refcard.pdf">Subversion Quick Reference Card</a><span class="fn">http://www.cs.put.poznan.pl/csobaniec/Papers/svn-refcard.pdf</span>. <a href="http://tortoisesvn.tigris.org/">Tortoise SVN</a><span class="fn">http://tortoisesvn.tigris.org</span> is a nice Windows interface.
<h3 id="svnimport">Import</h3>
A new project, that is a directory with some files, is imported into the repository with the <code>import</code> command. Import is also used to add a directory with its content to an existing project.
<pre># svn help import                               <span class="cmt"> # Get help for any command</span>
<span class="cmt">    # Add a new directory (with content) into the src dir on project1</span>
# svn import /project1/newdir http://host.url/svn/project1/trunk/src -m 'add newdir'
</pre>
<h3 id="svntypical">Typical SVN commands</h3>
<pre># svn co http://host.url/svn/project1/trunk     <span class="cmt"> # Checkout the most recent version</span>
<span class="cmt">    # Tags and branches are created by copying</span>
# svn mkdir http://host.url/svn/project1/tags/  <span class="cmt"> # Create the tags directory</span>
# svn copy -m "Tag rc1 rel." http://host.url/svn/project1/trunk \
                             http://host.url/svn/project1/tags/1.0rc1
# svn status [--verbose]                        <span class="cmt"> # Check files status into working dir</span>
# svn add src/file.h src/file.cpp               <span class="cmt"> # Add two files</span>
# svn commit -m 'Added new class file'          <span class="cmt"> # Commit the changes with a message</span>
# svn ls http://host.url/svn/project1/tags/     <span class="cmt"> # List all tags</span>
# svn move foo.c bar.c                          <span class="cmt"> # Move (rename) files</span>
# svn delete some_old_file                      <span class="cmt"> # Delete files</span>
</pre>

</div>

<div id="other"><h1><a>实用命令</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#less">less</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#vi">vi</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#mail">mail</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#tar">tar</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#dd">dd</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#screen">screen</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#find">find</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#misccmd">混杂的</a></p>
<h2 id="less">less</h2>
<code>less</code> 命令用来在控制台中分屏显示文本文档。它在许多发行版中可用。
<pre># less unixtoolbox.xhtml</pre>
一些重要指令(^N 代表 [control]-[N])：
<ul style="list-style-type: none;">
  <li><strong>h  H</strong>       显示指令的汇总列表</li>
  <li><strong>f  ^F  ^V  SPACE</strong>       向前滚动一屏(或者 N 行)</li>
  <li><strong>b  ^B  ESC-v</strong>       向后滚动一屏(或者 N 行)</li>
  <li><strong>F</strong>       向前滚动；类似于"tail -f"</li>
  <li><strong>/pattern</strong>       向前搜索匹配该模式的行</li>
  <li><strong>?pattern</strong>       向后搜索匹配该模式的行</li>
  <li><strong>n</strong>       重复之前的搜索</li>
  <li><strong>N</strong>       反方向重复之前的搜索</li>
  <li><strong>q</strong>       退出</li>
</ul>


<h2 id="vi">vi</h2>
Vi 在任何 Linux/Unix 发行安装版(gentoo 没有?)上都存在。因此，我们有必要了解一些基本的命令。Vi 有两个模式：命令模式和插入模式。使用 <strong>[ESC]</strong> 键可进入命令模式，使用 <strong>i</strong> 键可进入插入模式。如果你迷失了，可在命令模式下键入 <code>: help</code>。<br />
编辑器 <code>nano</code> 和 <code>pico</code> 通常也都可用，而且更容易(IMHO)使用。
<h3>Quit</h3>
<ul style="list-style-type: none;">
  <li><strong>:w</strong> newfilename       保存文件为 newfilename</li>
  <li><strong>:wq or :x</strong>       保存并退出</li>
  <li><strong>:q!</strong>       退出但不保存</li>
</ul>
<h3>移动和查找</h3>
<ul style="list-style-type: none;">
  <li><strong>/string</strong>       向前查找 string</li>
  <li><strong>?string</strong>       向后查找 string</li>
  <li><strong>n</strong>       同方向重复上一次搜索命令</li>
  <li><strong>N</strong>       反方向重复上一次搜索命令</li>
  <li><strong>{</strong>       光标移至段落结尾</li>
  <li><strong>}</strong>       光标移至段落开头</li>
  <li><strong>1G</strong>       光标移至文件的第一行首</li>
  <li><strong>nG</strong>       光标移至文件的第 n 行首</li>
  <li><strong>G</strong>       光标移至文件的最后一行首</li>
  <li><strong>:%s/OLD/NEW/g</strong>       替换所有查找到的 OLD 为 NEW</li>
</ul>
<h3>删除文本</h3>
<ul style="list-style-type: none;">
  <li><strong>dd</strong>       删除当前行</li>
  <li><strong>D</strong>       删除光标到当前行末尾的字符</li>
  <li><strong>dw</strong>       删除单词</li>
  <li><strong>x</strong>       删除字符</li>
  <li><strong>u</strong>       回复上一次操作</li>
  <li><strong>U</strong>       回复所有此行的更改</li>
</ul>

<h2 id="mail">mail</h2>
<code>mail</code> 命令是一个读取和发送邮件的应用程序，她通常已安装。要发送一封邮件，可以简单的输入 "mail user@domain"。其第一行为主题，然后是邮件内容。在一个新行中使用单个点(.)来结束并发送邮件。例子：
<pre># mail c@cb.vu
Subject: Your text is full of typos
"For a moment, nothing happened. Then, after a second or so, 
nothing continued to happen."
.
EOT
#
</pre>
这同样可用于管道：
<pre># echo "This is the mail body" | mail c@cb.vu</pre>
也是测试邮件服务器的简单方法。

<h2 id="tar">tar</h2>
命令 <code>tar</code> (磁带存档) 可以为文件和目录创建档案。归档文件 .tar 是未压缩的，一个压缩过的归档文件的后缀是 .tgz 或 .tar.gz (zip) 或者 .tbz (bzip2)。不要使用绝对路径建立一个归档文件，你可能要解开这个归档文件到某个地方。一些常用命令如下：
<h3>创建</h3>
<pre># cd /
# tar -cf home.tar home/        <span class="cmt"># 归档整个 /home 目录(c 为创建)</span>
# tar -czf home.tgz home/       <span class="cmt"># 等同于 zip 压缩</span>
# tar -cjf home.tbz home/       <span class="cmt"># 等同于 bzip2 压缩</span>
</pre>
从一个目录树中只包含一个(或2个)目录，并保持相对目录结构。举个例子，/usr/local/etc 和 /usr/local/www，它们在归档文件中的第一层目录是 local/。
<pre># tar -C /usr -czf local.tgz local/etc local/www
# tar -C /usr -xzf local.tgz    <span class="cmt"># 释放 local 目录到 /usr</span>
# cd /usr; tar -xzf local.tgz   <span class="cmt"># 同上面一样</span>
</pre>
<h3>释放(Extract)</h3>
<pre># tar -tzf home.tgz             <span class="cmt"># 列出归档文件中的所有文件，并不释放</span>
# tar -xf home.tar              <span class="cmt"># 释放归档文件(x 为释放)</span>
# tar -xzf home.tgz             <span class="cmt"># 等同于 zip 压缩</span>
# tar -xjf home.tgz             <span class="cmt"># 等同于 bzip2 压缩</span>
# tar -xjf home.tgz home/colin/file.txt    <span class="cmt"># 释放单个文件</span>
</pre>
<h3>更高级的</h3>
<pre># tar c dir/ | gzip | ssh user@remote 'dd of=dir.tgz' <span class="cmt"># 归档压缩 dir/ 目录并存储到远程主机上</span>
# tar cvf - `find . -print` &gt; backup.tar              <span class="cmt"># 归档当前目录</span>
# tar -cf - -C /etc . | tar xpf - -C /backup/etc      <span class="cmt"># 拷贝目录</span>
# tar -cf - -C /etc . | ssh user@remote tar xpf - -C /backup/etc      <span class="cmt"># 远程拷贝</span>
# tar -czf home.tgz --exclude '*.o' --exclude 'tmp/' home/
</pre>
<h2 id="dd">dd</h2>
程序 <code>dd</code> (磁盘备份(disk dump) 或 destroy disk，也可看 <a href="http://roesler-ac.de/wolfram/acro/credits.htm">dd 的含义</a>) 用来拷贝分区、磁盘或者其它拷贝。通常这么用：
<pre># dd if=&lt;source&gt; of=&lt;target&gt; bs=&lt;byte size&gt; conv=&lt;conversion&gt;</pre>
重要的 conv 选项：
<ul style="list-style-type: none;">
  <li><code>notrunc</code>       不截短输出文件</li>
  <li><code>noerror</code>       出错时不停止处理(e.g. 坏扇区)</li>
  <li><code>sync</code>       把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐</li>
</ul>
默认字节大小为 512 (一个扇区)。MBR 处于磁盘的第一个扇区，之后的 63 个扇区是空的。较大的字节大小可以加快拷贝速度但也需要更多的内存。
<h3>备份和恢复</h3>
<pre># dd if=/dev/hda of=/dev/hdc bs=16065b                <span class="cmt"># 拷贝磁盘到磁盘(相同大小)</span>
# dd if=/dev/sda7 of /home/root.img bs=4096 conv=notrunc,noerror <span class="cmt"># 备份 /</span>
# dd if /home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror <span class="cmt"># 恢复 /</span>
# dd bs=1M if=/dev/ad4s3e | gzip -c &gt; ad4s3e.gz                  <span class="cmt"># 压缩备份</span>
# gunzip -dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M                 <span class="cmt"># 解压恢复</span>
# dd bs=1M if=/dev/ad4s3e | gzip | ssh eedcoba@fry 'dd of=ad4s3e.gz' <span class="cmt"># 也可为远程的</span>
# gunzip -dc ad4s3e.gz | ssh eedcoba@host 'dd of=/dev/ad0s3e bs=1M'
# dd if=/dev/ad0 of=/dev/ad2 skip=1 seek=1 bs=4k conv=noerror    <span class="cmt"># 忽略 MBR</span>
    <span class="cmt"># 如果目标(ad2)比较小，这是必须的。</span>
</pre>

<h3>恢复</h3>
该 <code>dd</code> 命令会读取分区的<i>每一个区块</i>，即所有区块。对于有问题的区块，最好使用 <code>conv=sync,noerror</code> 选项，dd 将会跳过坏的区块并入 0。因此，这就是设置块大小等于或小于磁盘块大小的重要性。1k 大小似乎安全，用 <code>bs=1k</code> 来设置它。假如一个磁盘有坏扇区并且有个分区的数据要恢复，那么用 dd 工具创建一个镜像文件，挂载这个镜像文件，然后拷贝内容到新的磁盘中。如果用了 <code>noerror</code> 选项，dd 会跳过坏扇区并写入 0，也即坏扇区中的内容会丢失。

<pre># dd if=/dev/hda of=/dev/null bs=1m                   <span class="cmt"># 检查坏扇区</span>
# dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh \ <span class="cmt"># 发送到远程</span>
root@fry 'dd of=hda1.gz bs=1k'
# dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img    <span class="cmt"># 存储为一个映像文件</span>
# mount -o loop /hda1.img /mnt                        <span class="cmt"># <a class="xref" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#createimg">挂载这个映像文件</a></span>
# rsync -ax /mnt/ /newdisk/                           <span class="cmt"># 拷贝到一个新磁盘</span>
# dd if=/dev/hda of=/dev/hda                          <span class="cmt"># 刷新磁状态</span>
  <span class="cmt"># 上面的命令对于刷新磁盘(refresh disk)很有用。这绝对安全，但必须先卸载磁盘。</span>
</pre>
<h3>删除</h3>
<pre># dd if=/dev/zero of=/dev/hdc                         <span class="cmt"># 删除全部数据</span>
# dd if=/dev/urandom of=/dev/hdc                      <span class="cmt"># 更好的删除全部数据<span class="fn">译注：/dev/urandom 设备文件提供了一种比单独使用$RANDOM更好的,能产生更"随机"的随机数的方法。</span></span>
# kill -USR1 PID                                      <span class="cmt"># 查看 dd 进度(仅Linux!)</span>
</pre>
<h3>MBR 技巧</h3>
MBR 包含了引导程序和分区表，它的大小为 512 字节。前 446 字节为引导程序，446 到 512 字节为分区表。
<pre># dd if=/dev/sda of=/mbr_sda.bak bs=512 count=1                  <span class="cmt"># 完全备份 MBR</span>
# dd if=/dev/zero of=/dev/sda bs=512 count=1                     <span class="cmt"># 删除 MBR 和分区表</span>
# dd if=/mbr_sda.bak of=/dev/sda bs=512 count=1                  <span class="cmt"># 完全恢复MBR</span>
# dd if=/mbr_sda.bak of=/dev/sda bs=446 count=1                  <span class="cmt"># 仅回复引导程序</span>
# dd if=/mbr_sda.bak of=/dev/sda bs=1 count=64 skip=446 seek=446 <span class="cmt"># 恢复分区表</span>
</pre>

<h2 id="screen">screen</h2>
Screen 提供了两个主要功能：
<ul>
<li>在一个终端内运行多个终端会话(terminal session)。</li>
<li>一个已启动的程序与运行它的真实终端分离的，因此可运行于后台。真实的终端可以被关闭，还可以在稍后再重新接上(reattached)。</li>
</ul>
<h3>简短实例</h3>
开启 screen：
<pre># screen</pre>
在 screen 会话中，我们可以开启一个长时间运行的程序(如 top)。Detach 这个终端，之后可以从其他机器 reattach 这个相同的终端(比如通过 ssh)。
<pre># top</pre>
现在用 <strong>Ctrl-a Ctrl-d</strong> 来 detach。Reattach 终端：
<pre># screen -r</pre>
或更好的：
<pre># screen -R -D</pre>
现在 attach 到这里。具体意思是：先试图恢复离线的 screen 会话。若找不到离线的 screen 会话，即建立新的 screen 会话给用户。

<h3>Screen 命令 (在 screen 中)</h3>
所有命令都以 <strong>Ctrl-a</strong> 开始。
<ul>
  <li><strong>Ctrl-a ?</strong> 各功能的帮助摘要</li>
  <li><strong>Ctrl-a c</strong> 创建一个新的 window (终端)</li>
  <li><strong>Ctrl-a Ctrl-n 和 Ctrl-a Ctrl-p</strong> 切换到下一个或前一个 window</li>
  <li><strong>Ctrl-a Ctrl-N</strong> N 为 0 到 9 的数字，用来切换到相对应的 window</li>
  <li><strong>Ctrl-a "</strong> 获取所有正在运行的 window 的可导航的列表</li>
  <li><strong>Ctrl-a a</strong> 清楚错误的 Ctrl-a</li>
  <li><strong>Ctrl-a Ctrl-d</strong> 断开所有会话，会话中所有任务运行于后台</li>
  <li><strong>Ctrl-a x</strong> 用密码锁柱 screen 终端</li>
</ul>
当程序内部运行终端关闭并且你登出该终端时，该 screen 会话就会被终止。

<h2 id="find">Find</h2>
一些重要选项：
<ul style="list-style-type: none;">
  <li><code>-x</code> (BSD) <code>-xdev</code> (Linux)       留于同一文件系统 (fstab 中的 dev)</li>
  <li><code>-exec cmd {} \;</code>       执行命令并用全路径替换 {}</li>
  <li><code>-iname</code>       同 -name 一样，但不区分大小写</li>
  <li><code>-ls</code>       显示关于文件的信息(同 ls -la)</li>
  <li><code>-size n</code>       n 为 +-n (k M G T P)</li>
  <li><code>-cmin n</code>       查找系统中最后 n 分钟改变文件状态的文件</li>
</ul>
<pre># find . -type f ! -perm -444        <span class="cmt"># 寻找所有无法读取的文件</span>
# find . -type d ! -perm -111        <span class="cmt"># 寻找所有无法访问的目录</span>
# find /home/user/ -cmin 10 -print   <span class="cmt"># 寻找最后 10 分钟创建或修改的文件</span>
# find . -name '*.[ch]' | xargs grep -E 'expr' <span class="cmt"># 在当前目录及子目录搜索 'expr' 表达式</span>
# find / -name "*.core" | xargs rm   <span class="cmt"># 寻找 core 垃圾并删除它们(也可试试 core.*)</span>
# find / -name "*.core" -print -exec rm {} \;  <span class="cmt"># 另一种语法</span>
      <span class="cmt"># 寻找图像文件并创建一个归档文件，iname 为不区分大小写。-r 为附加</span>
# find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;
# find . -type f -name "*.txt" ! -name README.txt -print  <span class="cmt"># 除 README.txt 的文件</span>
# find /var/ -size +10M -exec ls -lh {} \;     <span class="cmt"># 查找 &gt; 10 MB 的文件</span>
# find /var/ -size +10M -ls           <span class="cmt"># 这个更简单</span>
# find . -size +10M -size -50M -print
# find /usr/ports/ -name work -type d -print -exec rm -rf {} \;  <span class="cmt"># 清理 port</span>
      <span class="cmt"># 以 SUID 查找文件；这些文件很脆弱，必须保持安全。</span>
# find / -type f -user root -perm -4000 -exec ls -l {} \; 
</pre>
小心 xarg 或 exec，因为当文件或目录中包含空格时可能会返回错误的结果。在有疑惑时用 "-print0 | xargs -0" 代替 "| xargs"。选项 -print0 必须在 find 命令的最后。看这个不错的 <a href="http://www.hccfl.edu/pollock/Unix/FindCmd.htm">find 迷你教程</a><span class="fn">http://www.hccfl.edu/pollock/Unix/FindCmd.htm</span>.
<pre># find . -type f | xargs ls -l       <span class="cmt"># 不能工作于有空格的名字</span>
# find . -type f -print0 | xargs -0 ls -l  <span class="cmt"># 可工作于有空格的名字</span>
# find . -type f -exec ls -l '{}' \; <span class="cmt"># 或使用用于 -exec 的引用 '{}'</span>
</pre>
<h2 id="misccmd">混杂的</h2>
<pre># which command                      <span class="cmt"># 显示命令的全路径名</span>
# time command                       <span class="cmt"># 显示一个命令执行完成所用的时间</span>
# time cat                           <span class="cmt"># 使用 time 作为秒表，用 Ctrl-c 来停止</span>
# set | grep $USER                   <span class="cmt"># 列显当前环境变量</span>
# cal -3                             <span class="cmt"># 显示三个月日历</span>
# date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]
# date 10022155                      <span class="cmt"># 设置日期和时间</span>
# whatis grep                        <span class="cmt"># 显示命令的简短信息</span>
# whereis java                       <span class="cmt"># 查询命令的的路径和标准目录</span>
# setenv varname value               <span class="cmt"># 设置环境变量，设置变量 varname 的值为 value (csh/tcsh)</span>
# export varname="value"             <span class="cmt"># 设置环境变量，设置变量 varname 的值为 value  (sh/ksh/bash)</span>
# pwd                                <span class="cmt"># 显示当前工作目录</span>
# mkdir -p /path/to/dir              <span class="cmt"># 如果存在不显示错误，建立所需的上级目录</span>
# mkdir -p project/{bin,src,obj,doc/{html,man,pdf},debug/some/more/dirs}
# rmdir /path/to/dir                 <span class="cmt"># 移除目录</span>
# rm -rf /path/to/dir                <span class="cmt"># 移除目录和其内容(强制)</span>
# cp -la /dir1 /dir2                 <span class="cmt"># 存档、硬连接目录所有文件，用来替代拷贝</span>
# cp -lpR /dir1 /dir2                <span class="cmt"># 同上 (FreeBSD)</span>
# cp unixtoolbox.xhtml{,.bak}        <span class="cmt"># 拷贝文件成新扩展名的快速方法</span>
# mv /dir1 /dir2                     <span class="cmt"># 修改目录名</span>
</pre>
</div>

<div id="software"><h1><a>软件安装</a></h1>
<h2 id="softwarelist">列出已安装过的软件包</h2>
<pre># rpm -qa                            <span class="cmt"># 列出已安装过的软件包(RH, SuSE, 基于 RPM 的)</span>
# dpkg -l                            <span class="cmt"># Debian, Ubuntu</span>
# pkg_info                           <span class="cmt"># 列出所有已安装过的软件包(FreeBSD)</span>
# pkg_info -W smbd                   <span class="cmt"># 查看 smbd 安装了那些软件包(FreeBSD)</span>
# pkginfo                            <span class="cmt"># Solaris</span>
</pre>
<h2 id="softwareadd">添加/删除软件</h2>
前端界面：SuSE 为 yast2/yast，Red Hat 为 redhat-config-packages。
<pre># rpm -i pkgname.rpm                 <span class="cmt"># 安装软件包(RH, SuSE, 基于 RPM 的)</span>
# rpm -e pkgname                     <span class="cmt"># 删除软件包</span>
</pre>
<h3>Debian</h3>
<pre># apt-get update                     <span class="cmt"># 更新源列表</span>
# apt-get install emacs              <span class="cmt"># 安装 emacs 软件包</span>
# dpkg --remove emacs                <span class="cmt"># 删除 emacs 软件包</span>
# dpkg -S file                       <span class="cmt"># 查找拥有该 file 的软件包</span>
</pre>
<h3>Gentoo</h3>
Gentoo 使用 emerge 作为 "Portage" 软件包管理系统的核心。
<pre># emerge --sync                      <span class="cmt"># 同步更新本地 protage 树</span>
# emerge -u packagename              <span class="cmt"># 安装或更新一个软件包</span>
# emerge -C packagename              <span class="cmt"># 删除软件包</span>
# revdep-rebuild                     <span class="cmt"># 修复依赖关系的缺失</span>
</pre>
<h3>Solaris</h3>
&lt;cdrom&gt; 路径通常为 <code>/cdrom/cdrom0</code>.
<pre># pkgadd -d &lt;cdrom&gt;/Solaris_9/Product SUNWgtar
# pkgadd -d SUNWgtar                 <span class="cmt"># 添加下载的软件包(先要 bunzip2)</span>
# pkgrm SUNWgtar                     <span class="cmt"># 删除软件包</span>
</pre>
<h3>FreeBSD</h3>
<pre># pkg_add -r rsync                   <span class="cmt"># 获取并安装 rsync</span>
# pkg_delete /var/db/pkg/rsync-xx    <span class="cmt"># 删除 rsync 软件包</span>
</pre>
可使用 <code>PACKAGESITE</code> 环境变量来设置哪里可以获取软件包。举个例子：
<pre># export PACKAGESITE=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages/Latest/ 
# or ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/
</pre>
<h3>FreeBSD ports</h3>
Port 树 <code>/usr/ports/</code> 是一个准备编译和安装的软件集。可用 <code>portsnap</code> 工具来跟新 port。
<pre># portsnap fetch extract             <span class="cmt"># 当第一次运行这个命令，会创建 port 树</span>
# portsnap fetch update              <span class="cmt"># 跟新 port 树</span>
# cd /usr/ports/net/rsync/           <span class="cmt"># 选择软件安装目录</span>
# make install distclean             <span class="cmt"># 安装并清理(也可看 man ports)</span>
# make package                       <span class="cmt"># Make 一个二进制软件包</span>
</pre>

<h2 id="librarypath">库路径</h2>
由于复杂的依赖关系和运行时链接，程序难于分发或拷贝到其他系统。不过对于较少依赖关系的小程序，缺失的库可被拷贝过去。运行时库(即缺失的库)可用 <code>ldd</code> 和 <code>ldconfig</code> 来检查和管理。
<pre># ldd /usr/bin/rsync                 <span class="cmt"># 列出所有所需的运行时库</span>
# ldconfig -n /path/to/libs/         <span class="cmt"># 添加一个路径到共享库目录Add a path to the shared libraries directories</span>
# ldconfig -m /path/to/libs/         <span class="cmt"># FreeBSD</span>
# LD_LIBRARY_PATH                    <span class="cmt"># 设置连接库路径的环境变量</span>
</pre>
</div>

<div id="convert"><h1><a>媒体转换</a></h1>
有时候需要转换一个视频、音频文件或者文档成其他格式。
<h2 id="encoding">文本编码</h2>
文本编码可以得到完全错误的，特别是当语言需要某些特殊字符像 àäç。命令 <code>iconv</code> 可以从一个编码转换成另一个编码。
<pre># iconv -f &lt;from_encoding&gt; -t &lt;to_encoding&gt; &lt;input_file&gt;
# iconv -f ISO8859-1 -t UTF-8 -o file.input &gt; file_utf8
# iconv -l                           <span class="cmt"># 列显系统所支持的字符编码</span>
</pre>
若文档显示良好，通常都可不使用 -f 选项，iconv 会使用本地字符集(char-set)。
<h2 id="newlines">Unix - DOS 新行</h2>
在 Unix Shell 中转换 DOS (CR/LF) 到 Unix (LF) 新行格式。也可使用 <code>dos2unix</code> 和 <code>unix2dos</code> 工具，如果你有它们的话。
<pre># sed 's/.$//' dosfile.txt &gt; unixfile.txt
</pre>
在 Windows 环境中转换 Unix 到 Dos 新行格式。需要在 mingw 或 cygwin 中使用 sed。
<pre># sed -n p unixfile.txt &gt; dosfile.txt
</pre>

<h2>PDF 转换成 Jpeg 和 连接一串 PDF 文件</h2>
用 <code>gs</code> (GhostScript) 工具转换 PDF 文档的每一页成 jpeg (或 png)图像。也可以使用更短的 <code>convert</code> (来自 ImageMagick 或 GraphicsMagick 工具) 命令。
<pre># gs -dBATCH -dNOPAUSE -sDEVICE=jpeg -r150 -dTextAlphaBits=4 -dGraphicsAlphaBits=4 \
 -dMaxStripSize=8192 -sOutputFile=unixtoolbox_%d.jpg unixtoolbox.pdf
# convert unixtoolbox.pdf unixtoolbox-%03d.png
# convert *.jpeg images.pdf          <span class="cmt"># 把所有图片转换成一份简单的 PDF 文档</span>
</pre>
Ghostscript 同样可连接多个 pdf 文件成一份 PDF 文档。这仅可工作于这些 PDF 文件都 "呈现一致(well behaved)" 的情况下。
<pre># gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=all.pdf \
file1.pdf file2.pdf ...              <span class="cmt"># 在 Windows 上使用 '#' 代替 '='</span>
</pre>

<h2>视频转换</h2>
使用 mpeg4 编码压缩佳能数码相机视频并修复无用音质。
<pre># mencoder -o videoout.avi -oac mp3lame -ovc lavc -srate 11025 \
-channels 1 -af-adv force=1 -lameopts preset=medium -lavcopts \
vcodec=msmpeg4v2:vbitrate=600 -mc 0 vidoein.AVI
</pre>
对于声音的处理可看 <a href="http://sox.sourceforge.net/">sox</a>。

<h2>拷贝音频光盘</h2>
程序 <a rel="nofollow" href="http://xiph.org/paranoia/"><code>cdparanoia</code></a><span class="fn">http://xiph.org/paranoia/</span> 可以保存音轨(FreeBSD port 在 audio/cdparanoia/)，<code>oggenc</code> 可编码 Ogg Vorbis 格式，<code>lame</code> 可转换成 mp3。
<pre># cdparanoia -B                      <span class="cmt"># 拷贝音轨成 wav 文件到当前目录列表(dir)</span>
# lame -b 256 in.wav out.mp3         <span class="cmt"># 编码成 256 kb/s 的 mp3</span>
# for i in *.wav; do lame -b 256 $i `basename $i .wav`.mp3; done
# oggenc in.wav -b 256 out.ogg       <span class="cmt"># 编码成 256 kb/s 的 Ogg Vorbis</span>
</pre>
</div>

<div id="printing"><h1><a>打印</a></h1>
<h2>打印命令 lpr</h2>
<pre style="page-break-inside: avoid;"># lpr unixtoolbox.ps                 <span class="cmt"># 用默认打印机打印</span>
# export PRINTER=hp4600              <span class="cmt"># 更改默认打印机</span>
# lpr -Php4500 #2 unixtoolbox.ps     <span class="cmt"># 指定打印机 hp4500 并打印 2 份</span>
# lpr -o Duplex=DuplexNoTumble ...   <span class="cmt"># 启用双面打印</span>
# lpr -o PageSize=A4,Duplex=DuplexNoTumble ...
# lpq                                <span class="cmt"># 查看默认打印机的队列</span>
# lpq -l -Php4500                    <span class="cmt"># 详细显示打印机队列信息</span>
# lprm -                             <span class="cmt"># 删除所有打印机内的用户打印作业</span>
# lprm -Php4500 3186                 <span class="cmt"># 删除作业 3186。可使用 lpq 查看作业号</span>
# lpc status                         <span class="cmt"># 列印所有可用打印机</span>
# lpc status hp4500                  <span class="cmt"># 如果打印机在线，查看其状态和列队长度</span>
</pre>
当要打印 PDF 文件时，一些打印设备不具备处理 postscript 的能力。可以这样解决<span class="fn">译注：此例事实上利用管道(pipe)方式将 PDF 的转换结果利用 -sOutputFile 选项导入给 lpr 打印。</span>：
<pre># gs -dSAFER -dNOPAUSE -sDEVICE=deskjet -sOutputFile=\|lpr file.pdf</pre>
</div>

<div id="databases"><h1><a>数据库</a></h1>
<h2 id="pgsql">PostgreSQL</h2>
<h3>更改 root 用户或其它用户的密码</h3>
<pre># psql -d template1 -U pgsql
&gt; alter user pgsql with password 'pgsql_password';  <span class="cmt"># pgsql 为需要更改密码的用户名</span>
</pre>
<h3>创建用户和数据库</h3>
命令 <code>createuser</code>, <code>dropuser</code>, <code>createdb</code> 和 <code>dropdb</code> 等同于 SQL 命令<span class="fn">译注：其实是一个 Shell 脚本</span>的快捷方式。我们创建一个新用户叫 bob 和一个数据库叫 bobdb；使用数据库的超级用户 pgsql 来创建：
<pre># createuser -U pgsql -P bob         <span class="cmt"># -P 会请求一个秘密</span>
# createdb -U pgsql -O bob bobdb     <span class="cmt"># 新数据库 bobdn 的所有者是 bob<span class="fn">译注：通常，执行这个命令的数据库用户成为新数据库的所有者。不过，如果执行用户拥有合适的权限，那么他可以通过 -O 指定合适的用户。</span></span>
# dropdb bobdb                       <span class="cmt"># 删除数据库 bobdb</span>
# dropuser bob                       <span class="cmt"># 删除用户 bob</span>
</pre>
一般数据库认证机制配置在 pg_hba.conf 文件中。
<h3>允许远程访问</h3>
文件 <code>$PGSQL_DATA_D/postgresql.conf</code> 可指定绑定地址。对于 Postgres 8.x 通常为 <code>listen_addresses = '*'</code>。<br />
文件 <code>$PGSQL_DATA_D/pg_hba.conf</code> 定义了访问控制。举例：
<pre># TYPE  DATABASE    USER        IP-ADDRESS        IP-MASK          METHOD
host    bobdb       bob        212.117.81.42     255.255.255.255   password
host    all         all        0.0.0.0/0                           password
</pre>
<h3>备份和恢复</h3>
使用 pgsql 或 postgres 用户来完成备份与恢复。下面是备份和恢复单个数据库：
<pre># pg_dump --clean dbname &gt; dbname_sql.dump
# psql dbname &lt; dbname_sql.dump
</pre>
备份和恢复所有数据库(包括用户)：
<pre># pg_dumpall --clean &gt; full.dump
# psql -f full.dump postgres
</pre>
在这个例子中，你可以声明任意现有的数据库进行连接，但是如果你是向一个空的数据库集群装载，那么 postgres 应该是比较好的选择。

<h2 id="mysql">MySQL</h2>
<h3>更改 mysql root 用户或其它用户的密码</h3>
<h4>方法 1</h4>
<pre># /etc/init.d/mysql stop
<i><span class="cmt">or</span></i>
# killall mysqld
# mysqld --skip-grant-tables
# mysqladmin -u root password 'newpasswd'
# /etc/init.d/mysql start
</pre>
<h4>方法 2</h4>
<pre># mysql -u root mysql
<span class="cmt">mysql&gt;</span> UPDATE USER SET PASSWORD=PASSWORD("newpassword") where user='root';
<span class="cmt">mysql&gt;</span> FLUSH PRIVILEGES;                           <span class="cmt"># 使用用户名替代"root"</span>
<span class="cmt">mysql&gt;</span> quit
</pre>
<h3>创建用户和数据库</h3>
<pre># mysql -u root mysql
<span class="cmt">mysql&gt;</span> CREATE DATABASE bobdb;
<span class="cmt">mysql&gt;</span> GRANT ALL ON *.* TO 'bob'@'%' IDENTIFIED BY 'pwd'; 
                           <span class="cmt"># 使用 localhost 替代 % 来限制网络访问</span>
<span class="cmt">mysql&gt;</span> DROP DATABASE bobdb;                        <span class="cmt"># 删除数据库 bobdb</span>
<span class="cmt">mysql&gt;</span> DROP USER bob;                              <span class="cmt"># 删除用户 bob</span>
<span class="cmt">mysql&gt;</span> DELETE FROM mysql.user WHERE user='bob and host='hostname'; 
                           <span class="cmt"># 删除 mysql 数据库 user 表中 user=bob,host=hostname 的记录</span>
<span class="cmt">mysql&gt;</span> FLUSH PRIVILEGES;
</pre>
<h3>允许远程访问</h3>
远程访问通常允许单个数据库，而不是所有的数据库。文件 <code>/etc/my.cnf</code> 包含约定的 IP 地址。通常为 <code>bind-address =</code> 绑定地址。
<pre># mysql -u root mysql
<span class="cmt">mysql&gt;</span> GRANT ALL ON bobdb.* TO bob@'xxx.xxx.xxx.xxx' IDENTIFIED BY 'PASSWORD';
<span class="cmt">mysql&gt;</span> REVOKE GRANT OPTION ON foo.* FROM bar@'xxx.xxx.xxx.xxx';
<span class="cmt">mysql&gt;</span> FLUSH PRIVILEGES;                  <span class="cmt"># 使用 'hostname' 也可为 '%' 来完全访问</span>
</pre>
<h3>备份和恢复</h3>
备份和恢复单个数据库：
<pre># mysqldump -u root -psecret --add-drop-database dbname &gt; dbname_sql.dump
# mysql -u root -psecret -D dbname &lt; dbname_sql.dump
</pre>
备份和恢复所有的数据库：
<pre># mysqldump -u root -psecret --add-drop-database --all-databases &gt; full.dump
# mysql -u root -psecret &lt; full.dump
</pre>
这里 mysql root 的密码为 "secret"，-p 选项后面没有空格。当单独使用 -p 选项(不跟密码)，命令行提示符后会要求输入密码。

<h2 id="sqlite">SQLite</h2>
<a href="http://www.sqlite.org/">SQLite</a><span class="fn">http://www.sqlite.org</span> 是一个小而强大的、独立的(self-contained)、无服务器的(serverless)、零配置的(zero-configuration) SQL 数据库。
<h3>备份和恢复</h3>
实用备份和恢复 SQLite 数据库命令。举个例子，你可以编辑备份文件来修改字段的属性和类型，然后再恢复这个数据库。这比使用 SQL 命令来得容易。对于 3.x 数据库可使用 <code>sqlite3</code>。
<pre># sqlite database.db .dump &gt; dump.sql              <span class="cmt"># 备份</span>
# sqlite database.db &lt; dump.sql                    <span class="cmt"># 恢复</span>
</pre>
<h3>转换 2.x 到 3.x 数据库</h3>
<pre>sqlite database_v2.db .dump | sqlite3 database_v3.db</pre>
</div>

<div id="quota"><h1><a>磁盘限额</a></h1>
磁盘限额用来限制磁盘空间大小和/或用户(或用户组)可用的文件数。The quotas are allocated on a per-file system basis and are enforced by the kernel.
<h2>Linux 设置</h2>
Quota 工具包通常已安装，其包含一些命令行工具。<br />
在 fstab 中激活用户配额并重新挂载分区。如果分区正在使用，关闭所有使用的文件，或者重启系统。添加 <code>usrquota</code> 到 fstab 的挂载类型中，举个例子：
<pre>/dev/sda2     /home    reiserfs     rw,acl,user_xattr,usrquota 1 1
# mount -o remount /home
# mount                              <span class="cmt"># 检查 usrquota 已经激活，否则重启</span>
</pre>
用 <code>quotacheck</code> 初始化 quota.user 文件。
<pre># quotacheck -vum /home
# chmod 644 /home/aquota.user        <span class="cmt"># 让用户检查自己的配额</span>
</pre>
用脚本(e.g. SuSE 的 /etc/init.d/quotad)或 <code>quotaon</code> 来启用限额：
<pre>quotaon -vu /home</pre>
检查配额启用情况：
<pre>quota -v</pre>

<h2>FreeBSD 设置</h2>
Quota 工具是 FreeBSD 基本系统的一部分，然而内核需要 quota 选项。如果不存在，新增它并<a href="http://cb.vu/unixtoolbox_zh_CN.xhtml#compilekernel">重新编译</a>内核。
<pre>options QUOTA</pre>
与 Linux 一样，添加限额到 fstab 选项(是 userquota，而不是 usrquota)中：
<pre>/dev/ad0s1d    /home    ufs     rw,noatime,userquota    2  2
# mount /home                        <span class="cmt"># 重新挂载分区</span>
</pre>
在 /etc/rc.conf 中启用磁盘限额并开启 quota 服务。
<pre># grep quotas /etc/rc.conf
enable_quotas="YES"                  <span class="cmt"># 在启动时打开限额(或者 "NO")</span>
check_quotas="YES"                   <span class="cmt"># 在启动时检查限额(或者 "NO")</span>
# /etc/rc.d/quota start
</pre>

<h2 id="assignquota">分配限额</h2>
磁盘限额默认并不限制(设置为0)。用 <code>edquota</code> 来对单用户进行限制。一个 quota 也可给许多用户复用。虽然 quota 实现之间的文件结构不同，但其原理是相同的：限制节点(inodes)数量以及使用者可以取用的磁盘区块数量。<i>Only change the values of soft and hard</i>. 如果未指定，默认区块大小为 1k。使用 <code>edquota -t</code> 设置 grace 时间。举个例子：
<pre># edquota -u colin</pre>
<h3>Linux</h3>
<pre>Disk quotas for user colin (uid 1007):
  Filesystem         blocks       soft       hard     inodes     soft     hard
  /dev/sda8            108       1000       2000          1        0        0
</pre>
<h3>FreeBSD</h3>
<pre>Quotas for user colin:
/home: kbytes in use: 504184, limits (soft = 700000, hard = 800000)
   inodes in use: 1792, limits (soft = 0, hard = 0)
</pre>
<h3>给许多用户分配限额</h3>
命令 <code>edquota -p</code> 用来复用一个 quota 给其他用户。举个例子，复用所指用户的限额给所有用户：
<pre># edquota -p refuser `awk -F: $3 &gt; 499 {print $1}' /etc/passwd`
# edquota -p refuser user1 user2     <span class="cmt"># 复用给 2 个用户</span>
</pre>
<h3>检查</h3>
用户只需输入 <code>quota</code> (文件 quota.user 必须可读) 来可以检查他们的限额。Root 可以查看所有用户的限额。
<pre># quota -u colin                     <span class="cmt"># 查看用户的限额</span>
# repquota /home                     <span class="cmt"># 所有用户在这个分区上的限额情况</span>
</pre>
</div>

<div id="shells"><h1><a>Shells</a></h1>
许多 Linux 发行版使用 BASH Shell，BSD 使用的是 tcsh，Bourne Shell 仅用于脚本。过滤器(Filter)非常有用并且可用于管道(pipe)：
<ul style="list-style-type:none;">
  <li><code>grep</code>     模式匹配</li>
  <li><code>sed</code>     查找并替换字符串或字符</li>
  <li><code>cut</code>     从一个标记开始打印所指定列数据</li>
  <li><code>sort</code>    按字母或数字排序</li>
  <li><code>uniq</code>    删除一个文件中重复行</li>
</ul>
举个例子，一次使用所有命令：
<pre># ifconfig | sed 's/  / /g' | cut -d" " -f1 | uniq | grep -E "[a-z0-9]+" | sort -r
# ifconfig | sed '/.*inet addr:/!d;s///;s/ .*//'|sort -t. -k1,1n -k2,2n -k3,3n -k4,4n
</pre>
sed 的模式字符串中的第一个字符是一个 tab。要在命令控制台中输入 tab，可以使用 ctrl-v ctrl-tab。

<h2 id="bash">bash</h2>
Bash、sh 的重定向<span class="fn">译注：当执行一个程序时，运行该程序的进程打开了3个文件描述符，分别是：0(标准输入)、1(标准输出)和2(标准错误输出)。重定向输出符号(&gt;)是 1&gt;的简写，它通知 shell 重定向标准输出。类似的，&lt;是 0&lt;的简写，表示重定向标准输入。符号 2&gt;将重定向标准错误输出。</span>和管道：
<pre># cmd 1&gt; file                         <span class="cmt"># 重定向标准输出到 file。</span>
# cmd 2&gt; file                         <span class="cmt"># 重定向标准错误输出到 file。</span>
# cmd 1&gt;&gt; file                        <span class="cmt"># 重定向标准输出并追加到 file。</span>
# cmd &amp;&gt; file                         <span class="cmt"># 重定向标准输出和标准错误输出到 file。</span>
# cmd &gt;file 2&gt;&amp;1                      <span class="cmt"># 重定向标准错误输出到标准输出然后重定向到 file。</span>
# cmd1 | cmd2                         <span class="cmt"># cmd1 的输出通过管道连接到 cmd2 的输入</span>
# cmd1 2&gt;&amp;1 | cmd2                    <span class="cmt"># cmd1 的输出和错误输出通过管道连接到 cmd2 的输入</span>
</pre>
修改你的配置文件 ~/.bashrc (也可以是 ~/.bash_profile)。下列条目非常有用，使用". .bashrc"重新加载。
<pre style="page-break-inside:avoid;"># in .bashrc
bind '"\e[A"':history-search-backward <span class="cmt"># 使用上下键查找</span>
bind '"\e[B"':history-search-forward  <span class="cmt"># 历史命令。无价之宝!</span>
set -o emacs                          <span class="cmt"># Set emacs mode in bash (看下面)</span>
set bell-style visible                <span class="cmt"># Do not beep, inverse colors</span>
    <span class="cmt"># 设置一个漂亮的提示符像 [user@host]/path/todir&gt;</span>
PS1="\[\033[1;30m\][\[\033[1;34m\]\u\[\033[1;30m\]"
PS1="$PS1@\[\033[0;33m\]\h\[\033[1;30m\]]\[\033[0;37m\]"
PS1="$PS1\w\[\033[1;30m\]&gt;\[\033[0m\]"
</pre><pre><span class="cmt"># 要检查当前可用别名(alias)，只需简单输入命令 alias</span>
alias  ls='ls -aF'                    <span class="cmt"># 添加指示符(*/=&gt;@| 其中之一)</span>
alias  ll='ls -aFls'                  <span class="cmt"># 清单</span>
alias  la='ls -all'
alias ..='cd ..'
alias ...='cd ../..'
export HISTFILESIZE=5000              <span class="cmt"># 巨大的历史记录</span>
export CLICOLOR=1                     <span class="cmt"># 使用颜色(如果可用)</span>
export LSCOLORS=ExGxFxdxCxDxDxBxBxExEx
</pre>

<h2 id="tcsh">tcsh</h2>
Tcsh、csh 的重定向和管道(&gt; 和 &gt;&gt; 同 sh 中一样)：
<pre># cmd &gt;&amp; file                         <span class="cmt"># 重定向标准输出和标准错误输出到 file。</span>
# cmd &gt;&gt;&amp; file                        <span class="cmt"># 追加标准输出和标准错误输出到 file。</span>
# cmd1 | cmd2                         <span class="cmt"># cmd1 的输出通过管道连接到 cmd2 的输入</span>
# cmd1 |&amp; cmd2                        <span class="cmt"># cmd1 的输出和错误输出通过管道连接到 cmd2 的输入</span>
</pre>

Csh/tcsh 的设置在 <code>~/.cshrc</code> 中，使用"source .cshrc"来重新加载。例子：
<pre style="page-break-inside:avoid;"># in .cshrc
alias  ls      'ls -aF'
alias  ll      'ls -aFls'
alias  la      'ls -all'
alias  ..      'cd ..'
alias  ...     'cd ../..'
set   prompt    = "%B%n%b@%B%m%b%/&gt; " <span class="cmt"># 像 user@host/path/todir&gt;</span>
set   history   =  5000
set   savehist  = ( 6000 merge )
set   autolist                        <span class="cmt"># 控制命令补全和变量补全</span>
set   visiblebell                     <span class="cmt"># 使用闪动屏幕的方式来取代蜂鸣器鸣叫</span>
</pre><pre><span class="cmt"># Bindkey 和颜色</span>
bindkey -e     Select Emacs bindings  <span class="cmt"># 将命令行编辑器切换到emacs模式</span>
bindkey -k up history-search-backward <span class="cmt"># 使用上下键来搜索</span>
bindkey -k down history-search-forward
setenv CLICOLOR 1                     <span class="cmt"># 使用颜色(可能的话)</span>
setenv LSCOLORS ExGxFxdxCxDxDxBxBxExEx
</pre>
该 emacs 模式将使用 emacs 快捷键来修改命令提示行。这是非常有用的(不单为 Emacs 用户)。最常用的命令如下：
<ul style="list-style-type:none;">
  <li>C-a       移动光标到行头</li>
  <li>C-e       移动光标到行尾</li>
  <li>M-b       移动光标到前一个单词</li>
  <li>M-f       移动光标到后一个单词</li>
  <li>M-d       剪切下一个单词</li>
  <li>C-w       剪切最后一个单词</li>
  <li>C-u       剪切光标前所有字符</li> 
  <li>C-k       剪切光标后所有字符</li>
  <li>C-y       粘帖最后剪切的字符(简易的粘帖)</li>
  <li>C-_       重做</li>
</ul>
<i>注意:</i> C- = 按住 control 键，M- = 按住 meta (它通常为 alt 或者 escape)键。
</div>

<div id="scripting"><h1><a>脚本</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#bournebasics">基础</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#bourneexample">脚本实例</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox_zh_CN.xhtml#sed">sed/实用命令</a></p>
Bourne shell<span class="fn">译注：Shell 存在很多种，如 bash(Bourne Again Shell),csh(C Shell),tcsh(TC Shell),zsh(Z Shell) 等。通过 ps 命令可识别出正在运行的是哪种 Shell。</span> (/bin/sh) 存在于所有的 Unix 系统上，并且用她写的脚本是(完全)可移植的； <code>man 1 sh</code> 是一个好的参考。

<h2 id="bournebasics">基础</h2>
<h3>变量和参数</h3>
使用 <code>variable=value</code> 的命令格式设置变量，其中 variable 是变量名称，value是打算赋给该变量的值。使用 $variable 获取变量值。
<pre>MESSAGE="Hello World"                        <span class="cmt"># 赋予一个字符串</span>
PI=3.1415                                    <span class="cmt"># 赋予一个十进制小数</span>
N=8
TWON=`expr $N * 2`                           <span class="cmt"># 算术表达式(只限整数)</span>
TWON=$(($N * 2))                             <span class="cmt"># 另一种语法</span>
TWOPI=`echo "$PI * 2" | bc -l`               <span class="cmt"># 使用 bc 进行浮点运算</span>
ZERO=`echo "c($PI/4)-sqrt(2)/2" | bc -l`
</pre>
命令行参数：
<pre>$0, $1, $2, ...                              <span class="cmt"># $0 命令本身</span> 
$#                                           <span class="cmt"># 命令参数个数</span>
$*                                           <span class="cmt"># 所有参数(也可以是 $@)</span>
</pre>
<h3>一些特殊的变量</h3>
<pre>$$                                           <span class="cmt"># 当前进程 ID</span>
$?                                           <span class="cmt"># 最后命令退出状态码</span>
  command
  <span class="keyword">if</span> [ $<span class="pp">?</span> != 0 ]; <span class="keyword">then</span>
    echo "command failed"
  <span class="keyword">fi</span>
<span class="pp">mypath</span>=`pwd`
<span class="pp">mypath</span>=${<span class="pp">mypath</span>}/file.txt
echo ${<span class="pp">mypath</span>##*/}                           <span class="cmt"># 只显示文件名</span>
echo ${<span class="pp">mypath</span>%%.*}                           <span class="cmt"># 除了扩展名的全路径</span>
<span class="pp">var2</span>=${<span class="pp">var</span>:=string}                          <span class="cmt"># 如果var没有被赋值，则string值先赋值给var，
                                             # 然后再赋值给var2</span>
</pre>

<h3>结构控制</h3>
<pre><span class="keyword">for</span> <span class="pp">file</span> in `ls`
<span class="keyword">do</span>
    echo $<span class="pp">file</span>
<span class="keyword">done</span>

<span class="pp">count</span>=0
<span class="keyword">while</span> [ $<span class="pp">count</span> -lt 5 ]; <span class="keyword">do</span>
    echo $<span class="pp">count</span>
    sleep 1
    <span class="pp">count</span>=$(($<span class="pp">count</span> + 1))
<span class="keyword">done</span>

myfunction() {
    find . -type f -name "*.$<span class="pp">1</span>" -print       <span class="cmt"># $1 为方法的第一个参数</span>
}
myfunction "txt"
</pre>
<h4>产生一个文件</h4>
<pre><span class="pp">MYHOME</span>=/home/colin
cat &gt; testhome.sh &lt;&lt; _EOF
<span class="cmt"># 所有_EOF前的代码都会进入到 testhome.sh 文件中去</span>
<span class="keyword">if</span> [ -d "$<span class="pp">MYHOME</span>" ] ; <span class="keyword">then</span>
    echo $<span class="pp">MYHOME</span> exists
<span class="keyword">else</span>
    echo $<span class="pp">MYHOME</span> does not exist
<span class="keyword">fi</span>
_EOF
sh testhome.sh
</pre>
<h2 id="bourneexample">Bourne 脚本实例</h2>
来一个小实例，此脚本从本 xhtml 文档创建一个 PDF 小册子：
<pre style="page-break-inside:avoid;"><span class="pp">#!/bin/sh</span>
<span class="cmt"># 此脚本可以创建一份供双面打印机打印的 PDF 格式的书</span>
<span class="keyword">if</span> [ $<span class="pp">#</span> <span class="keyword">-ne</span> 1 ]; <span class="keyword">then</span>                        <span class="cmt"># 检查参数是否等于 1</span>
  echo 1&gt;&amp;2 "Usage: $0 HtmlFile"
  <span class="keyword">exit</span> 1                                     <span class="cmt"># 如果不等于1，非0退出</span>
<span class="keyword">fi</span>

<span class="pp">file</span>=$<span class="pp">1</span>                                      <span class="cmt"># 文件变量</span>
<span class="pp">fname</span>=${<span class="pp">file</span>%.*}                             <span class="cmt"># 文件名变量</span>
<span class="pp">fext</span>=${<span class="pp">file</span>#*.}                              <span class="cmt"># 文件扩展名变量</span>

prince $<span class="pp">file</span> -o $<span class="pp">fname</span>.pdf                   <span class="cmt"># www.princexml.com</span>
pdftops -paper A4 -noshrink $<span class="pp">fname</span>.pdf $<span class="pp">fname</span>.ps <span class="cmt"># 创建 postscript 小册子</span>
cat $<span class="pp">fname</span>.ps |psbook|psnup -Pa4 -2 |pstops -b "2:0,1U(21cm,29.7cm)" &gt; $<span class="pp">fname</span>.book.ps

ps2pdf13 -sPAPERSIZE=a4 -sAutoRotatePages=None $<span class="pp">fname</span>.book.ps $<span class="pp">fname</span>.book.pdf
                                             <span class="cmt"># 在 Windows 上使用 #a4 和 #None!</span>
<span class="keyword">exit</span> 0                                       <span class="cmt"># exit 0 意为成功</span>
</pre>

<h2 id="sed">一些 sed 命令</h2>
这里是<a href="http://student.northpark.edu/pemente/sed/sed1line.txt">单行 sed 命令的金矿</a><span class="fn">http://student.northpark.edu/pemente/sed/sed1line.txt</span>。还有一个很好的 <a href="http://www.grymoire.com/Unix/Sed.html">sed 介绍及教程</a><span class="fn">http://www.grymoire.com/Unix/Sed.html</span>。
<pre>sed 's/string1/string2/g'                    <span class="cmt"># 替换 string1 为 string2</span>
sed -i 's/wroong/wrong/g' *.txt              <span class="cmt"># 用 g 替换所有返回的单词</span>
sed 's/\(.*\)1/\12/g'                        <span class="cmt"># 修改 anystring1 为 anystring2</span>
sed '/&lt;p&gt;/,/&lt;\/p&gt;/d' t.xhtml                 <span class="cmt"># 删除以 &lt;p&gt; 开始，以 &lt;/p&gt; 结尾的行</span>
sed '/ *#/d; /^ *$/d'                        <span class="cmt"># 删除注释和空行</span>
sed 's/[ \t]*$//'                            <span class="cmt"># 删除行尾空格 (使用 tab 代替 \t)</span>
sed 's/^[ \t]*//;s/[ \t]*$//'                <span class="cmt"># 删除行头尾空格</span>
sed 's/[^*]/[&amp;]/'                            <span class="cmt"># 括住首字符 [] top -&gt; [t]op</span>
sed = file | sed 'N;s/\n/\t/' &gt; file.num     <span class="cmt"># 为文件添加行号</span>
</pre>

<h2 id="regex">正则表达式</h2>
一些基本的正则表达式同样可用于 sed。作为一个良好的启蒙，可看 <a href="http://www.regular-expressions.info/reference.html">基本正则语法</a><span class="fn">http://www.regular-expressions.info/reference.html</span>。
<pre>[\^$.|?*+()                          <span class="cmt"># 特殊字符，其他字符将匹配自身</span>
\                                    <span class="cmt"># 转义特殊字符，当成普通字符对待</span>
*                                    <span class="cmt"># 重复前项 0 次或多次</span>
.                                    <span class="cmt"># 单个字符除换行符</span>
.*                                   <span class="cmt"># 匹配 0 个或多个字符</span>
^                                    <span class="cmt"># 匹配字符串行开始处</span>
$                                    <span class="cmt"># 匹配字符串行结尾处</span>
.$                                   <span class="cmt"># 匹配字符串行最后一个字符</span>
^ $                                  <span class="cmt"># 匹配单个空格的行</span>
[^A-Z]                               <span class="cmt"># 匹配任何以 A-Z 字符开始的行</span>
</pre>

<h2 id="shcmd">一些实用命令</h2>
下列命令对于包含于一个脚本或者单行命令来说很有用。
<pre>sort -t. -k1,1n -k2,2n -k3,3n -k4,4n         <span class="cmt"># 排序 IPv4 格式的 IP 地址</span>
echo 'Test' | tr '[:lower:]' '[:upper:]'     <span class="cmt"># 转换成大写</span>
echo foo.bar | cut -d . -f 1                 <span class="cmt"># 返回 foo</span>
PID=$(ps | grep script.sh | grep bin | awk '{print $1}')          <span class="cmt"># 正在运行名为 script 脚本的 PID</span>
PID=$(ps axww | grep [p]ing | awk '{print $1}')                   <span class="cmt"># ping 的 PID (w/o grep pid)</span>
IP=$(ifconfig $INTERFACE | sed '/.*inet addr:/!d;s///;s/ .*//')   <span class="cmt"># Linux</span>
IP=$(ifconfig $INTERFACE | sed '/.*inet /!d;s///;s/ .*//')        <span class="cmt"># FreeBSD</span>
if [ `diff file1 file2 | wc -l` != 0 ]; then [...] fi             <span class="cmt"># 文件改变了？</span>
cat /etc/master.passwd | grep -v root | grep -v \*: | awk -F":" \ <span class="cmt"># 创建 http passwd</span>
'{ printf("%s:%s\n", $1, $2) }' &gt; /usr/local/etc/apache2/passwd

testuser=$(cat /usr/local/etc/apache2/passwd | grep -v \    <span class="cmt"># 查看 passwd 中的用户</span>
root | grep -v \*: | awk -F":" '{ printf("%s\n", $1) }' | grep ^user$)
:(){ :|:&amp; };:                                <span class="cmt"># bash fork 炸弹。会干掉你的机器<span class="fn">译注：http://forum.ubuntu.org.cn/viewtopic.php?t=92074</span></span>
tail +2 file &gt; file2                         <span class="cmt"># 删除文件的第一行</span>
</pre>
我使用一种小伎俩来一次更改许多文件的扩展名。举个例子，从 .cxx 到 .cpp。排除最后的 <code>| sh</code> 先测试一下。你同样可以使用命令 <code>rename</code> 来做这些，如果安装了的话。或者使用 bash 内建命令。
<pre># ls *.cxx | awk -F. '{print "mv "$0" "$1".cpp"}' | sh
# ls *.c | sed "s/.*/cp &amp; &amp;.$(date "+%Y%m%d")/" | sh <span class="cmt"># 如 拷贝 *.c 成 *.c.20080401</span>
# rename .cxx .cpp *.cxx                             <span class="cmt"># 重命名所有 .cxx 成 .cpp</span>
# for i in *.cxx; do mv $i ${i%%.cxx}.cpp; done      <span class="cmt"># bash 内建的</span>
</pre>
</div>

<div id="programming"><h1><a>编程</a></h1>
<h2 id="cbasics">C 基础</h2>
<pre>strcpy(newstr,str)                        <span class="cmt">/* 拷贝 str 到 newstr */</span>
expr1 ? expr2 : expr3                     <span class="cmt">/* if (expr1) expr2 else expr3 */</span>
x = (y &gt; z) ? y : z;                      <span class="cmt">/* if (y &gt; z) x = y; else x = z; */</span>
int a[]={0,1,2};                          <span class="cmt">/* 初始化数组 (或者 a[3]={0,1,2}; */</span>
int a[2][3]={{1,2,3},{4,5,6}};            <span class="cmt">/* 初始化二维数组 */</span>
int i = 12345;                            <span class="cmt">/* 从 i 转换成 char str */</span>
char str[10];
sprintf(str, "%d", i);
</pre>
<h2>C 实例</h2>
一个最小化的 C 程式 simple.c：
<pre><span class="pp">#include</span> &lt;stdio.h&gt;
main() {
    <span class="keyword">int</span> number=42;
    printf("The answer is %i\n", number);  
}
</pre>
编译：
<pre># gcc simple.c -o simple
# ./simple
The answer is 42
</pre>

<h2 id="cppbasics">C++ 基础</h2>
<pre>*pointer                                  <span class="cmt">// 指向对象的指针</span>
&amp;obj                                      <span class="cmt">// 对象 obj 的地址</span>
obj.x                                     <span class="cmt">// 类(对象) obj 成员 x</span>
pobj-&gt;x                                   <span class="cmt">// 指针 pobj 指向类(对象)成员 x</span>
                                          <span class="cmt">// (*pobj).x 同 pobj-&gt;x</span>
</pre>
<h2>C++ 实例</h2>
来一个稍微现实一点的 C++ 程序，我们在一个头文件(IPv4.h)中创建一个类并且实现它(IPv4.cpp)，然后创建一个程式来使用其功能。这个类的成员方法实现了 IP 地址从一串整数转换成我们熟知的点分格式。这是一个最小化的 C++ 程式和多源文件(multi-source)的编译。
<h3>IPv4 class</h3>
<h4>IPv4.h:</h4>
<pre style="page-break-inside:avoid;"><span class="pp">#ifndef</span> IPV4_H
<span class="pp">#define</span> IPV4_H
<span class="pp">#include</span> &lt;string&gt;

<span class="keyword">namespace</span> GenericUtils {                          <span class="cmt">// 创建 namespace
</span><span class="keyword">class</span> IPv4 {                                      <span class="cmt">// 类定义
</span><span class="keyword">public</span>:
    IPv4();
    ~IPv4();
    std::string IPint_to_IPquad(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip);<span class="cmt">// 成员方法接口
</span>};
} <span class="cmt">//namespace GenericUtils</span>
<span class="pp">#endif</span> <span class="cmt">// IPV4_H
</span></pre>

<h4>IPv4.cpp:</h4>
<pre style="page-break-inside:avoid;"><span class="pp">#include</span> "IPv4.h"
<span class="pp">#include</span> &lt;string&gt;
<span class="pp">#include</span> &lt;sstream&gt;
<span class="keyword">using</span> <span class="keyword">namespace</span> std;                              <span class="cmt">// 使用 namespace
</span><span class="keyword">using</span> <span class="keyword">namespace</span> GenericUtils;

IPv4::IPv4() {}                                   <span class="cmt">// 默认构造/析构函数
</span>IPv4::~IPv4() {}
string IPv4::IPint_to_IPquad(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip) {  <span class="cmt">// 成员方法实现
</span>    ostringstream ipstr;                          <span class="cmt">// 使用字符串流
</span>    ipstr &lt;&lt; ((ip &amp;0xff000000) &gt;&gt; 24)             <span class="cmt">// 位右移
</span>          &lt;&lt; "." &lt;&lt; ((ip &amp;0x00ff0000) &gt;&gt; 16)
          &lt;&lt; "." &lt;&lt; ((ip &amp;0x0000ff00) &gt;&gt; 8)
          &lt;&lt; "." &lt;&lt; ((ip &amp;0x000000ff));
    <span class="keyword">return</span> ipstr.str();
}
</pre>
<h3>程序 simplecpp.cpp</h3>
<pre style="page-break-inside:avoid;"><span class="pp">#include</span> "IPv4.h"
<span class="pp">#include</span> &lt;iostream&gt;
<span class="pp">#include</span> &lt;string&gt;
<span class="keyword">using</span> <span class="keyword">namespace</span> std;

<span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) {
    string ipstr;                                 <span class="cmt">// 定义变量
</span>    <span class="keyword">unsigned</span> <span class="keyword">long</span> ipint = 1347861486;             <span class="cmt">// 数字形式的 IP</span>
    GenericUtils::IPv4 iputils;                   <span class="cmt">// 创建一个类的对象
</span>    ipstr = iputils.IPint_to_IPquad(ipint);       <span class="cmt">// 调研类的成员方法
</span>    cout &lt;&lt; ipint &lt;&lt; " = " &lt;&lt; ipstr &lt;&lt; endl;      <span class="cmt">// 输出结果</span>

    <span class="keyword">return</span> 0;
}
</pre>

编译和执行：
<pre style="page-break-before:avoid;"># g++ -c IPv4.cpp simplecpp.cpp                <span class="cmt"># 编译成目标文件</span>
# g++ IPv4.o simplecpp.o -o simplecpp.exe      <span class="cmt"># 连接目标代码，生成可执行文件</span>
# ./simplecpp.exe 
1347861486 = 80.86.187.238
</pre>
使用 <code>ldd</code> 脚本检查并列出可执行程序所依赖的共享库文件。这个命令同样可以用来检查共享库的丢失。
<pre># ldd /sbin/ifconfig</pre>
<h2 id="makefile">简单的 Makefile</h2>
相应的最小化多源文件(multi-source)编译 Makefile 显示如下。每一个命令行必须以 <i>tab</i> 开始！可以将一个较长行使用反斜线"\"来分解为多行。
<pre style="page-break-inside:avoid;"><span class="pp">CC</span> = g++
<span class="pp">CFLAGS</span> = -O
<span class="pp">OBJS</span> = IPv4.o simplecpp.o

<span class="keyword">simplecpp</span>: ${OBJS}
	${CC} -o simplecpp ${CFLAGS} ${OBJS}
<span class="keyword">clean</span>:
	rm -f ${TARGET} ${OBJS}
</pre>
</div>

<div id="onlinehelp"><h1><a>在线帮助</a></h1>
<h2 id="documentation">文档</h2>
<table>
  <tr><td><a href="http://en.tldp.org/">Linux 文档</a> </td><td>en.tldp.org</td></tr>
  <tr><td><a href="http://www.linuxmanpages.com/">Linux Man Pages</a> </td><td>www.linuxmanpages.com</td></tr>
  <tr><td><a href="http://www.oreillynet.com/linux/cmd/">Linux 命令目录</a> </td><td>www.oreillynet.com/linux/cmd</td></tr>
  <tr><td><a href="http://linux.die.net/">Linux doc man howtos</a> </td><td>linux.die.net</td></tr>
  <tr><td><a href="http://www.freebsd.org/handbook/">FreeBSD 手册</a> </td><td>www.freebsd.org/handbook</td></tr>
  <tr><td><a href="http://www.freebsd.org/cgi/man.cgi">FreeBSD Man Pages</a> </td><td>www.freebsd.org/cgi/man.cgi</td></tr>
  <tr><td><a href="http://www.freebsdwiki.net/">FreeBSD 用户 wiki</a> </td><td>www.freebsdwiki.net</td></tr>
  <tr><td><a href="http://docs.sun.com/app/docs/coll/40.10">Solaris Man Pages</a> </td><td>docs.sun.com/app/docs/coll/40.10</td></tr>
</table>
<h2 id="crossref">其他 Unix/Linux 参考</h2>
<table>
  <tr><td><a href="http://bhami.com/rosetta.html">Rosetta Stone for Unix</a> </td><td>bhami.com/rosetta.html (a Unix command translator)</td></tr>
  <tr><td><a href="http://unixguide.net/unixguide.shtml">Unix guide cross reference</a> </td><td>unixguide.net/unixguide.shtml</td></tr>
  <tr><td><a rel="nofollow" href="http://www.linuxguide.it/linux_commands_line_en.htm">Linux 命令行列表</a> </td><td>www.linuxguide.it/commands_list.php</td></tr>
  <tr><td><a rel="nofollow" href="http://www.pixelbeat.org/cmdline.html">Short Linux reference</a> </td><td>www.pixelbeat.org/cmdline.html</td></tr>
</table>
</div>

<p class="last">That's all folks!</p>

 <!-- </div>  end main -->

<!-- page break -->
<!-- <div class="pb" /> -->

<div class="footerlast">
This document: "Unix Toolbox revision 12" is licensed under a <a rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Licence [Attribution - Share Alike]</a>. © <a href="mailto:c_at_cb.vu">Colin Barschel and Greco Shi</a> 2007-2008. Some rights reserved.
</div>

</body>
</html>