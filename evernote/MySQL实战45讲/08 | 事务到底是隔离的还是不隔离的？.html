<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.5.14 (465167)"/><meta name="author" content="章炎(印象)"/><meta name="created" content="2020-03-01 12:52:09 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-03-01 12:52:15 +0000"/><title>08 | 事务到底是隔离的还是不隔离的？</title></head><body><h2 style="padding: 5px; border-bottom: 2px solid lightgrey; line-height: 40.5px; color: rgb(102, 102, 102); font-family: Georgia, &quot;Microsoft Yahei&quot;, &quot;WenQuanYi Micro Hei&quot;; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="border-bottom: 2px solid lightgrey; line-height: 40.5px; color: rgb(102, 102, 102); font-family: Georgia, &quot;Microsoft Yahei&quot;, &quot;WenQuanYi Micro Hei&quot;; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">08 | 事务到底是隔离的还是不隔离的？
</span></h2><div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div>你好，我是林晓斌。</div><div>你现在看到的这篇文章是我重写过的。在第一版文章发布之后，我发现在介绍事务可见性规则时，由于引入了太多概念，导致理解起来很困难。随后，我索性就重写了这篇文章。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">现在的用户留言中，还能看到第一版文章中引入的up_limit_id的概念，为了避免大家产生误解，再此特地和大家事先说明一下。
</span></div></blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我在第3篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我给你举一个例子吧。下面是一个只有两行的表的初始化语句。
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">mysql&gt; CREATE TABLE `t` (</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">  `id` int(11) NOT NULL,</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">  `k` int(11) DEFAULT NULL,</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">  PRIMARY KEY (`id`)</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">) ENGINE=InnoDB;</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">insert into t(id, k) values(1,1),(2,2);</span></div></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-19D7CDA0-6D77-40AF-AC32-B02F564141D3.png" height="509" width="910"/></div><center>图1 事务A、B、C的执行流程
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里，我们需要注意的是事务的启动时机。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。
</span></div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">第二种启动方式，一致性视图是在执行start transaction with consistent snapshot时创建的。
</span></div></blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认autocommit=1。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在这个例子中，事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对InnoDB的事务和锁有更进一步的理解。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在MySQL里，有两个“视图”的概念：
</span></div><ul style="padding-left: 10px;"><li style=""><div>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</div></li><li style=""><div>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在第3篇文章</span><a href="https://time.geekbang.org/column/article/68963" style="border-bottom: 1px dashed red;-en-paragraph:true;">《事务隔离：为什么你改了我还看不见？》</a><span style="-en-paragraph:true;">中，我跟你解释过一遍MVCC的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。你可以结合这两篇文章的说明来更深一步地理解MVCC。
</span></div><h1>“快照”在MVCC里是怎么工作的？
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如图2所示，就是一个记录被多个事务连续更新后的状态。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-09662B16-FA8F-4724-AB86-F4C7B519E2AA.png" height="856" width="1142"/></div><center>图2 行状态变更图
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，</span><span style="font-weight: bold;-en-paragraph:true;">undo log在哪呢？</span><span style="-en-paragraph:true;"
/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个视图数组把所有的row trx_id 分成了几种不同的情况。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-9A0B5A16-E553-4BE7-9177-65382D8EFC25.png" height="856" width="1142"/></div><center>图3 数据版本可见性规则
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：
</span></div><ol style="padding-left: 20px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
</span></div></li><li style=""><div>如果落在黄色部分，那就包括两种情况</div><div>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。
</span></div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以你现在知道了，</span><span style="font-weight: bold;-en-paragraph:true;">InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</span><span style="-en-paragraph:true;"
/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k=1。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里，我们不妨做如下假设：
</span></div><ol style="padding-left: 20px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">事务A开始前，系统里面只有一个活跃事务ID是99；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">三个事务开始前，(1,1）这一行数据的row trx_id是90。
</span></div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-A7DAC86F-A17F-4CA5-A60D-581F12F88318.png" height="856" width="1142"/></div><center>图4 事务A查询数据逻辑图
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：
</span></div><ul style="padding-left: 10px;"><li style=""><div>找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见；</div></li><li style=""><div>接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见；</div></li><li style=""><div>再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：
</span></div><ol style="padding-left: 20px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">版本未提交，不可见；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">版本已提交，但是是在视图创建后提交的，不可见；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">版本已提交，而且是在视图创建前提交的，可见。
</span></div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：
</span></div><ul style="padding-left: 10px;"><li style=""><div>(1,3)还没提交，属于情况1，不可见；</div></li><li style=""><div>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</div></li><li style=""><div>(1,1)是在视图数组创建之前提交的，可见。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。
</span></div><h1>更新逻辑
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">细心的同学可能有疑问了：</span><span style="font-weight: bold;-en-paragraph:true;">事务B的update语句，如果按照一致性读，好像结果不对哦？</span><span style="-en-paragraph:true;"
/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-47174234-3FFA-49BA-A06A-794C8CAD5A8A.png" height="856" width="1142"/></div><center>图5 事务B更新逻辑图
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k=k+1是在（1,2）的基础上进行的操作。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，这里就用到了这样一条规则：</span><span style="font-weight: bold;-en-paragraph:true;">更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</span><span style="-en-paragraph:true;"
/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是当前读。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，如果把事务A的查询语句select * from t where id=1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">mysql&gt; select k from t where id=1 lock in share mode;</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">mysql&gt; select k from t where id=1 for update;</span></div></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-D14039DC-D72B-44CD-8BAF-3395ECDD03AD.png" height="565" width="906"/></div><center>图6 事务A、B、C'的执行流程
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-460C92A4-175C-4603-9F0D-030A656937CA.png" height="856" width="1142"/></div><center>图7 事务B更新逻辑图（配合事务C'）
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">到这里，我们把一致性读、当前读和行锁就串起来了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">现在，我们再回到文章开头的问题：</span><span style="font-weight: bold;-en-paragraph:true;">事务的可重复读的能力是怎么实现的？</span><span style="-en-paragraph:true;"
/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
</span></div><ul style="padding-left: 10px;"><li style=""><div>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</div></li><li style=""><div>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多少呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/08-343B14A3-2B82-45C2-89DC-A9369B978B43.jpg" height="856" width="1142"/></div><center>图8 读提交隔离级别下的事务状态图
</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：
</span></div><ul style="padding-left: 10px;"><li style=""><div>(1,3)还没提交，属于情况1，不可见；</div></li><li style=""><div>(1,2)提交了，属于情况3，可见。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，这时候事务A查询语句返回的是k=2。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">显然地，事务B查询结果k=3。
</span></div><h1>小结
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。
</span></div><ul style="padding-left: 10px;"><li style=""><div>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</div></li><li style=""><div>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而当前读，总是读取已经提交完成的最新版本。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复读。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">mysql&gt; CREATE TABLE `t` (</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">  `id` int(11) NOT NULL,</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">  `c` int(11) DEFAULT NULL,</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">  PRIMARY KEY (`id`)</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">) ENGINE=InnoDB;</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);</span></div></div><div><img src="images/08-B250434C-1CBB-43E4-AC9C-32C9DDDBFCBC.png" height="661" width="486"/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
</span></div><h1>上期问题时间
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我在上一篇文章最后，留给你的问题是：怎么删除表的前10000行。比较多的留言都选择了第二种方式，即：在一个连接中循环执行20次 delete from T limit 500。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">确实是这样的，第二种方式是相对较好的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">评论区留言点赞板：
</span></div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div>@Tony Du的评论，详细而且准确。</div><div>@Knight²º¹⁸ 提到了如果可以加上特定条件，将这10000行天然分开，可以考虑第三种。是的，实际上在操作的时候我也建议你尽量拿到ID再删除。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">@荒漠甘泉 提了一个不错的问题，大家需要区分行锁、MDL锁和表锁的区别。对InnoDB表更新一行，可能过了MDL关，却被挡在行锁阶段。
</span></div></blockquote></div><div><br/></div></body></html>