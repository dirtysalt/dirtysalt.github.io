<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.5.14 (465167)"/><meta name="author" content="章炎(印象)"/><meta name="created" content="2020-03-01 12:51:52 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-03-01 12:51:56 +0000"/><title>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</title></head><body><h2 style="padding: 5px; border-bottom: 2px solid lightgrey; line-height: 40.5px; color: rgb(102, 102, 102); font-family: Georgia, &quot;Microsoft Yahei&quot;, &quot;WenQuanYi Micro Hei&quot;; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="border-bottom: 2px solid lightgrey; line-height: 40.5px; color: rgb(102, 102, 102); font-family: Georgia, &quot;Microsoft Yahei&quot;, &quot;WenQuanYi Micro Hei&quot;; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
</span></h2><div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">今天我要跟你聊聊MySQL的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</span><span style="-en-paragraph:true;">。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介绍。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。
</span></div><h1>全局锁
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">全局锁的典型使用场景是，做全库逻辑备份。</span><span style="-en-paragraph:true;">也就是把整库每个表都select出来存成文本。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">但是让整库都只读，听上去就很危险：
</span></div><ul style="padding-left: 10px;"><li style=""><div>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</div></li><li style=""><div>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表(u_course)，会怎么样呢？你可以看一下这个图：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/06-3DAB07E4-45E9-4681-9126-ECDA46C9B5AA.png" height="856" width="1142"/></div><center>图1 业务和备份状态图</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的，对吧？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">是的，就是在可重复读隔离级别下开启一个事务。
</span></div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第3篇文章</span><a href="https://time.geekbang.org/column/article/68963" style="border-bottom: 1px dashed red;-en-paragraph:true;">《事务隔离：为什么你改了我还看不见？》</a><span style="-en-paragraph:true;">中的相关内容。
</span></div></blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？</span><span style="font-weight: bold;-en-paragraph:true;">一致性读是好，但前提是引擎要支持这个隔离级别。</span><span style="-en-paragraph:true;">比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，</span><span style="font-weight: bold;-en-paragraph:true;">single-transaction方法只适用于所有的表使用事务引擎的库。</span><span style="-en-paragraph:true;">如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你也许会问，</span><span style="font-weight: bold;-en-paragraph:true;">既然要全库只读，为什么不使用set global readonly=true的方式呢</span><span style="-en-paragraph:true;">？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：
</span></div><ul style="padding-left: 10px;"><li style=""><div>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</div></li><li style=""><div>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。
</span></div><h1>表级锁
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">表锁的语法是 lock tables … read/write。</span><span style="-en-paragraph:true;">与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">另一类表级的锁是MDL（metadata lock)。</span><span style="-en-paragraph:true;">MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
</span></div><ul style="padding-left: 10px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。
</span></div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。
</span></div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">备注：这里的实验环境是MySQL 5.6。
</span></div></blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/06-F002F71C-C18E-4354-A673-24ED786E580E.jpg" height="856" width="1142"/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">基于上面的分析，我们来讨论一个问题，</span><span style="font-weight: bold;-en-paragraph:true;">如何安全地给小表加字段？</span><span style="-en-paragraph:true;"
/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">ALTER TABLE tbl_name NOWAIT add column ...</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">ALTER TABLE tbl_name WAIT N add column ... </span></div></div><h1>小结
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">今天，我跟你介绍了MySQL的全局锁和表级锁。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–single-transaction参数，对应用会更友好。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：
</span></div><ul style="padding-left: 10px;"><li style=""><div>要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；</div></li><li style=""><div>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">说明：这篇文章没有介绍到物理备份，物理备份会有一篇单独的文章。
</span></div><h1>上期问题时间
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">上期的问题是关于对联合主键索引和InnoDB索引组织表的理解。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我直接贴@老杨同志 的回复略作修改如下（我修改的部分用橙色标出）：
</span></div><div>表记录</div><div>–a--|–b--|–c--|–d--</div><div>1 2 3 d</div><div>1 3 2 d</div><div>1 4 3 d</div><div>2 1 3 d</div><div>2 2 2 d</div><div>2 3 4 d</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。
</span></div><div>索引 ca 的组织是先按c排序，再按a排序，同时记录主键</div><div>–c--|–a--|–主键部分b-- （注意，这里不是ab，而是只有b）</div><div>2 1 3</div><div>2 2 2</div><div>3 1 2</div><div>3 1 4</div><div>3 2 1</div><div>4 2 3</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个跟索引c的数据是一模一样的。
</span></div><div>索引 cb 的组织是先按c排序，在按b排序，同时记录主键</div><div>–c--|–b--|–主键部分a-- （同上）</div><div>2 2 2</div><div>2 3 1</div><div>3 1 2</div><div>3 2 1</div><div>3 4 1</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">4 3 2
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，结论是ca可以去掉，cb需要保留。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">评论区留言点赞：
</span></div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div>@浪里白条 帮大家总结了复习要点；</div><div>@约书亚 的问题里提到了MRR优化；</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">@HwangZHen 留言言简意赅。
</span></div></blockquote></div><div><br/></div></body></html>