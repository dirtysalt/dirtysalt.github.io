<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.5.14 (465167)"/><meta name="author" content="章炎(印象)"/><meta name="created" content="2020-03-01 12:51:28 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-03-01 12:51:32 +0000"/><title>04 | 深入浅出索引（上）</title></head><body><h2 style="padding: 5px; border-bottom: 2px solid lightgrey; line-height: 40.5px; color: rgb(102, 102, 102); font-family: Georgia, &quot;Microsoft Yahei&quot;, &quot;WenQuanYi Micro Hei&quot;; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="border-bottom: 2px solid lightgrey; line-height: 40.5px; color: rgb(102, 102, 102); font-family: Georgia, &quot;Microsoft Yahei&quot;, &quot;WenQuanYi Micro Hei&quot;; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">04 | 深入浅出索引（上）
</span></h2><div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一，所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识点，加深你对数据库索引的理解。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。
</span></div><h1>索引的常见模型
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">下面我主要从使用的角度，为你简单分析一下这三种模型的区别。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的键即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/04-32C372B3-AEE9-4A74-879E-C400E911328D.png" height="856" width="1142"/></div><center>图1 哈希表示意图</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，</span><span style="font-weight: bold;-en-paragraph:true;">哈希表这种结构适用于只有等值查询的场景</span><span style="-en-paragraph:true;">，比如Memcached及其他一些NoSQL引擎。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而</span><span style="font-weight: bold;-en-paragraph:true;">有序数组在等值查询和范围查询场景中的性能就都非常优秀</span><span style="-en-paragraph:true;">。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/04-9D42C3C8-9514-4230-89AF-E643CE213B82.png" height="787" width="1142"/></div><center>图2 有序数组示意图</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，</span><span style="font-weight: bold;-en-paragraph:true;">有序数组索引只适用于静态存储引擎</span><span style="-en-paragraph:true;">，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/04-7E55EF3C-99D6-4218-A3B7-69E009369C6C.png" height="856" width="1142"/></div><center>图3 二叉搜索树示意图</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">现在，我们一起进入相对偏实战的内容吧。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。
</span></div><h1>InnoDB 的索引模型
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">每一个索引在InnoDB里面对应一棵B+树。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个表的建表语句是：
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">mysql&gt; create table T(</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">id int primary key, </span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">k int not null, </span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">name varchar(16),</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">index (k))engine=InnoDB;</span></div></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="images/04-44674831-27C2-495D-8866-4CDF309C0115.png" height="856" width="1142"/></div><center>图4 InnoDB的索引组织结构</center><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">根据上面的索引结构说明，我们来讨论一个问题：</span><span style="font-weight: bold;-en-paragraph:true;">基于主键索引和普通索引的查询有什么区别？</span><span style="-en-paragraph:true;"
/></div><ul style="padding-left: 10px;"><li style=""><div>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；</div></li><li style=""><div>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
</span></div><h1>索引维护
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">基于上面的索引维护过程说明，我们来讨论一个案例：
</span></div><blockquote style="border-left: 4px solid lightgrey; padding-left: 5px;"><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。
</span></div></blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：
</span></div><ol style="padding-left: 20px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">只有一个索引；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">该索引必须是唯一索引。
</span></div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你一定看出来了，这就是典型的KV场景。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。
</span></div><h1>小结
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">最后，我给你留下一个问题吧。对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个SQL语句可以这么写：
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">alter table T drop index k;</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">alter table T add index(k);</span></div></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果你要重建主键索引，也可以这么写：
</span></div><div style="border: 1px solid lightgrey; box-shadow: rgb(238, 238, 238) 3px 3px 3px; padding: 5px; font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; overflow: auto; font-size: 13.5px; background-color: ivory; line-height: 17.55px;"><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">alter table T drop primary key;</span></div><div><span style="font-family: Inconsolata, Consolas, &quot;DEJA VU SANS MONO&quot;, &quot;DROID SANS MONO&quot;, Proggy, monospace; font-size: 13.3333px;">alter table T add primary key(id);</span></div></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
</span></div><h1>上期问题时间
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我在上一篇文章末尾给你留下的问题是：如何避免长事务对业务的影响？
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个问题，我们可以从应用开发端和数据库端来看。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">首先，从应用开发端来看：</span></div><ol style="padding-left: 20px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）
</span></div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">其次，从数据库端来看：</span></div><ol style="padding-left: 20px;"><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">Percona的pt-kill这个工具不错，推荐使用；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；
</span></div></li><li style=""><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。
</span></div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">感谢 @壹笙☞漂泊 @王凯 @易翔 留下的高质量评论。
</span></div></div><div><br/></div></body></html>